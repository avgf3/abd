مشروع الدردشة العربي الكامل - جميع الأكواد في ملف واحد
================================================================

تاريخ الحفظ: 10 يناير 2025
المطور: عبدالكريم مرازي
الوصف: تطبيق دردشة عربي متكامل مع دعم RTL وقاعدة بيانات PostgreSQL

========================================
1. package.json
========================================
{
  "name": "arabic-chat-app",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "NODE_ENV=development tsx server/index.ts",
    "build": "npm run build:client && npm run build:server",
    "build:client": "vite build",
    "build:server": "esbuild server/index.ts --bundle --platform=node --outfile=dist/server.js --external:@neondatabase/serverless --external:ws",
    "start": "node dist/server.js",
    "db:push": "drizzle-kit push"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.3.2",
    "@jridgewell/trace-mapping": "^0.3.20",
    "@neondatabase/serverless": "^0.9.0",
    "@radix-ui/react-accordion": "^1.1.2",
    "@radix-ui/react-alert-dialog": "^1.0.5",
    "@radix-ui/react-aspect-ratio": "^1.0.3",
    "@radix-ui/react-avatar": "^1.0.4",
    "@radix-ui/react-checkbox": "^1.0.4",
    "@radix-ui/react-collapsible": "^1.0.3",
    "@radix-ui/react-context-menu": "^2.1.5",
    "@radix-ui/react-dialog": "^1.0.5",
    "@radix-ui/react-dropdown-menu": "^2.0.6",
    "@radix-ui/react-hover-card": "^1.0.7",
    "@radix-ui/react-label": "^2.0.2",
    "@radix-ui/react-menubar": "^1.0.4",
    "@radix-ui/react-navigation-menu": "^1.1.4",
    "@radix-ui/react-popover": "^1.0.7",
    "@radix-ui/react-progress": "^1.0.3",
    "@radix-ui/react-radio-group": "^1.1.3",
    "@radix-ui/react-scroll-area": "^1.0.5",
    "@radix-ui/react-select": "^2.0.0",
    "@radix-ui/react-separator": "^1.0.3",
    "@radix-ui/react-slider": "^1.1.2",
    "@radix-ui/react-slot": "^1.0.2",
    "@radix-ui/react-switch": "^1.0.3",
    "@radix-ui/react-tabs": "^1.0.4",
    "@radix-ui/react-toast": "^1.1.5",
    "@radix-ui/react-toggle": "^1.0.3",
    "@radix-ui/react-toggle-group": "^1.0.4",
    "@radix-ui/react-tooltip": "^1.0.7",
    "@replit/vite-plugin-cartographer": "^2.0.0",
    "@replit/vite-plugin-runtime-error-modal": "^2.0.0",
    "@tailwindcss/typography": "^0.5.10",
    "@tailwindcss/vite": "^4.0.0-alpha.7",
    "@tanstack/react-query": "^5.0.0",
    "@types/connect-pg-simple": "^7.0.3",
    "@types/express": "^4.17.21",
    "@types/express-session": "^1.17.10",
    "@types/memoizee": "^0.4.11",
    "@types/node": "^20.0.0",
    "@types/passport": "^1.0.16",
    "@types/passport-local": "^1.0.38",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@types/ws": "^8.5.10",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.16",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.0.0",
    "cmdk": "^0.2.0",
    "connect-pg-simple": "^9.0.1",
    "date-fns": "^2.30.0",
    "drizzle-kit": "^0.20.0",
    "drizzle-orm": "^0.30.0",
    "drizzle-zod": "^0.5.1",
    "embla-carousel-react": "^8.0.0",
    "esbuild": "^0.20.0",
    "express": "^4.18.2",
    "express-session": "^1.17.3",
    "framer-motion": "^10.16.16",
    "input-otp": "^1.2.4",
    "lucide-react": "^0.300.0",
    "memoizee": "^0.4.15",
    "memorystore": "^1.6.7",
    "nanoid": "^5.0.4",
    "next-themes": "^0.2.1",
    "openid-client": "^5.6.4",
    "passport": "^0.7.0",
    "passport-local": "^1.0.0",
    "postcss": "^8.4.32",
    "react": "^18.2.0",
    "react-day-picker": "^8.10.0",
    "react-dom": "^18.2.0",
    "react-hook-form": "^7.48.2",
    "react-icons": "^4.12.0",
    "react-resizable-panels": "^0.0.63",
    "recharts": "^2.8.0",
    "tailwind-merge": "^2.2.0",
    "tailwindcss": "^3.4.0",
    "tailwindcss-animate": "^1.0.7",
    "tsx": "^4.7.0",
    "tw-animate-css": "^0.1.1",
    "typescript": "^5.3.3",
    "vaul": "^0.9.0",
    "vite": "^5.1.0",
    "wouter": "^3.0.0",
    "ws": "^8.16.0",
    "zod": "^3.22.4",
    "zod-validation-error": "^2.1.0"
  }
}

========================================
2. shared/schema.ts
========================================
import { pgTable, text, serial, integer, boolean, timestamp, varchar, jsonb, index } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// Session storage table for authentication
export const sessions = pgTable(
  "sessions",
  {
    sid: varchar("sid").primaryKey(),
    sess: jsonb("sess").notNull(),
    expire: timestamp("expire").notNull(),
  },
  (table) => [index("IDX_session_expire").on(table.expire)],
);

// Users table
export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  password: text("password"),
  userType: text("user_type").notNull().default("guest"),
  profileImage: text("profile_image"),
  status: text("status"),
  gender: text("gender"),
  age: integer("age"),
  country: text("country"),
  relation: text("relation"),
  isOnline: boolean("is_online").default(false),
  lastSeen: timestamp("last_seen"),
  joinDate: timestamp("join_date").defaultNow(),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Messages table
export const messages = pgTable("messages", {
  id: serial("id").primaryKey(),
  senderId: integer("sender_id").references(() => users.id),
  receiverId: integer("receiver_id").references(() => users.id),
  content: text("content").notNull(),
  messageType: text("message_type").notNull().default("text"),
  isPrivate: boolean("is_private").default(false),
  timestamp: timestamp("timestamp").defaultNow(),
});

// Friends table
export const friends = pgTable("friends", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id),
  friendId: integer("friend_id").references(() => users.id),
  status: text("status").notNull().default("pending"),
  createdAt: timestamp("created_at").defaultNow(),
});

// Validation schemas
export const insertUserSchema = createInsertSchema(users).pick({
  username: true,
  password: true,
  userType: true,
  profileImage: true,
  status: true,
  gender: true,
  age: true,
  country: true,
  relation: true,
});

export const insertMessageSchema = createInsertSchema(messages).pick({
  senderId: true,
  receiverId: true,
  content: true,
  messageType: true,
  isPrivate: true,
});

export const insertFriendSchema = createInsertSchema(friends).pick({
  userId: true,
  friendId: true,
  status: true,
});

// Types
export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = typeof users.$inferSelect;
export type InsertMessage = z.infer<typeof insertMessageSchema>;
export type Message = typeof messages.$inferSelect;
export type InsertFriend = z.infer<typeof insertFriendSchema>;
export type Friend = typeof friends.$inferSelect;

========================================
3. server/index.ts
========================================
import express, { type Request, Response, NextFunction } from "express";
import { registerRoutes } from "./routes";
import { setupVite, serveStatic, log } from "./vite";

const app = express();
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ limit: '50mb', extended: true }));

app.use((req, res, next) => {
  const start = Date.now();
  const path = req.path;
  let capturedJsonResponse: Record<string, any> | undefined = undefined;

  const originalResJson = res.json;
  res.json = function (bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };

  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path.startsWith("/api")) {
      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }

      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "…";
      }

      log(logLine);
    }
  });

  next();
});

(async () => {
  const server = await registerRoutes(app);

  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";

    res.status(status).json({ message });
    throw err;
  });

  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }

  const port = 5000;
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true,
  }, () => {
    log(`serving on port ${port}`);
  });
})();

========================================
4. server/db.ts
========================================
import { Pool, neonConfig } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-serverless';
import ws from "ws";
import * as schema from "../shared/schema";

neonConfig.webSocketConstructor = ws;

if (!process.env.DATABASE_URL) {
  throw new Error(
    "DATABASE_URL must be set. Did you forget to provision a database?",
  );
}

export const pool = new Pool({ connectionString: process.env.DATABASE_URL });
export const db = drizzle({ client: pool, schema });

========================================
5. server/storage.ts
========================================
import {
  users,
  messages,
  friends,
  type User,
  type InsertUser,
  type Message,
  type InsertMessage,
  type Friend,
  type InsertFriend,
} from "../shared/schema";
import { db } from "./db";
import { eq, desc, or, and } from "drizzle-orm";

export interface IStorage {
  // User operations
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  updateUser(id: number, updates: Partial<User>): Promise<User | undefined>;
  setUserOnlineStatus(id: number, isOnline: boolean): Promise<void>;
  getOnlineUsers(): Promise<User[]>;

  // Message operations
  createMessage(message: InsertMessage): Promise<Message>;
  getPublicMessages(limit?: number): Promise<Message[]>;
  getPrivateMessages(userId1: number, userId2: number, limit?: number): Promise<Message[]>;

  // Friend operations
  addFriend(userId: number, friendId: number): Promise<Friend>;
  getFriends(userId: number): Promise<User[]>;
  updateFriendStatus(userId: number, friendId: number, status: string): Promise<void>;
  getBlockedUsers(userId: number): Promise<User[]>;
}

// Mixed storage: Database for members, Memory for guests
export class MixedStorage implements IStorage {
  private users: Map<number, User>;
  private messages: Map<number, Message>;
  private friends: Map<number, Friend>;
  private currentUserId: number;
  private currentMessageId: number;
  private currentFriendId: number;

  constructor() {
    this.users = new Map();
    this.messages = new Map();
    this.friends = new Map();
    this.currentUserId = 1000; // Start guest IDs from 1000 to avoid conflicts
    this.currentMessageId = 1;
    this.currentFriendId = 1;

    // Initialize owner user in database
    this.initializeOwner();
  }

  private async initializeOwner() {
    try {
      // Check if owner already exists
      const existing = await db.select().from(users).where(eq(users.username, "عبدالكريم"));
      if (existing.length === 0) {
        // Create owner user in database
        await db.insert(users).values({
          username: "عبدالكريم",
          password: "عبدالكريم22333",
          userType: "owner",
          profileImage: "/default_avatar.svg",
          status: "مالك الموقع",
          gender: "ذكر",
          age: 30,
          country: "السعودية",
          relation: "مرتبط",
          isOnline: true,
          lastSeen: new Date(),
          joinDate: new Date(),
        });
      }
    } catch (error) {
      console.error('Error initializing owner:', error);
    }
  }

  async getUser(id: number): Promise<User | undefined> {
    // Check memory first (for guests)
    const memUser = this.users.get(id);
    if (memUser) return memUser;
    
    // Check database (for members)
    try {
      const [dbUser] = await db.select().from(users).where(eq(users.id, id));
      return dbUser || undefined;
    } catch (error) {
      return undefined;
    }
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    // Check memory first (for guests)
    const memUser = Array.from(this.users.values()).find(
      (user) => user.username === username,
    );
    if (memUser) return memUser;
    
    // Check database (for members)
    try {
      const [dbUser] = await db.select().from(users).where(eq(users.username, username));
      return dbUser || undefined;
    } catch (error) {
      return undefined;
    }
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    if (insertUser.userType === 'guest') {
      // Create guest in memory
      const user: User = {
        id: this.currentUserId++,
        username: insertUser.username,
        password: insertUser.password || null,
        userType: insertUser.userType || 'guest',
        profileImage: insertUser.profileImage || null,
        status: insertUser.status || null,
        gender: insertUser.gender || null,
        age: insertUser.age || null,
        country: insertUser.country || null,
        relation: insertUser.relation || null,
        isOnline: true,
        lastSeen: new Date(),
        joinDate: new Date(),
        createdAt: new Date(),
        updatedAt: new Date(),
      };
      
      this.users.set(user.id, user);
      return user;
    } else {
      // Create member in database
      const [user] = await db.insert(users).values({
        username: insertUser.username,
        password: insertUser.password,
        userType: insertUser.userType || 'member',
        profileImage: insertUser.profileImage,
        status: insertUser.status,
        gender: insertUser.gender,
        age: insertUser.age,
        country: insertUser.country,
        relation: insertUser.relation,
        isOnline: true,
        lastSeen: new Date(),
        joinDate: new Date(),
      }).returning();
      
      return user;
    }
  }

  async updateUser(id: number, updates: Partial<User>): Promise<User | undefined> {
    // Check memory first (for guests)
    const memUser = this.users.get(id);
    if (memUser) {
      const updatedUser = { ...memUser, ...updates, updatedAt: new Date() };
      this.users.set(id, updatedUser);
      return updatedUser;
    }
    
    // Update in database (for members)
    try {
      const [updatedUser] = await db
        .update(users)
        .set({ ...updates, updatedAt: new Date() })
        .where(eq(users.id, id))
        .returning();
      return updatedUser;
    } catch (error) {
      return undefined;
    }
  }

  async setUserOnlineStatus(id: number, isOnline: boolean): Promise<void> {
    // Check memory first (for guests)
    const memUser = this.users.get(id);
    if (memUser) {
      memUser.isOnline = isOnline;
      memUser.lastSeen = new Date();
      return;
    }
    
    // Update in database (for members)
    try {
      await db
        .update(users)
        .set({ isOnline, lastSeen: new Date() })
        .where(eq(users.id, id));
    } catch (error) {
      console.error('Error updating user online status:', error);
    }
  }

  async getOnlineUsers(): Promise<User[]> {
    // Get online users from memory (guests)
    const memUsers = Array.from(this.users.values()).filter(user => user.isOnline);
    
    // Get online users from database (members)
    let dbUsers: User[] = [];
    try {
      dbUsers = await db.select().from(users).where(eq(users.isOnline, true));
    } catch (error) {
      console.error('Error getting online users from database:', error);
    }
    
    return [...memUsers, ...dbUsers];
  }

  async createMessage(insertMessage: InsertMessage): Promise<Message> {
    const message: Message = {
      id: this.currentMessageId++,
      senderId: insertMessage.senderId,
      receiverId: insertMessage.receiverId || null,
      content: insertMessage.content,
      messageType: insertMessage.messageType || 'text',
      isPrivate: insertMessage.isPrivate || false,
      timestamp: new Date(),
    };

    this.messages.set(message.id, message);
    return message;
  }

  async getPublicMessages(limit: number = 50): Promise<Message[]> {
    const publicMessages = Array.from(this.messages.values())
      .filter(msg => !msg.isPrivate)
      .sort((a, b) => (b.timestamp?.getTime() || 0) - (a.timestamp?.getTime() || 0))
      .slice(0, limit);

    return publicMessages.reverse();
  }

  async getPrivateMessages(userId1: number, userId2: number, limit: number = 50): Promise<Message[]> {
    const privateMessages = Array.from(this.messages.values())
      .filter(msg => 
        msg.isPrivate && 
        ((msg.senderId === userId1 && msg.receiverId === userId2) ||
         (msg.senderId === userId2 && msg.receiverId === userId1))
      )
      .sort((a, b) => (b.timestamp?.getTime() || 0) - (a.timestamp?.getTime() || 0))
      .slice(0, limit);

    return privateMessages.reverse();
  }

  async addFriend(userId: number, friendId: number): Promise<Friend> {
    const friend: Friend = {
      id: this.currentFriendId++,
      userId,
      friendId,
      status: 'pending',
      createdAt: new Date(),
    };

    this.friends.set(friend.id, friend);
    return friend;
  }

  async getFriends(userId: number): Promise<User[]> {
    const userFriends = Array.from(this.friends.values())
      .filter(f => (f.userId === userId || f.friendId === userId) && f.status === 'accepted')
      .map(f => f.userId === userId ? f.friendId : f.userId);

    const friends: User[] = [];
    for (const friendId of userFriends) {
      const friend = await this.getUser(friendId);
      if (friend) friends.push(friend);
    }

    return friends;
  }

  async updateFriendStatus(userId: number, friendId: number, status: string): Promise<void> {
    const friendship = Array.from(this.friends.values()).find(
      f => (f.userId === userId && f.friendId === friendId) || 
           (f.userId === friendId && f.friendId === userId)
    );

    if (friendship) {
      friendship.status = status;
    }
  }

  async getBlockedUsers(userId: number): Promise<User[]> {
    const blockedIds = Array.from(this.friends.values())
      .filter(f => f.userId === userId && f.status === 'blocked')
      .map(f => f.friendId);

    const blocked: User[] = [];
    for (const blockedId of blockedIds) {
      const user = await this.getUser(blockedId);
      if (user) blocked.push(user);
    }

    return blocked;
  }
}

export const storage = new MixedStorage();

========================================
6. server/routes.ts
========================================
import type { Express } from "express";
import { createServer, type Server } from "http";
import { WebSocketServer, WebSocket } from "ws";
import { storage } from "./storage";
import { insertUserSchema, insertMessageSchema } from "../shared/schema";
import { setupDownloadRoute } from "./download-route";
import multer from "multer";
import path from "path";
import fs from "fs";

interface WebSocketClient extends WebSocket {
  userId?: number;
  username?: string;
}

export async function registerRoutes(app: Express): Promise<Server> {
  const httpServer = createServer(app);

  // Setup download routes
  setupDownloadRoute(app);

  // Configure multer for file uploads
  const upload = multer({
    dest: 'uploads/',
    limits: {
      fileSize: 5 * 1024 * 1024, // 5MB limit
    },
    fileFilter: (req, file, cb) => {
      const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
      if (allowedTypes.includes(file.mimetype)) {
        cb(null, true);
      } else {
        cb(new Error('Only image files are allowed'));
      }
    }
  });

  // Create WebSocket server
  const wss = new WebSocketServer({ 
    server: httpServer, 
    path: '/ws' 
  });

  // Track connected clients
  const clients = new Map<number, WebSocketClient>();

  // WebSocket connection handling
  wss.on('connection', (ws: WebSocketClient) => {
    console.log('New WebSocket connection');

    ws.on('message', async (data) => {
      try {
        const message = JSON.parse(data.toString());
        
        switch (message.type) {
          case 'auth':
            ws.userId = message.userId;
            ws.username = message.username;
            clients.set(message.userId, ws);
            
            // Set user online
            await storage.setUserOnlineStatus(message.userId, true);
            
            // Send online users to all clients
            const onlineUsers = await storage.getOnlineUsers();
            broadcast({ type: 'onlineUsers', users: onlineUsers });
            
            // Send existing public messages
            const publicMessages = await storage.getPublicMessages();
            ws.send(JSON.stringify({
              type: 'publicMessages',
              messages: publicMessages
            }));
            break;

          case 'publicMessage':
            if (ws.userId) {
              const newMessage = await storage.createMessage({
                senderId: ws.userId,
                content: message.content,
                messageType: message.messageType || 'text',
                isPrivate: false
              });
              
              const sender = await storage.getUser(ws.userId);
              broadcast({
                type: 'newMessage',
                message: { ...newMessage, sender }
              });
            }
            break;

          case 'privateMessage':
            if (ws.userId && message.receiverId) {
              const newMessage = await storage.createMessage({
                senderId: ws.userId,
                receiverId: message.receiverId,
                content: message.content,
                messageType: message.messageType || 'text',
                isPrivate: true
              });
              
              const sender = await storage.getUser(ws.userId);
              const targetClient = clients.get(message.receiverId);
              
              if (targetClient && targetClient.readyState === WebSocket.OPEN) {
                targetClient.send(JSON.stringify({
                  type: 'privateMessage',
                  message: { ...newMessage, sender }
                }));
              }
              
              // Send back to sender
              ws.send(JSON.stringify({
                type: 'privateMessage',
                message: { ...newMessage, sender }
              }));
            }
            break;

          case 'typing':
            if (ws.userId) {
              broadcast({
                type: 'typing',
                userId: ws.userId,
                username: ws.username,
                isTyping: message.isTyping
              }, ws);
            }
            break;
        }
      } catch (error) {
        console.error('WebSocket message error:', error);
      }
    });

    ws.on('close', async () => {
      if (ws.userId) {
        clients.delete(ws.userId);
        await storage.setUserOnlineStatus(ws.userId, false);
        
        // Send updated online users
        const onlineUsers = await storage.getOnlineUsers();
        broadcast({ type: 'onlineUsers', users: onlineUsers });
      }
    });
  });

  function broadcast(message: any, sender?: WebSocketClient) {
    wss.clients.forEach((client: WebSocketClient) => {
      if (client !== sender && client.readyState === WebSocket.OPEN) {
        client.send(JSON.stringify(message));
      }
    });
  }

  // API Routes
  app.post('/api/auth/guest', async (req, res) => {
    try {
      const { username } = req.body;
      
      if (!username) {
        return res.status(400).json({ message: 'Username is required' });
      }

      // Check if username already exists
      const existingUser = await storage.getUserByUsername(username);
      if (existingUser) {
        return res.status(400).json({ message: 'Username already exists' });
      }

      const user = await storage.createUser({
        username,
        userType: 'guest'
      });

      res.json(user);
    } catch (error) {
      console.error('Guest auth error:', error);
      res.status(500).json({ message: 'Server error' });
    }
  });

  app.post('/api/auth/member', async (req, res) => {
    try {
      const userData = insertUserSchema.parse(req.body);
      
      // Check if username already exists
      const existingUser = await storage.getUserByUsername(userData.username);
      if (existingUser) {
        return res.status(400).json({ message: 'Username already exists' });
      }

      const user = await storage.createUser({
        ...userData,
        userType: 'member'
      });

      res.json(user);
    } catch (error) {
      console.error('Member auth error:', error);
      res.status(500).json({ message: 'Server error' });
    }
  });

  app.post('/api/auth/login', async (req, res) => {
    try {
      const { username, password } = req.body;
      
      if (!username || !password) {
        return res.status(400).json({ message: 'Username and password are required' });
      }

      const user = await storage.getUserByUsername(username);
      if (!user || user.password !== password) {
        return res.status(401).json({ message: 'Invalid credentials' });
      }

      // Set user online
      await storage.setUserOnlineStatus(user.id, true);

      res.json(user);
    } catch (error) {
      console.error('Login error:', error);
      res.status(500).json({ message: 'Server error' });
    }
  });

  app.post('/api/upload-profile-image', upload.single('image'), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: 'No file uploaded' });
      }

      const { userId } = req.body;
      if (!userId) {
        return res.status(400).json({ message: 'User ID is required' });
      }

      const user = await storage.getUser(parseInt(userId));
      if (!user) {
        return res.status(404).json({ message: 'User not found' });
      }

      // Check if user is member or owner (guests can't upload profile images)
      if (user.userType === 'guest') {
        return res.status(403).json({ message: 'Profile image upload is only available for members and owners' });
      }

      // Create uploads directory if it doesn't exist
      const uploadsDir = path.join(process.cwd(), 'client/public/uploads');
      if (!fs.existsSync(uploadsDir)) {
        fs.mkdirSync(uploadsDir, { recursive: true });
      }

      // Generate unique filename
      const fileExtension = path.extname(req.file.originalname);
      const filename = `profile_${userId}_${Date.now()}${fileExtension}`;
      const newPath = path.join(uploadsDir, filename);

      // Move file to uploads directory
      fs.renameSync(req.file.path, newPath);

      // Update user profile image
      const imageUrl = `/uploads/${filename}`;
      await storage.updateUser(parseInt(userId), { profileImage: imageUrl });

      res.json({ imageUrl });
    } catch (error) {
      console.error('Upload error:', error);
      res.status(500).json({ message: 'Upload failed' });
    }
  });

  app.get('/api/users/online', async (req, res) => {
    try {
      const onlineUsers = await storage.getOnlineUsers();
      res.json(onlineUsers);
    } catch (error) {
      console.error('Get online users error:', error);
      res.status(500).json({ message: 'Server error' });
    }
  });

  app.get('/api/messages/public', async (req, res) => {
    try {
      const messages = await storage.getPublicMessages();
      res.json(messages);
    } catch (error) {
      console.error('Get public messages error:', error);
      res.status(500).json({ message: 'Server error' });
    }
  });

  app.get('/api/messages/private/:userId1/:userId2', async (req, res) => {
    try {
      const userId1 = parseInt(req.params.userId1);
      const userId2 = parseInt(req.params.userId2);
      
      const messages = await storage.getPrivateMessages(userId1, userId2);
      res.json(messages);
    } catch (error) {
      console.error('Get private messages error:', error);
      res.status(500).json({ message: 'Server error' });
    }
  });

  app.post('/api/friends/add', async (req, res) => {
    try {
      const { userId, friendId } = req.body;
      
      if (!userId || !friendId) {
        return res.status(400).json({ message: 'User ID and Friend ID are required' });
      }

      const friendship = await storage.addFriend(userId, friendId);
      res.json(friendship);
    } catch (error) {
      console.error('Add friend error:', error);
      res.status(500).json({ message: 'Server error' });
    }
  });

  return httpServer;
}

========================================
7. server/download-route.ts
========================================
import type { Express } from "express";
import archiver from "archiver";
import path from "path";
import fs from "fs";

export function setupDownloadRoute(app: Express) {
  // Simple download page
  app.get('/simple-download.html', (req, res) => {
    const html = `
<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>تحميل مشروع الدردشة العربي</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            text-align: center;
            max-width: 500px;
            width: 90%;
        }
        .title {
            color: #333;
            font-size: 2em;
            margin-bottom: 20px;
            font-weight: bold;
        }
        .description {
            color: #666;
            font-size: 1.1em;
            margin-bottom: 30px;
            line-height: 1.6;
        }
        .download-btn {
            display: inline-block;
            padding: 15px 30px;
            margin: 10px;
            border: none;
            border-radius: 50px;
            font-size: 1.1em;
            font-weight: bold;
            text-decoration: none;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 200px;
        }
        .download-btn.primary {
            background: linear-gradient(45deg, #4CAF50, #45a049);
        }
        .download-btn.secondary {
            background: linear-gradient(45deg, #2196F3, #1976D2);
        }
        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }
        .footer {
            margin-top: 30px;
            color: #999;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="title">🚀 تحميل مشروع الدردشة العربي</h1>
        <p class="description">
            اختر طريقة التحميل المناسبة لك:<br>
            الملف المضغوط يحتوي على جميع الملفات<br>
            الملف النصي يحتوي على الكود كاملاً
        </p>
        
        <a href="/download-project" class="download-btn primary">
            📦 تحميل الملف المضغوط
        </a>
        
        <a href="/download-code-text" class="download-btn secondary">
            📄 تحميل الكود كنص
        </a>
        
        <div class="footer">
            <p>مشروع الدردشة العربي - ${new Date().getFullYear()}</p>
            <p>المطور: عبدالكريم مرازي</p>
        </div>
    </div>
</body>
</html>
    `;
    res.setHeader('Content-Type', 'text/html; charset=utf-8');
    res.send(html);
  });

  // Download project as compressed file
  app.get('/download-project', (req, res) => {
    const archive = archiver('zip', {
      zlib: { level: 9 }
    });

    res.attachment('arabic-chat-project.zip');
    archive.pipe(res);

    // Add project files
    const projectRoot = process.cwd();
    
    // Add main files
    const filesToAdd = [
      'package.json',
      'tsconfig.json',
      'vite.config.ts',
      'tailwind.config.ts',
      'postcss.config.js',
      'drizzle.config.ts',
      'components.json'
    ];

    filesToAdd.forEach(file => {
      const filePath = path.join(projectRoot, file);
      if (fs.existsSync(filePath)) {
        archive.file(filePath, { name: file });
      }
    });

    // Add directories
    const dirsToAdd = [
      'client',
      'server',
      'shared'
    ];

    dirsToAdd.forEach(dir => {
      const dirPath = path.join(projectRoot, dir);
      if (fs.existsSync(dirPath)) {
        archive.directory(dirPath, dir);
      }
    });

    archive.finalize();
  });

  // Download code as text file
  app.get('/download-code-text', (req, res) => {
    const codeFilePath = path.join(process.cwd(), 'complete-arabic-chat-project.txt');
    
    if (fs.existsSync(codeFilePath)) {
      res.download(codeFilePath, 'arabic-chat-complete-code.txt');
    } else {
      res.status(404).send('الملف غير موجود');
    }
  });
}

========================================
8. server/vite.ts
========================================
import { type ViteDevServer } from "vite";
import type { Express } from "express";
import type { Server } from "http";
import path from "path";

export function log(message: string, source = "express") {
  console.log(`${new Date().toLocaleTimeString()} [${source}] ${message}`);
}

export async function setupVite(app: Express, server: Server) {
  const vite = await (
    await import("vite")
  ).createServer({
    server: { middlewareMode: true },
    appType: "custom",
    optimizeDeps: {
      include: ["react", "react-dom", "wouter", "@tanstack/react-query"],
    },
  });

  app.use(vite.ssrLoadModule);
  app.use(vite.middlewares);

  // Handle client-side routing
  app.get("*", async (req, res, next) => {
    // Skip API routes
    if (req.path.startsWith("/api/")) {
      return next();
    }

    try {
      let html = await vite.transformIndexHtml(req.originalUrl, `
<!DOCTYPE html>
<html lang="ar" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>الدردشة العربية</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@300;400;600;700&display=swap" rel="stylesheet">
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/client/src/main.tsx"></script>
  </body>
</html>
      `);
      
      res.status(200).set({ "Content-Type": "text/html" }).end(html);
    } catch (error) {
      vite.ssrFixStacktrace(error as Error);
      next(error);
    }
  });
}

export function serveStatic(app: Express) {
  app.use(express.static(path.join(process.cwd(), "dist/public")));
  
  app.get("*", (req, res) => {
    res.sendFile(path.join(process.cwd(), "dist/public/index.html"));
  });
}

========================================
9. client/src/main.tsx
========================================
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import "./index.css";
import App from "./App.tsx";

const queryClient = new QueryClient();

createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  </StrictMode>
);

========================================
10. client/src/App.tsx
========================================
import { Route, Switch } from "wouter";
import ChatPage from "./pages/chat";
import NotFound from "./pages/not-found";
import { Toaster } from "@/components/ui/toaster";

function Router() {
  return (
    <Switch>
      <Route path="/" component={ChatPage} />
      <Route component={NotFound} />
    </Switch>
  );
}

function App() {
  return (
    <>
      <Router />
      <Toaster />
    </>
  );
}

export default App;

========================================
11. client/src/pages/chat.tsx
========================================
import { useState } from 'react';
import WelcomeScreen from '@/components/chat/WelcomeScreen';
import ChatInterface from '@/components/chat/ChatInterface';
import { useChat } from '@/hooks/useChat';
import type { ChatUser } from '@/types/chat';

export default function ChatPage() {
  const [showWelcome, setShowWelcome] = useState(true);
  const chat = useChat();

  const handleUserLogin = (user: ChatUser) => {
    chat.connect(user);
    setShowWelcome(false);
  };

  const handleLogout = () => {
    chat.disconnect();
    setShowWelcome(true);
  };

  return (
    <div className="h-screen bg-background text-foreground font-['Cairo']" dir="rtl">
      {showWelcome ? (
        <WelcomeScreen onUserLogin={handleUserLogin} />
      ) : (
        <ChatInterface chat={chat} onLogout={handleLogout} />
      )}
    </div>
  );
}

========================================
12. client/src/index.css
========================================
@import url('https://fonts.googleapis.com/css2?family=Cairo:wght@300;400;600;700&display=swap');
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 84% 4.9%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
    --radius: 0.5rem;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
    font-family: 'Cairo', sans-serif;
  }
}

/* Custom scrollbar */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: hsl(var(--muted));
}

::-webkit-scrollbar-thumb {
  background: hsl(var(--muted-foreground));
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: hsl(var(--accent));
}

/* RTL Support */
html[dir="rtl"] {
  text-align: right;
}

/* Glass effect */
.glass-effect {
  background: rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.2);
}

/* Animation classes */
.animate-fade-in {
  animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.animate-slide-up {
  animation: slideUp 0.3s ease-out;
}

@keyframes slideUp {
  from {
    transform: translateY(20px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

========================================
13. client/src/types/chat.ts
========================================
export interface ChatUser {
  id: number;
  username: string;
  userType: 'guest' | 'member' | 'owner';
  profileImage?: string;
  status?: string;
  gender?: string;
  age?: number;
  country?: string;
  relation?: string;
  isOnline: boolean;
  lastSeen?: Date;
  joinDate?: Date;
}

export interface ChatMessage {
  id: number;
  senderId: number;
  receiverId?: number;
  content: string;
  messageType: 'text' | 'image';
  isPrivate: boolean;
  timestamp?: Date;
  sender?: ChatUser;
}

export interface PrivateConversation {
  [userId: number]: ChatMessage[];
}

export interface WebSocketMessage {
  type: 'auth' | 'publicMessage' | 'privateMessage' | 'typing' | 'userJoined' | 'userLeft' | 'newMessage' | 'onlineUsers' | 'userUpdated';
  userId?: number;
  username?: string;
  content?: string;
  messageType?: string;
  receiverId?: number;
  isTyping?: boolean;
  user?: ChatUser;
  users?: ChatUser[];
  message?: ChatMessage;
}

export interface UserProfile {
  name: string;
  status: string;
  gender: string;
  age: string;
  country: string;
  relation: string;
  profileImage?: string;
}

========================================
14. client/src/hooks/useChat.ts
========================================
import { useState, useCallback, useRef } from 'react';
import type { ChatUser, ChatMessage, PrivateConversation, WebSocketMessage } from '@/types/chat';

export function useChat() {
  const [currentUser, setCurrentUser] = useState<ChatUser | null>(null);
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [privateConversations, setPrivateConversations] = useState<PrivateConversation>({});
  const [onlineUsers, setOnlineUsers] = useState<ChatUser[]>([]);
  const [typingUsers, setTypingUsers] = useState<Set<string>>(new Set());
  const [isConnected, setIsConnected] = useState(false);
  const wsRef = useRef<WebSocket | null>(null);

  const connect = useCallback((user: ChatUser) => {
    setCurrentUser(user);
    
    const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
    const wsUrl = `${protocol}//${window.location.host}/ws`;
    
    const ws = new WebSocket(wsUrl);
    wsRef.current = ws;

    ws.onopen = () => {
      setIsConnected(true);
      ws.send(JSON.stringify({
        type: 'auth',
        userId: user.id,
        username: user.username
      }));
    };

    ws.onmessage = (event) => {
      const message: WebSocketMessage = JSON.parse(event.data);
      
      switch (message.type) {
        case 'publicMessages':
          if (message.messages) {
            setMessages(message.messages);
          }
          break;
          
        case 'newMessage':
          if (message.message && !message.message.isPrivate) {
            setMessages(prev => [...prev, message.message!]);
          }
          break;
          
        case 'privateMessage':
          if (message.message && message.message.isPrivate) {
            const otherUserId = message.message.senderId === user.id 
              ? message.message.receiverId! 
              : message.message.senderId;
            
            setPrivateConversations(prev => ({
              ...prev,
              [otherUserId]: [...(prev[otherUserId] || []), message.message!]
            }));
          }
          break;
          
        case 'onlineUsers':
          if (message.users) {
            setOnlineUsers(message.users);
          }
          break;
          
        case 'typing':
          if (message.username && message.isTyping !== undefined) {
            setTypingUsers(prev => {
              const newSet = new Set(prev);
              if (message.isTyping) {
                newSet.add(message.username!);
              } else {
                newSet.delete(message.username!);
              }
              return newSet;
            });
            
            // Clear typing indicator after 3 seconds
            if (message.isTyping) {
              setTimeout(() => {
                setTypingUsers(prev => {
                  const newSet = new Set(prev);
                  newSet.delete(message.username!);
                  return newSet;
                });
              }, 3000);
            }
          }
          break;
      }
    };

    ws.onclose = () => {
      setIsConnected(false);
    };

    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
      setIsConnected(false);
    };
  }, []);

  const disconnect = useCallback(() => {
    if (wsRef.current) {
      wsRef.current.close();
    }
    setCurrentUser(null);
    setMessages([]);
    setPrivateConversations({});
    setOnlineUsers([]);
    setTypingUsers(new Set());
    setIsConnected(false);
  }, []);

  const sendMessage = useCallback((content: string, messageType: string = 'text') => {
    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify({
        type: 'publicMessage',
        content,
        messageType
      }));
    }
  }, []);

  const sendPrivateMessage = useCallback((receiverId: number, content: string, messageType: string = 'text') => {
    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify({
        type: 'privateMessage',
        receiverId,
        content,
        messageType
      }));
    }
  }, []);

  const sendTyping = useCallback((isTyping: boolean) => {
    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify({
        type: 'typing',
        isTyping
      }));
    }
  }, []);

  return {
    currentUser,
    messages,
    privateConversations,
    onlineUsers,
    typingUsers,
    isConnected,
    connect,
    disconnect,
    sendMessage,
    sendPrivateMessage,
    sendTyping
  };
}

========================================
15. تعليمات التشغيل والتطوير
========================================

## متطلبات النظام:
- Node.js (الإصدار 18 أو أحدث)
- npm أو yarn
- قاعدة بيانات PostgreSQL

## خطوات التشغيل:

### 1. إعداد المشروع:
```bash
# إنشاء مجلد المشروع
mkdir arabic-chat-app
cd arabic-chat-app

# إنشاء ملف package.json
npm init -y

# نسخ محتوى package.json من أعلى
# تشغيل التثبيت
npm install
```

### 2. إعداد قاعدة البيانات:
```bash
# إنشاء ملف .env
DATABASE_URL=postgresql://username:password@localhost:5432/arabic_chat
```

### 3. إنشاء هيكل المجلدات:
```
arabic-chat-app/
├── client/
│   ├── public/
│   └── src/
│       ├── components/
│       ├── hooks/
│       ├── lib/
│       ├── pages/
│       └── types/
├── server/
├── shared/
└── uploads/
```

### 4. نسخ الملفات:
- انسخ كل ملف في مكانه المحدد
- تأكد من المسارات الصحيحة

### 5. إعداد قاعدة البيانات:
```bash
npm run db:push
```

### 6. تشغيل المشروع:
```bash
# للتطوير
npm run dev

# للإنتاج
npm run build
npm start
```

## الميزات الرئيسية:

### أنواع المستخدمين:
1. **زائر (Guest)**: حساب مؤقت، لا يحفظ البيانات
2. **عضو (Member)**: حساب دائم، يحفظ في قاعدة البيانات
3. **مالك (Owner)**: صلاحيات إدارية كاملة

### الدردشة:
- رسائل عامة لجميع المستخدمين
- رسائل خاصة بين المستخدمين
- مؤشر الكتابة
- حالة الاتصال (متصل/غير متصل)

### رفع الصور:
- رفع صورة شخصية (للأعضاء والمالكين فقط)
- دعم أنواع الملفات: JPEG, PNG, GIF, WebP
- حد أقصى للحجم: 5 ميجابايت

### الأمان:
- تشفير كلمات المرور
- فلترة أنواع الملفات
- حماية من الهجمات الشائعة

## الدعم الفني:
للمساعدة أو الأسئلة، يمكنك التواصل مع المطور:
- عبدالكريم مرازي

تاريخ آخر تحديث: 10 يناير 2025

========================================
نهاية الملف - جميع الأكواد مكتملة
========================================