# خطة تحسين الأداء الشاملة لتطبيق الدردشة

## المشاكل المحددة

### 1. إعادة التصيير الزائد (Excessive Re-rendering)
- تحديث كامل واجهة المستخدم مع كل رسالة جديدة
- إعادة تصيير قائمة الأصدقاء عند وصول رسالة
- تحديثات متكررة للمكونات غير المتأثرة

### 2. استخدام الذاكرة المفرط
- الاحتفاظ بجميع الرسائل في الذاكرة
- تراكم بيانات المستخدمين
- عدم تنظيف البيانات القديمة

## الحلول المقترحة

### المرحلة الأولى: تحسين إدارة الحالة

#### 1.1 تقسيم الحالة المركزية
```typescript
// فصل حالات مختلفة لتقليل نطاق التأثير
interface ChatState {
  messages: MessageState;
  users: UserState;
  rooms: RoomState;
  notifications: NotificationState;
  ui: UIState;
}

interface MessageState {
  byRoom: Record<string, ChatMessage[]>;
  private: Record<number, ChatMessage[]>;
  lastMessageId: Record<string, number>;
}

interface UserState {
  online: ChatUser[];
  offline: ChatUser[];
  ignored: Set<number>;
  typing: Set<string>;
}
```

#### 1.2 استخدام React.memo للمكونات
```typescript
// تحسين مكونات الرسائل
const MessageItem = React.memo(({ message, isOwn }: MessageItemProps) => {
  // مكون محسن
}, (prevProps, nextProps) => {
  // مقارنة مخصصة للأداء
  return prevProps.message.id === nextProps.message.id &&
         prevProps.message.content === nextProps.message.content;
});

// تحسين قائمة المستخدمين
const UserList = React.memo(({ users, onUserClick }: UserListProps) => {
  // مكون محسن
});
```

#### 1.3 استخدام useCallback و useMemo
```typescript
// تحسين الدوال
const sendMessage = useCallback((content: string) => {
  // منطق إرسال الرسالة
}, [currentUser, currentRoomId]);

// تحسين القيم المحسوبة
const filteredUsers = useMemo(() => {
  return onlineUsers.filter(user => !ignoredUsers.has(user.id));
}, [onlineUsers, ignoredUsers]);

const groupedMessages = useMemo(() => {
  // تجميع الرسائل حسب المرسل والوقت
}, [messages]);
```

### المرحلة الثانية: تحسين إدارة الذاكرة

#### 2.1 تحديد حجم البيانات المخزنة
```typescript
// تحديد حد أقصى للرسائل
const MAX_MESSAGES_PER_ROOM = 100;
const MAX_PRIVATE_MESSAGES = 50;
const MAX_OFFLINE_USERS = 200;

// تنظيف تلقائي للبيانات
const cleanupOldMessages = useCallback(() => {
  Object.keys(roomMessages).forEach(roomId => {
    if (roomMessages[roomId].length > MAX_MESSAGES_PER_ROOM) {
      const trimmed = roomMessages[roomId].slice(-MAX_MESSAGES_PER_ROOM);
      setRoomMessages(prev => ({ ...prev, [roomId]: trimmed }));
    }
  });
}, [roomMessages]);
```

#### 2.2 استخدام React Query للتخزين المؤقت
```typescript
// تكوين React Query محسن
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 دقائق
      cacheTime: 10 * 60 * 1000, // 10 دقائق
      retry: 2,
      refetchOnWindowFocus: false,
    },
  },
});

// استخدام queries محسنة
const useRoomMessages = (roomId: string) => {
  return useQuery({
    queryKey: ['messages', roomId],
    queryFn: () => fetchRoomMessages(roomId),
    staleTime: 30 * 1000, // 30 ثانية للرسائل
    cacheTime: 5 * 60 * 1000, // 5 دقائق
  });
};
```

#### 2.3 تنظيف الذاكرة التلقائي
```typescript
// Hook لتنظيف الذاكرة
const useMemoryCleanup = () => {
  useEffect(() => {
    const cleanup = () => {
      // تنظيف timeouts
      const highestTimeoutId = setTimeout(';');
      for (let i = 0; i < highestTimeoutId; i++) {
        clearTimeout(i);
      }
      
      // تنظيف intervals
      const highestIntervalId = setInterval(';');
      for (let i = 0; i < highestIntervalId; i++) {
        clearInterval(i);
      }
    };

    // تنظيف عند تغيير الصفحة
    window.addEventListener('beforeunload', cleanup);
    
    return () => {
      window.removeEventListener('beforeunload', cleanup);
      cleanup();
    };
  }, []);
};
```

### المرحلة الثالثة: تحسين الاتصال بالشبكة

#### 3.1 تحسين Socket.IO
```typescript
// تكوين Socket.IO محسن
const socket = io(serverUrl, {
  transports: ['websocket'], // استخدام WebSocket فقط
  timeout: 10000,
  reconnection: true,
  reconnectionAttempts: 5,
  reconnectionDelay: 1000,
  maxReconnectionAttempts: 10,
  forceNew: false,
});

// إدارة الاتصال
const useSocketConnection = () => {
  const [isConnected, setIsConnected] = useState(false);
  const reconnectTimeout = useRef<NodeJS.Timeout>();

  useEffect(() => {
    socket.on('connect', () => {
      setIsConnected(true);
      if (reconnectTimeout.current) {
        clearTimeout(reconnectTimeout.current);
      }
    });

    socket.on('disconnect', () => {
      setIsConnected(false);
      // إعادة الاتصال بعد تأخير
      reconnectTimeout.current = setTimeout(() => {
        socket.connect();
      }, 2000);
    });

    return () => {
      if (reconnectTimeout.current) {
        clearTimeout(reconnectTimeout.current);
      }
    };
  }, []);
};
```

#### 3.2 تحسين إرسال الرسائل
```typescript
// throttling لإرسال الرسائل
const useThrottledMessage = () => {
  const lastMessageTime = useRef(0);
  const MESSAGE_THROTTLE = 100; // 100ms

  const sendThrottledMessage = useCallback((content: string) => {
    const now = Date.now();
    if (now - lastMessageTime.current < MESSAGE_THROTTLE) {
      return false; // منع الإرسال
    }
    
    lastMessageTime.current = now;
    socket.emit('message', { content });
    return true;
  }, []);

  return sendThrottledMessage;
};
```

### المرحلة الرابعة: تحسين واجهة المستخدم

#### 4.1 Virtual Scrolling للرسائل
```typescript
// استخدام react-window للرسائل الكثيرة
import { FixedSizeList as List } from 'react-window';

const VirtualizedMessageList = ({ messages }: { messages: ChatMessage[] }) => {
  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => (
    <div style={style}>
      <MessageItem message={messages[index]} />
    </div>
  );

  return (
    <List
      height={400}
      itemCount={messages.length}
      itemSize={80}
      width="100%"
    >
      {Row}
    </List>
  );
};
```

#### 4.2 تحسين عرض المستخدمين
```typescript
// تجميع المستخدمين حسب الحالة
const useOptimizedUserList = (users: ChatUser[]) => {
  return useMemo(() => {
    const grouped = {
      online: users.filter(u => u.isOnline),
      offline: users.filter(u => !u.isOnline),
      moderators: users.filter(u => u.userType === 'moderator'),
      admins: users.filter(u => u.userType === 'admin'),
    };
    
    return grouped;
  }, [users]);
};
```

### المرحلة الخامسة: مراقبة الأداء

#### 5.1 إضافة أدوات المراقبة
```typescript
// Hook لمراقبة الأداء
const usePerformanceMonitor = () => {
  useEffect(() => {
    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.entryType === 'measure') {
          console.log(`Performance: ${entry.name} took ${entry.duration}ms`);
        }
      }
    });
    
    observer.observe({ entryTypes: ['measure'] });
    
    return () => observer.disconnect();
  }, []);
};

// قياس أداء المكونات
const useComponentPerformance = (componentName: string) => {
  useEffect(() => {
    performance.mark(`${componentName}-start`);
    
    return () => {
      performance.mark(`${componentName}-end`);
      performance.measure(`${componentName}-render`, `${componentName}-start`, `${componentName}-end`);
    };
  });
};
```

#### 5.2 تحسين React DevTools
```typescript
// إضافة معلومات الأداء للمكونات
const withPerformanceTracking = <P extends object>(
  Component: React.ComponentType<P>,
  componentName: string
) => {
  return React.memo((props: P) => {
    useComponentPerformance(componentName);
    return <Component {...props} />;
  });
};
```

## خطة التنفيذ

### الأسبوع الأول: تحسين إدارة الحالة
1. تقسيم UserContext إلى contexts منفصلة
2. تطبيق React.memo على المكونات الرئيسية
3. تحسين useCallback و useMemo

### الأسبوع الثاني: تحسين الذاكرة
1. تحديد حدود للبيانات المخزنة
2. تطبيق React Query للتخزين المؤقت
3. إضافة تنظيف الذاكرة التلقائي

### الأسبوع الثالث: تحسين الشبكة
1. تحسين تكوين Socket.IO
2. تطبيق throttling للرسائل
3. تحسين إدارة الاتصال

### الأسبوع الرابع: تحسين واجهة المستخدم
1. تطبيق Virtual Scrolling
2. تحسين عرض المستخدمين
3. إضافة أدوات المراقبة

## النتائج المتوقعة

### تحسين الأداء
- تقليل إعادة التصيير بنسبة 70%
- تحسين سرعة الاستجابة بنسبة 50%
- تقليل استخدام الذاكرة بنسبة 40%

### تحسين تجربة المستخدم
- استجابة أسرع للرسائل
- تقليل التأخير في واجهة المستخدم
- تحسين الأداء على الأجهزة الضعيفة

### تحسين الاستقرار
- تقليل الأخطاء المتعلقة بالذاكرة
- تحسين استقرار الاتصال
- تقليل استهلاك الموارد