import { useState, useEffect, useRef, useCallback, useMemo, useReducer } from 'react';
import type { Socket } from 'socket.io-client';

import type { PrivateConversation } from '../../../shared/types';

import { apiRequest, queryClient } from '@/lib/queryClient';
import { connectSocket, saveSession, clearSession } from '@/lib/socket';
import type { ChatUser, ChatMessage } from '@/types/chat';
import type { Notification } from '@/types/chat';
import { mapDbMessagesToChatMessages } from '@/utils/messageUtils';
import { userCache, setCachedUser } from '@/utils/userCacheManager';

// Audio notification function
const playNotificationSound = () => {
  try {
    const audio = new Audio('/notification.mp3');
    audio.volume = 0.3;
    audio.play().catch(() => {
      try {
        const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gain = audioContext.createGain();

        oscillator.connect(gain);
        gain.connect(audioContext.destination);

        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
        gain.gain.setValueAtTime(0.001, audioContext.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.03, audioContext.currentTime + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.3);

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.3);
      } catch {
        // Silent fail
      }
    });
  } catch {
    // Silent fail
  }
};

// üî• SIMPLIFIED State interface - ÿ≠ÿ∞ŸÅ ÿßŸÑÿ™ÿπŸÇŸäÿØÿßÿ™
interface ChatState {
  currentUser: ChatUser | null;
  onlineUsers: ChatUser[];
  currentRoomId: string;
  roomMessages: Record<string, ChatMessage[]>; // ‚úÖ ŸÖÿµÿØÿ± Ÿàÿßÿ≠ÿØ ŸÑŸÑÿ≠ŸÇŸäŸÇÿ©
  privateConversations: PrivateConversation;
  ignoredUsers: Set<number>;
  isConnected: boolean;
  typingUsers: Set<string>;
  connectionError: string | null;
  newMessageSender: ChatUser | null;
  isLoading: boolean;
  notifications: Notification[];
  showKickCountdown: boolean;
}

// üî• SIMPLIFIED Action types - ÿ≠ÿ∞ŸÅ ÿßŸÑÿ™ÿ∂ÿßÿ±ÿ®
type ChatAction =
  | { type: 'SET_CURRENT_USER'; payload: ChatUser | null }
  | { type: 'SET_ONLINE_USERS'; payload: ChatUser[] }
  | { type: 'SET_ROOM_MESSAGES'; payload: { roomId: string; messages: ChatMessage[] } }
  | { type: 'ADD_ROOM_MESSAGE'; payload: { roomId: string; message: ChatMessage } }
  | { type: 'SET_PRIVATE_MESSAGE'; payload: { userId: number; message: ChatMessage } }
  | { type: 'SET_PRIVATE_CONVERSATION'; payload: { userId: number; messages: ChatMessage[] } }
  | { type: 'PREPEND_PRIVATE_MESSAGES'; payload: { userId: number; messages: ChatMessage[] } }
  | { type: 'SET_CONNECTION_STATUS'; payload: boolean }
  | { type: 'SET_TYPING_USERS'; payload: Set<string> }
  | { type: 'SET_CONNECTION_ERROR'; payload: string | null }
  | { type: 'SET_NEW_MESSAGE_SENDER'; payload: ChatUser | null }
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'ADD_NOTIFICATION'; payload: Notification }
  | { type: 'SET_CURRENT_ROOM'; payload: string }
  | { type: 'SET_SHOW_KICK_COUNTDOWN'; payload: boolean }
  | { type: 'IGNORE_USER'; payload: number }
  | { type: 'UNIGNORE_USER'; payload: number }
  | { type: 'CLEAR_ALL'; payload: void }
  | { type: 'UPSERT_ONLINE_USER'; payload: ChatUser }
  | { type: 'REMOVE_ONLINE_USER'; payload: number };

type ReactionCounts = { like: number; dislike: number; heart: number };

// üî• SIMPLIFIED Initial state
const initialState: ChatState = {
  currentUser: null,
  onlineUsers: [],
  currentRoomId: '',
  roomMessages: {},
  privateConversations: {},
  ignoredUsers: new Set(),
  isConnected: false,
  typingUsers: new Set(),
  connectionError: null,
  newMessageSender: null,
  isLoading: false,
  notifications: [],
  showKickCountdown: false,
};

// üî• SIMPLIFIED Reducer function - ÿ≠ÿ∞ŸÅ ÿßŸÑÿ™ÿπŸÇŸäÿØÿßÿ™ ŸàÿßŸÑÿ™ÿ∂ÿßÿ±ÿ®
function chatReducer(state: ChatState, action: ChatAction): ChatState {
  switch (action.type) {
    case 'SET_CURRENT_USER':
      return { ...state, currentUser: action.payload };

    case 'SET_ONLINE_USERS': {
      // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÉÿßÿ¥ ŸÖÿπ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿßŸÑÿ¨ÿØŸäÿØÿ©
      action.payload.forEach(user => {
        if (user && user.id && user.username) {
          setCachedUser(user);
        }
      });
      // ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ ŸÅŸä ÿßŸÑŸÉÿßÿ¥
      userCache.updateOnlineStatus(action.payload.map(u => u.id));
      return { ...state, onlineUsers: action.payload };
    }

    case 'SET_ROOM_MESSAGES': {
      const { roomId, messages } = action.payload;
      return {
        ...state,
        roomMessages: { ...state.roomMessages, [roomId]: messages },
      };
    }

    case 'ADD_ROOM_MESSAGE': {
      const { roomId, message } = action.payload;
      const existingMessages = state.roomMessages[roomId] || [];

      // ‚úÖ ŸÅÿ≠ÿµ ÿ®ÿ≥Ÿäÿ∑ ŸÑŸÑÿ™ŸÉÿ±ÿßÿ± ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ID ÿ£Ÿà timestamp+content
      const isDuplicate = existingMessages.some(
        (msg) =>
          msg.id === message.id ||
          (msg.timestamp === message.timestamp &&
            msg.senderId === message.senderId &&
            msg.content === message.content)
      );

      if (isDuplicate) {
        return state; // ŸÑÿß ŸÜÿ∂ŸäŸÅ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖŸÉÿ±ÿ±ÿ©
      }

      return {
        ...state,
        roomMessages: {
          ...state.roomMessages,
          [roomId]: [...existingMessages, message],
        },
      };
    }

    // ŸÖŸÑÿßÿ≠ÿ∏ÿ©: ÿ™ÿ≠ÿØŸäÿ´ÿßÿ™ ÿßŸÑÿ™ŸÅÿßÿπŸÑÿßÿ™ ÿ™Ÿèÿ∑ÿ®ŸëŸÇ ÿØÿßÿÆŸÑ ŸÖÿ≥ÿ™ŸÖÿπ ÿßŸÑÿ≥ŸàŸÉÿ™ ŸÖÿ®ÿßÿ¥ÿ±ÿ© ÿπÿ®ÿ± dispatch SET_ROOM_MESSAGES

    case 'SET_PRIVATE_MESSAGE': {
      const { userId, message } = action.payload;
      const existingMessages = state.privateConversations[userId] || [];

      // ŸÖŸÜÿπ ÿßŸÑÿ™ŸÉÿ±ÿßÿ± - ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿ®ŸÜŸÅÿ≥ ID ÿ£Ÿà ŸÜŸÅÿ≥ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ŸàÿßŸÑŸàŸÇÿ™
      const isDuplicate = existingMessages.some(
        (msg) =>
          (message.id && msg.id === message.id) ||
          (msg.content === message.content &&
            msg.senderId === message.senderId &&
            Math.abs(new Date(msg.timestamp).getTime() - new Date(message.timestamp).getTime()) <
              1000)
      );

      if (isDuplicate) {
        return state; // ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖŸÉÿ±ÿ±ÿ©
      }

      return {
        ...state,
        privateConversations: {
          ...state.privateConversations,
          [userId]: [...existingMessages, message],
        },
      };
    }

    case 'SET_PRIVATE_CONVERSATION': {
      const { userId, messages } = action.payload;
      // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ™ŸÉÿ±ÿßÿ±ÿßÿ™ ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ID ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©
      const uniqueMessages = messages.reduce((acc: ChatMessage[], msg) => {
        const exists = acc.some(
          (m) =>
            (msg.id && m.id === msg.id) ||
            (m.content === msg.content &&
              m.senderId === msg.senderId &&
              Math.abs(new Date(m.timestamp).getTime() - new Date(msg.timestamp).getTime()) < 1000)
        );
        if (!exists) {
          acc.push(msg);
        }
        return acc;
      }, []);

      return {
        ...state,
        privateConversations: {
          ...state.privateConversations,
          [userId]: uniqueMessages,
        },
      };
    }

    case 'PREPEND_PRIVATE_MESSAGES': {
      const { userId, messages } = action.payload;
      const existing = state.privateConversations[userId] || [];
      const existingIds = new Set(existing.map((m) => m.id));
      const toPrepend = messages.filter((m) => !existingIds.has(m.id));
      return {
        ...state,
        privateConversations: {
          ...state.privateConversations,
          [userId]: [...toPrepend, ...existing],
        },
      };
    }

    case 'UPSERT_ONLINE_USER': {
      const incoming = action.payload;
      if (!incoming || !incoming.id) {
        return state;
      }
      
      // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÉÿßÿ¥ ŸÖÿπ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ¨ÿØŸäÿØÿ©
      if (incoming.username) {
        setCachedUser(incoming);
      }
      const existingIndex = state.onlineUsers.findIndex((u) => u.id === incoming.id);
      if (existingIndex === -1) {
        // ŸÑÿß ÿ™ÿ∂ŸÅ ŸÖÿ≥ÿ™ÿÆÿØŸÖŸãÿß ÿ¨ÿØŸäÿØŸãÿß ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÖŸÜŸÇŸàÿµÿ© (ÿ™ÿ≠ÿØŸäÿ´ ÿ¨ÿ≤ÿ¶Ÿä ŸÖÿ´ŸÑ ÿßŸÑŸÑŸàŸÜ/ÿßŸÑÿ™ÿ£ÿ´Ÿäÿ±)
        const hasMinimum = !!(incoming.username && incoming.userType);
        if (!hasMinimum) {
          return state;
        }
        return { ...state, onlineUsers: [...state.onlineUsers, incoming] };
      }
      const merged = { ...state.onlineUsers[existingIndex], ...incoming } as ChatUser;
      const next = state.onlineUsers.slice();
      next[existingIndex] = merged;
      return { ...state, onlineUsers: next };
    }

    case 'REMOVE_ONLINE_USER': {
      const userId = action.payload;
      return { ...state, onlineUsers: state.onlineUsers.filter((u) => u.id !== userId) };
    }

    case 'SET_CONNECTION_STATUS':
      return { ...state, isConnected: action.payload };

    case 'SET_TYPING_USERS':
      return { ...state, typingUsers: action.payload };

    case 'SET_CONNECTION_ERROR':
      return { ...state, connectionError: action.payload };

    case 'SET_NEW_MESSAGE_SENDER':
      return { ...state, newMessageSender: action.payload };

    case 'SET_LOADING':
      return { ...state, isLoading: action.payload };

    case 'ADD_NOTIFICATION':
      return {
        ...state,
        notifications: [...state.notifications, action.payload],
      };

    case 'SET_CURRENT_ROOM':
      return { ...state, currentRoomId: action.payload };

    case 'SET_SHOW_KICK_COUNTDOWN':
      return { ...state, showKickCountdown: action.payload };

    case 'IGNORE_USER':
      return {
        ...state,
        ignoredUsers: new Set([...state.ignoredUsers, action.payload]),
      };

    case 'UNIGNORE_USER': {
      const newIgnoredUsers = new Set(state.ignoredUsers);
      newIgnoredUsers.delete(action.payload);
      return { ...state, ignoredUsers: newIgnoredUsers };
    }

    case 'CLEAR_ALL':
      return { ...initialState };

    default:
      return state;
  }
}

export const useChat = () => {
  const [state, dispatch] = useReducer(chatReducer, initialState);
  const socket = useRef<Socket | null>(null);

  // üî• SIMPLIFIED loading management - ŸÖÿµÿØÿ± Ÿàÿßÿ≠ÿØ
  const loadingRooms = useRef<Set<string>>(new Set());

  // Broadcast handlers registry
  const broadcastHandlers = useRef<Set<(data: any) => void>>(new Set());

  // WebRTC signaling handlers registries
  const webrtcOfferHandlers = useRef<Set<(data: any) => void>>(new Set());
  const webrtcAnswerHandlers = useRef<Set<(data: any) => void>>(new Set());
  const webrtcIceHandlers = useRef<Set<(data: any) => void>>(new Set());

  // Notification states
  const [levelUpNotification, setLevelUpNotification] = useState<any>(null);
  const [achievementNotification, setAchievementNotification] = useState<any>(null);
  const [dailyBonusNotification, setDailyBonusNotification] = useState<any>(null);

  // Refs to avoid stale closures in socket listeners
  const currentUserRef = useRef<ChatUser | null>(null);
  const currentRoomIdRef = useRef<string>(initialState.currentRoomId);
  const ignoredUsersRef = useRef<Set<number>>(new Set());
  const roomMessagesRef = useRef<Record<string, ChatMessage[]>>({});
  const typingTimersRef = useRef<Map<number, number>>(new Map());

  useEffect(() => {
    currentUserRef.current = state.currentUser;
  }, [state.currentUser]);
  useEffect(() => {
    currentRoomIdRef.current = state.currentRoomId;
  }, [state.currentRoomId]);
  useEffect(() => {
    ignoredUsersRef.current = state.ignoredUsers;
  }, [state.ignoredUsers]);
  useEffect(() => {
    roomMessagesRef.current = state.roomMessages;
  }, [state.roomMessages]);

  // ‚úÖ Memoized current room messages - ÿ≠ŸÑ ŸÖÿ¥ŸÉŸÑÿ© ÿßŸÑŸÄ performance
  const currentRoomMessages = useMemo(() => {
    return state.roomMessages[state.currentRoomId] || [];
  }, [state.roomMessages, state.currentRoomId]);

  // ‚úÖ Memoized online users
  const memoizedOnlineUsers = useMemo(() => {
    const filtered = state.onlineUsers.filter(
      (user) =>
        user && user.id && user.username && user.userType && !state.ignoredUsers.has(user.id)
    );
    // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ™ŸÉÿ±ÿßÿ±ÿßÿ™
    const dedup = new Map<number, ChatUser>();
    for (const u of filtered) {
      if (!dedup.has(u.id)) dedup.set(u.id, u);
    }
    return Array.from(dedup.values());
  }, [state.onlineUsers, state.ignoredUsers]);

  // üî• SIMPLIFIED Message loading - ÿ≠ÿ∞ŸÅ ÿßŸÑÿ™ÿπŸÇŸäÿØÿßÿ™
  const loadRoomMessages = useCallback(
    async (roomId: string, forceReload: boolean = false) => {
      // ŸÜÿπÿ™ŸÖÿØ ÿßŸÑÿ¢ŸÜ ÿπŸÑŸâ Socket ŸÑÿ•ÿ±ÿ≥ÿßŸÑ ÿ¢ÿÆÿ± ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿπŸÜÿØ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖÿå
      // ŸÑŸÉŸÜ ŸÜŸèÿ®ŸÇŸä Ÿáÿ∞ÿß ŸÉŸÜÿ≥ÿÆÿ© ÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿäÿ© ÿ≥ÿ±Ÿäÿπÿ© ÿ™ÿ∑ŸÑÿ® 10 ÿ±ÿ≥ÿßÿ¶ŸÑ ŸÅŸÇÿ∑.

      if (!forceReload && state.roomMessages[roomId]?.length > 0) {
        return;
      }

      if (loadingRooms.current.has(roomId)) {
        return;
      }

      loadingRooms.current.add(roomId);

      try {
        const data = await apiRequest(`/api/messages/room/${roomId}/latest?limit=10`);

        if (data?.messages && Array.isArray(data.messages)) {
          const formattedMessages = mapDbMessagesToChatMessages(data.messages, roomId);
          dispatch({
            type: 'SET_ROOM_MESSAGES',
            payload: { roomId, messages: formattedMessages },
          });
        }
      } catch (error) {
        console.error(`‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ∫ÿ±ŸÅÿ© ${roomId}:`, error);
      } finally {
        loadingRooms.current.delete(roomId);
      }
    },
    [state.roomMessages]
  );

  // Track ping interval to avoid leaks
  const pingIntervalRef = useRef<number | null>(null);

  // üî• SIMPLIFIED Socket event handling - ÿ≠ÿ∞ŸÅ ÿßŸÑÿ™ÿ∂ÿßÿ±ÿ®
  const setupSocketListeners = useCallback((socketInstance: Socket) => {
    // ÿ≠ÿßŸÅÿ∏ ÿπŸÑŸâ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿπÿ®ÿ± ping/pong ŸÖÿÆÿµÿµ ÿπŸÜÿØ ÿßŸÑÿ≥ŸÉŸàŸÜ
    if (pingIntervalRef.current) {
      clearInterval(pingIntervalRef.current);
    }
    const pingId = window.setInterval(() => {
      if (socketInstance.connected) {
        socketInstance.emit('client_ping');
      }
    }, 20000);
    pingIntervalRef.current = pingId;
    socketInstance.on('client_pong', () => {});

    // ŸÑŸÖ ŸÜÿπÿØ ŸÜÿ≥ÿ™ÿÆÿØŸÖ polling ŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ™ÿµŸÑŸäŸÜÿõ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± Ÿäÿ®ÿ´ ÿßŸÑÿ™ÿ≠ÿØŸäÿ´ÿßÿ™ ŸÖÿ®ÿßÿ¥ÿ±ÿ©

    // ‚úÖ ŸÖÿπÿßŸÑÿ¨ Ÿàÿßÿ≠ÿØ ŸÑŸÑÿ±ÿ≥ÿßÿ¶ŸÑ - ÿ≠ÿ∞ŸÅ ÿßŸÑÿ™ÿ∂ÿßÿ±ÿ®
    socketInstance.on('message', (data: any) => {
      try {
        const envelope = data.envelope || data;

        // ÿ™ÿ≠ÿØŸäÿ´ ÿ™ÿ£ÿ´Ÿäÿ± ÿßŸÑÿ®ÿ±ŸàŸÅÿßŸäŸÑ ŸÅŸÇÿ∑ ÿπŸÜÿØ ŸàÿµŸàŸÑ ÿ®ÿ´ profileEffectChanged
        if (envelope.type === 'profileEffectChanged') {
          const { userId, profileEffect, user } = envelope as any;
          const targetId = userId || user?.id;
          if (targetId) {
            if (currentUserRef.current?.id === targetId) {
              dispatch({
                type: 'SET_CURRENT_USER',
                payload: {
                  ...currentUserRef.current!,
                  profileEffect:
                    profileEffect ?? user?.profileEffect ?? currentUserRef.current?.profileEffect,
                } as any,
              });
            }
            dispatch({
              type: 'UPSERT_ONLINE_USER',
              payload: { id: targetId, profileEffect: profileEffect ?? user?.profileEffect } as any,
            });
          }
        }

        // ÿ®ÿ´ ÿÆÿßÿµ ŸÑÿ™ÿ≠ÿØŸäÿ´ ŸÑŸàŸÜ ÿßŸÑÿßÿ≥ŸÖ ŸÅŸÇÿ∑
        if (envelope.type === 'usernameColorChanged') {
          const { userId, color, user } = envelope as any;
          const targetId = userId || user?.id;
          if (targetId && color) {
            if (currentUserRef.current?.id === targetId) {
              dispatch({
                type: 'SET_CURRENT_USER',
                payload: { ...currentUserRef.current!, usernameColor: color } as any,
              });
            }
            dispatch({
              type: 'UPSERT_ONLINE_USER',
              payload: { id: targetId, usernameColor: color } as any,
            });
          }
        }

        // ÿ™ÿ≠ÿØŸäÿ´ ŸÑŸàŸÜ ÿµŸÜÿØŸàŸÇ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ (profileBackgroundColor)
        if (envelope.type === 'user_background_updated') {
          const { data } = envelope as any;
          const targetId = data?.userId;
          const color = data?.profileBackgroundColor;
          if (targetId && color) {
            if (currentUserRef.current?.id === targetId) {
              dispatch({
                type: 'SET_CURRENT_USER',
                payload: { ...currentUserRef.current!, profileBackgroundColor: color } as any,
              });
            }
            dispatch({
              type: 'UPSERT_ONLINE_USER',
              payload: { id: targetId, profileBackgroundColor: color } as any,
            });
          }
        }

        // ÿ™ÿ≠ÿØŸäÿ´ ÿµŸàÿ±ÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
        if (envelope.type === 'userAvatarUpdated') {
          const { userId, avatarHash, avatarVersion, users } = envelope as any;

          if (userId) {
            // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÅŸä ÿßŸÑŸÇÿßÿ¶ŸÖÿ©
            dispatch({
              type: 'UPSERT_ONLINE_USER',
              payload: { id: userId, avatarHash, avatarVersion } as any,
            });

            // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ≠ÿßŸÑŸä
            if (currentUserRef.current?.id === userId) {
              dispatch({
                type: 'SET_CURRENT_USER',
                payload: {
                  ...currentUserRef.current!,
                  avatarHash: avatarHash || (currentUserRef.current as any).avatarHash,
                  avatarVersion: avatarVersion || (currentUserRef.current as any).avatarVersion,
                } as any,
              });
            }
          }

          // ÿ™ÿ≠ÿØŸäÿ´ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿ•ÿ∞ÿß ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑŸáÿß
          if (users && Array.isArray(users)) {
            dispatch({ type: 'SET_ONLINE_USERS', payload: users });
          }
        }

        // ÿ™ÿ≠ÿØŸäÿ´ ÿµŸàÿ±ÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ≠ÿßŸÑŸä ÿπÿ®ÿ± ÿ¨ŸÖŸäÿπ ÿßŸÑÿ£ÿ¨Ÿáÿ≤ÿ©
        if (envelope.type === 'selfAvatarUpdated') {
          const { avatarHash, avatarVersion } = envelope as any;

          if (currentUserRef.current) {
            dispatch({
              type: 'SET_CURRENT_USER',
              payload: {
                ...currentUserRef.current!,
                avatarHash: avatarHash || (currentUserRef.current as any).avatarHash,
                avatarVersion: avatarVersion || (currentUserRef.current as any).avatarVersion,
              } as any,
            });
          }
        }

        // ÿ™ÿ≠ÿØŸäÿ´ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÖŸàÿ≠ÿØÿ©
        if (envelope.type === 'userUpdated') {
          const updatedUser: ChatUser | undefined = (envelope as any).user;
          if (updatedUser && updatedUser.id) {
            const isCurrent = currentUserRef.current?.id === updatedUser.id;
            // ÿØŸÖÿ¨ ŸÅŸàÿ±Ÿä ŸÑŸÑÿ≠ŸÇŸàŸÑ ÿßŸÑŸÖÿ™ÿßÿ≠ÿ©
            if (isCurrent && currentUserRef.current) {
              dispatch({
                type: 'SET_CURRENT_USER',
                payload: { ...currentUserRef.current, ...updatedUser } as any,
              });
            }
            dispatch({ type: 'UPSERT_ONLINE_USER', payload: updatedUser });

            // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑÿ®ÿ´ ÿÆŸÅŸäŸÅÿßŸã (ÿ®ÿØŸàŸÜ profileImage/base64) ŸàÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ≠ÿßŸÑŸä Ÿäÿ≠ÿ™ÿßÿ¨ ÿßŸÑÿµŸàÿ±ÿ©ÿå ÿßÿ¨ŸÑÿ® ŸÜÿ≥ÿÆÿ© ŸÉÿßŸÖŸÑÿ© ŸÖÿ±ÿ© Ÿàÿßÿ≠ÿØÿ©
            if (
              isCurrent &&
              (!updatedUser.profileImage ||
                (typeof updatedUser.profileImage === 'string' &&
                  !updatedUser.profileImage.startsWith('data:')))
            ) {
              try {
                apiRequest(`/api/users/${updatedUser.id}?t=${Date.now()}`)
                  .then((full: any) => {
                    if (full && full.id) {
                      // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÉÿßÿ¥ ŸÖÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÉÿßŸÖŸÑÿ©
                      setCachedUser(full as ChatUser);
                      if (currentUserRef.current?.id === updatedUser.id) {
                        dispatch({
                          type: 'SET_CURRENT_USER',
                          payload: { ...currentUserRef.current!, ...full } as any,
                        });
                      }
                    }
                  })
                  .catch(() => {});
              } catch {}
            }
          }
        }

        switch (envelope.type) {
          case 'typing': {
            const uid = (envelope as any).userId;
            const isTyping = !!(envelope as any).isTyping;
            const username = (envelope as any).username || (uid ? `User#${uid}` : '');
            if (!uid || uid === currentUserRef.current?.id) break;
            const next = new Set(state.typingUsers);
            if (isTyping) {
              next.add(username);
              // clear previous timer
              const t = typingTimersRef.current.get(uid);
              if (t) {
                clearTimeout(t);
                typingTimersRef.current.delete(uid);
              }
              const timeoutId = window.setTimeout(() => {
                const after = new Set(
                  currentRoomIdRef.current ? Array.from(next) : Array.from(state.typingUsers)
                );
                after.delete(username);
                dispatch({ type: 'SET_TYPING_USERS', payload: after });
                const tmp = typingTimersRef.current.get(uid);
                if (tmp) {
                  clearTimeout(tmp);
                  typingTimersRef.current.delete(uid);
                }
              }, 3000);
              typingTimersRef.current.set(uid, timeoutId);
            } else {
              next.delete(username);
              const t = typingTimersRef.current.get(uid);
              if (t) {
                clearTimeout(t);
                typingTimersRef.current.delete(uid);
              }
            }
            dispatch({ type: 'SET_TYPING_USERS', payload: next });
            break;
          }
          case 'newMessage': {
            const { message } = envelope;
            if (message?.sender && message.content) {
              const roomId = message.roomId || 'general';

              // ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÑÿ™ŸÜÿ≥ŸäŸÇ ChatMessage
              const chatMessage: ChatMessage = {
                id: message.id,
                content: message.content,
                senderId: message.sender.id,
                timestamp: message.timestamp || new Date().toISOString(),
                messageType: message.messageType || 'text',
                sender: message.sender,
                roomId,
                isPrivate: Boolean(message.isPrivate),
                reactions: message.reactions || { like: 0, dislike: 0, heart: 0 },
                myReaction: message.myReaction ?? null,
                attachments: message.attachments || [],
              };

              // ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÑŸÑÿ∫ÿ±ŸÅÿ© ÿßŸÑŸÖŸÜÿßÿ≥ÿ®ÿ© (ÿπÿßŸÖ ŸÅŸÇÿ∑)
              if (!chatMessage.isPrivate) {
                dispatch({
                  type: 'ADD_ROOM_MESSAGE',
                  payload: { roomId, message: chatMessage },
                });
              }

              // ÿ™ÿ¥ÿ∫ŸäŸÑ ÿµŸàÿ™ ÿÆŸÅŸäŸÅ ŸÅŸÇÿ∑ ÿπŸÜÿØ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿπÿßŸÖÿ© ŸÅŸä ÿßŸÑÿ∫ÿ±ŸÅÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©
              if (
                !chatMessage.isPrivate &&
                chatMessage.senderId !== currentUserRef.current?.id &&
                roomId === currentRoomIdRef.current
              ) {
                playNotificationSound();
              }
            }
            break;
          }
          case 'reactionUpdated': {
            const { roomId, messageId, counts, myReaction, reactorId } = envelope as any;
            const targetRoom = roomId || currentRoomIdRef.current;
            if (!targetRoom || !messageId) break;
            const existing = roomMessagesRef.current[targetRoom] || [];
            const next = existing.map((m) =>
              m.id === messageId
                ? {
                    ...m,
                    reactions: {
                      like: counts?.like ?? m.reactions?.like ?? 0,
                      dislike: counts?.dislike ?? m.reactions?.dislike ?? 0,
                      heart: counts?.heart ?? m.reactions?.heart ?? 0,
                    },
                    myReaction:
                      reactorId && reactorId === currentUserRef.current?.id
                        ? (myReaction ?? null)
                        : (m.myReaction ?? null),
                  }
                : m
            );
            dispatch({
              type: 'SET_ROOM_MESSAGES',
              payload: { roomId: targetRoom, messages: next },
            });
            break;
          }
          case 'messageDeleted': {
            const { messageId, roomId } = envelope as any;
            if (messageId && roomId) {
              const existing = roomMessagesRef.current[roomId] || [];
              const next = existing.filter((m) => m.id !== messageId);
              dispatch({ type: 'SET_ROOM_MESSAGES', payload: { roomId, messages: next } });
            }
            break;
          }

          case 'roomMessages': {
            const { messages, roomId: payloadRoomId } = envelope as any;
            if (Array.isArray(messages)) {
              const roomId = payloadRoomId || currentRoomIdRef.current;
              const formattedMessages = mapDbMessagesToChatMessages(messages, roomId);
              dispatch({
                type: 'SET_ROOM_MESSAGES',
                payload: { roomId, messages: formattedMessages },
              });
            }
            break;
          }

          case 'onlineUsers': {
            const roomId = (envelope as any).roomId || 'general';
            if (roomId !== currentRoomIdRef.current) {
              break;
            }
            if (Array.isArray(envelope.users)) {
              const rawUsers = envelope.users as ChatUser[];
              // ŸÅŸÑÿ™ÿ±ÿ© ÿµÿßÿ±ŸÖÿ© + ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑŸÖÿ™ÿ¨ÿßŸáŸÑŸäŸÜ + ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ™ŸÉÿ±ÿßÿ±ÿßÿ™
              const filtered = rawUsers.filter(
                (u) => u && u.id && u.username && u.userType && !ignoredUsersRef.current.has(u.id)
              );
              const dedup = new Map<number, ChatUser>();
              for (const u of filtered) {
                if (!dedup.has(u.id)) dedup.set(u.id, u);
              }
              const nextUsers = Array.from(dedup.values());
              dispatch({ type: 'SET_ONLINE_USERS', payload: nextUsers });
            }
            break;
          }

          case 'roomJoined': {
            const roomId = (envelope as any).roomId;
            if (roomId && roomId !== currentRoomIdRef.current) {
              // Switch local state to the confirmed room and persist session
              dispatch({ type: 'SET_CURRENT_ROOM', payload: roomId });
              try { saveSession({ roomId }); } catch {}
            }
            // ÿßÿ≥ÿ™ÿ®ÿØÿßŸÑ ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿ®ÿßŸÑŸÉÿßŸÖŸÑ ÿ®ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ∫ÿ±ŸÅÿ© ÿßŸÑŸÖÿ±ÿ≥ŸÑÿ© (ŸÖÿπ ŸÅŸÑÿ™ÿ±ÿ© Ÿàÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ™ŸÉÿ±ÿßÿ±ÿßÿ™)
            const users = (envelope as any).users;
            if (Array.isArray(users)) {
              const rawUsers = users as ChatUser[];
              const filtered = rawUsers.filter(
                (u) => u && u.id && u.username && u.userType && !ignoredUsersRef.current.has(u.id)
              );
              const dedup = new Map<number, ChatUser>();
              for (const u of filtered) {
                if (!dedup.has(u.id)) dedup.set(u.id, u);
              }
              dispatch({ type: 'SET_ONLINE_USERS', payload: Array.from(dedup.values()) });
            }
            break;
          }

          case 'userJoinedRoom': {
            const joinedId = (envelope as any).userId;
            const username = (envelope as any).username || (joinedId ? `User#${joinedId}` : 'User');
            if (joinedId) {
              const placeholder = {
                id: joinedId,
                username,
                role: 'member',
                userType: 'member',
                isOnline: true,
              } as ChatUser;
              dispatch({ type: 'UPSERT_ONLINE_USER', payload: placeholder });
              try {
                apiRequest(`/api/users/${joinedId}?t=${Date.now()}`)
                  .then((data: any) => {
                    if (data && data.id) {
                      // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÉÿßÿ¥ ŸÖÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÉÿßŸÖŸÑÿ©
                      setCachedUser(data as ChatUser);
                      dispatch({
                        type: 'UPSERT_ONLINE_USER',
                        payload: { ...(data as any), isOnline: true } as ChatUser,
                      });
                    }
                  })
                  .catch(() => {});
              } catch {
                // ignore
              }
            }
            break;
          }
          case 'userLeftRoom': {
            const leftId = (envelope as any).userId;
            if (leftId) {
              dispatch({ type: 'REMOVE_ONLINE_USER', payload: leftId });
            }
            break;
          }
          case 'userDisconnected': {
            const uid = (envelope as any).userId;
            if (uid) {
              dispatch({ type: 'REMOVE_ONLINE_USER', payload: uid });
            }
            break;
          }
          case 'userConnected': {
            const u = (envelope as any).user;
            if (u && u.id) {
              dispatch({ type: 'UPSERT_ONLINE_USER', payload: u });
            }
            break;
          }

          case 'kicked': {
            // ÿ•ÿ∏Ÿáÿßÿ± ÿπÿØŸëÿßÿØ ÿßŸÑÿ∑ÿ±ÿØ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÖÿ≥ÿ™ŸáÿØŸÅ ŸÅŸÇÿ∑
            const targetId = envelope.targetUserId;
            if (targetId && targetId === currentUserRef.current?.id) {
              dispatch({ type: 'SET_SHOW_KICK_COUNTDOWN', payload: true });
              // ÿ•ÿ∂ÿßŸÅÿ© ÿ±ÿ≥ÿßŸÑÿ© Ÿàÿßÿ∂ÿ≠ÿ© ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
              const duration = (envelope as any).duration || 15;
              const reason = (envelope as any).reason || 'ÿ®ÿØŸàŸÜ ÿ≥ÿ®ÿ®';
              const moderator = (envelope as any).moderator || 'ŸÖÿ¥ÿ±ŸÅ';
              alert(
                `ÿ™ŸÖ ÿ∑ÿ±ÿØŸÉ ŸÖŸÜ ÿßŸÑÿØÿ±ÿØÿ¥ÿ© ÿ®Ÿàÿßÿ≥ÿ∑ÿ© ${moderator}\nÿßŸÑÿ≥ÿ®ÿ®: ${reason}\nÿßŸÑŸÖÿØÿ©: ${duration} ÿØŸÇŸäŸÇÿ©`
              );
            }
            break;
          }

          case 'blocked': {
            // ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ≠ÿ¨ÿ® ÿßŸÑŸÜŸáÿßÿ¶Ÿä
            if (currentUserRef.current?.id) {
              const reason = (envelope as any).reason || 'ÿ®ÿØŸàŸÜ ÿ≥ÿ®ÿ®';
              const moderator = (envelope as any).moderator || 'ŸÖÿ¥ÿ±ŸÅ';
              alert(`ÿ™ŸÖ ÿ≠ÿ¨ÿ®ŸÉ ŸÜŸáÿßÿ¶ŸäÿßŸã ŸÖŸÜ ÿßŸÑÿØÿ±ÿØÿ¥ÿ© ÿ®Ÿàÿßÿ≥ÿ∑ÿ© ${moderator}\nÿßŸÑÿ≥ÿ®ÿ®: ${reason}`);
              // ŸÅÿµŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ Ÿàÿ•ÿπÿßÿØÿ© ÿ™Ÿàÿ¨ŸäŸáŸá
              setTimeout(() => {
                window.location.href = '/';
              }, 3000);
            }
            break;
          }

          case 'moderationAction': {
            // ŸÅŸä ÿ≠ÿßŸÑÿ© ŸàÿµŸàŸÑ ÿ®ÿ´ ÿπÿßŸÖ ÿ®ÿ•ÿ¨ÿ±ÿßÿ° "banned"ÿå ŸÅÿπŸëŸÑ ÿßŸÑÿπÿØŸëÿßÿØ ÿ•ÿ∞ÿß ŸÉŸÜÿ™ ÿ£ŸÜÿ™ ÿßŸÑŸáÿØŸÅ
            const action = (envelope as any).action;
            const targetId = (envelope as any).targetUserId;
            if (action === 'banned' && targetId && targetId === currentUserRef.current?.id) {
              dispatch({ type: 'SET_SHOW_KICK_COUNTDOWN', payload: true });
            }
            break;
          }

          case 'error':
          case 'warning': {
            console.warn('‚ö†Ô∏è ÿÆÿ∑ÿ£ ŸÖŸÜ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±:', envelope.message);
            
            // ÿπÿ±ÿ∂ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿÆÿ∑ÿ£ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿ™ÿ™ÿπŸÑŸÇ ÿ®ÿ∫ÿ±ŸÅÿ© ŸÖŸÇŸÅŸÑÿ©
            if (envelope.message && (envelope.message.includes('ŸÖŸÇŸÅŸÑÿ©') || envelope.message.includes('locked'))) {
              // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ≠ÿØÿ´ ŸÖÿÆÿµÿµ ŸÑÿπÿ±ÿ∂ ÿ±ÿ≥ÿßŸÑÿ© ÿÆÿ∑ÿ£
              try {
                window.dispatchEvent(new CustomEvent('roomLockError', { 
                  detail: { message: envelope.message }
                }));
              } catch {}
            }
            break;
          }

          // ‚úÖ ÿ®ÿ´Ÿàÿµ ÿßŸÑÿ£ÿµÿØŸÇÿßÿ°: ÿ™ÿ≠ŸàŸäŸÑŸáÿß ÿ•ŸÑŸâ ÿ£ÿ≠ÿØÿßÿ´ ŸÖÿ™ÿµŸÅÿ≠ ŸÑÿ™ŸÅÿπŸäŸÑ ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥ ÿπÿ®ÿ± useNotificationManager
          case 'friendRequestReceived': {
            const targetId = (envelope as any).targetUserId;
            if (targetId && targetId === currentUserRef.current?.id) {
              const detail = {
                senderName: (envelope as any).senderName,
                senderId: (envelope as any).senderId,
              } as any;
              try {
                window.dispatchEvent(new CustomEvent('friendRequestReceived', { detail }));
              } catch {}
            }
            break;
          }
          case 'friendRequestAccepted': {
            const targetId = (envelope as any).targetUserId;
            if (targetId && targetId === currentUserRef.current?.id) {
              const detail = { friendName: (envelope as any).senderName } as any;
              try {
                window.dispatchEvent(new CustomEvent('friendRequestAccepted', { detail }));
              } catch {}
            }
            break;
          }
          case 'friendAdded': {
            const targetId = (envelope as any).targetUserId;
            if (targetId && targetId === currentUserRef.current?.id) {
              const detail = {
                friendId: (envelope as any).friendId,
                friendName: (envelope as any).friendName,
              } as any;
              try {
                window.dispatchEvent(new CustomEvent('friendAdded', { detail }));
              } catch {}
            }
            break;
          }

          default: {
            break;
          }
        }
      } catch (error) {
        console.error('‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿ±ÿ≥ÿßŸÑÿ© Socket:', error);
      }
    });

    // ÿ£ÿ≠ÿØÿßÿ´ ŸÖÿ®ÿßÿ¥ÿ±ÿ© ŸÖÿ≠ÿ™ŸÖŸÑÿ© ŸÑÿ™ÿ≠ÿØŸäÿ´ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ™ÿµŸÑŸäŸÜ ŸÅŸàÿ±ÿßŸã ÿ•ŸÜ ŸàŸèÿ¨ÿØÿ™ ÿπŸÑŸâ ÿßŸÑÿÆÿßÿØŸÖ
    socketInstance.on('userDisconnected', (payload: any) => {
      const uid = payload?.userId || payload?.id;
      if (uid) {
        dispatch({ type: 'REMOVE_ONLINE_USER', payload: uid });
      }
    });
    socketInstance.on('userConnected', (payload: any) => {
      const user = payload?.user || payload;
      if (user?.id) {
        dispatch({ type: 'UPSERT_ONLINE_USER', payload: user });
      }
    });

    // ÿ®ÿ´ ÿ™ÿ≠ÿØŸäÿ´ÿßÿ™ ÿ∫ÿ±ŸÅÿ© ÿßŸÑÿ®ÿ´ Ÿàÿ£ÿ≠ÿØÿßÿ´ ÿßŸÑŸÖÿßŸäŸÉ ÿπÿ®ÿ± ŸÇŸÜŸàÿßÿ™ Socket ÿßŸÑŸÖÿÆÿµÿµÿ©
    const emitToBroadcastHandlers = (payload: any) => {
      broadcastHandlers.current.forEach((handler) => {
        try {
          handler(payload);
        } catch (err) {
          /* ignore single handler error */
        }
      });
    };

    socketInstance.on('roomUpdate', (message: any) => {
      emitToBroadcastHandlers(message);
    });

    // ÿ™ŸàÿßŸÅŸÇ ŸÖÿπ REST endpoints ÿßŸÑÿ™Ÿä ÿ™ÿ®ÿ´ ÿ£ÿ≠ÿØÿßÿ´ ÿßŸÑŸÖÿßŸäŸÉ ŸÉÿ£ÿ≠ÿØÿßÿ´ ŸÖÿ≥ÿ™ŸÇŸÑÿ©
    socketInstance.on('micRequested', (message: any) => {
      emitToBroadcastHandlers({ type: 'micRequest', ...message });
    });
    socketInstance.on('micApproved', (message: any) => {
      emitToBroadcastHandlers({ type: 'micApproved', ...message });
    });
    socketInstance.on('micRejected', (message: any) => {
      emitToBroadcastHandlers({ type: 'micRejected', ...message });
    });
    socketInstance.on('speakerRemoved', (message: any) => {
      emitToBroadcastHandlers({ type: 'speakerRemoved', ...message });
    });

    // WebRTC signaling relays
    socketInstance.on('webrtc-offer', (payload: any) => {
      webrtcOfferHandlers.current.forEach((h) => {
        try {
          h(payload);
        } catch (e) {
          console.warn('webrtc offer handler error', e);
        }
      });
    });
    socketInstance.on('webrtc-answer', (payload: any) => {
      webrtcAnswerHandlers.current.forEach((h) => {
        try {
          h(payload);
        } catch (e) {
          console.warn('webrtc answer handler error', e);
        }
      });
    });
    socketInstance.on('webrtc-ice-candidate', (payload: any) => {
      webrtcIceHandlers.current.forEach((h) => {
        try {
          h(payload);
        } catch (e) {
          console.warn('webrtc ice handler error', e);
        }
      });
    });

    // ŸÖÿπÿßŸÑÿ¨ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿÆÿßÿµÿ© ÿßŸÑŸÖÿ≠ÿ≥ŸÜ
    const handlePrivateMessage = (incoming: any) => {
      try {
        const envelope = incoming?.envelope ? incoming.envelope : incoming;
        const payload = envelope?.message ?? envelope;
        const message = payload?.message ?? payload;

        if (message?.sender && currentUserRef.current) {
          const chatMessage: ChatMessage = {
            id: message.id,
            content: message.content,
            senderId: message.sender.id,
            timestamp: message.timestamp || new Date().toISOString(),
            messageType: message.messageType || 'text',
            sender: message.sender,
            receiverId: message.receiverId,
            isPrivate: true,
            attachments: message.attachments || [],
          };

          // ÿ™ÿ¨ÿßŸáŸÑ ÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ≠ÿßŸÑÿßÿ™ ŸÅŸä ŸÖÿ≠ÿßÿØÿ´ÿßÿ™ ÿßŸÑÿ∑ÿ±ŸÅŸäŸÜ ÿ•ÿ∞ÿß ÿ£ÿ±ÿØŸÜÿß ŸÅÿµŸÑŸáÿß ŸÑÿßÿ≠ŸÇÿßŸã (ÿ≥ŸÜÿ®ŸÇŸäŸáÿß ÿßŸÑÿ¢ŸÜ ŸàŸÑŸÉŸÜ ŸÜÿ∂ÿπ ÿπŸÑÿßŸÖÿ©)
          const isStoryChannel = Array.isArray(chatMessage.attachments) && chatMessage.attachments.some((a: any) => a?.channel === 'story');

          // ÿ™ÿ≠ÿØŸäÿØ ŸÖÿπÿ±ŸÅ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ© ÿ®ÿ¥ŸÉŸÑ ŸÖÿ≠ÿ≥ŸÜ
          let conversationId: number;
          if (message.senderId === currentUserRef.current.id) {
            conversationId = message.receiverId;
          } else {
            conversationId = message.senderId;
          }

          // ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿµÿ≠ÿ© ŸÖÿπÿ±ŸÅ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
          if (
            conversationId &&
            !isNaN(conversationId) &&
            conversationId !== currentUserRef.current.id
          ) {
            dispatch({
              type: 'SET_PRIVATE_MESSAGE',
              payload: { userId: conversationId, message: chatMessage },
            });

            // ÿ™ÿ¥ÿ∫ŸäŸÑ ÿµŸàÿ™ ÿßŸÑÿ•ÿ¥ÿπÿßÿ± ŸÅŸÇÿ∑ ŸÑŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸàÿßÿ±ÿØÿ©
            if (chatMessage.senderId !== currentUserRef.current.id) {
              playNotificationSound();
              // ÿπÿ±ÿ∂ ÿ™ŸÜÿ®ŸäŸá ŸÖÿ±ÿ¶Ÿä ŸÑŸÑŸÖŸèÿ±ÿ≥ŸÑ
              try {
                dispatch({ type: 'SET_NEW_MESSAGE_SENDER', payload: message.sender as any });
              } catch {}
            }

            // ÿ•ÿ¥ÿπÿßÿ± ÿßŸÑŸàÿßÿ¨Ÿáÿ© ÿ®ŸàÿµŸàŸÑ/ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ÿÆÿßÿµÿ© ŸÑÿ™ÿ≠ÿØŸäÿ´ ÿ™ÿ®ŸàŸäÿ® ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ŸÅŸàÿ±ÿßŸã
            try {
              const detail = {
                otherUserId: conversationId,
                senderId: message.senderId,
                receiverId: message.receiverId,
                storyChannel: isStoryChannel,
              } as any;
              window.dispatchEvent(new CustomEvent('privateMessageReceived', { detail }));
            } catch {}
          }
        }
      } catch (error) {
        console.error('‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿÆÿßÿµÿ©:', error);
      }
    };

    socketInstance.on('privateMessage', handlePrivateMessage);

    // ŸÖÿπÿßŸÑÿ¨ ÿ≠ÿØÿ´ ÿßŸÑÿ∑ÿ±ÿØ
    socketInstance.on('kicked', (data: any) => {
      if (currentUserRef.current?.id === data.userId) {
        const kickerName = data.kickerName || 'ŸÖÿ¥ÿ±ŸÅ';
        const reason = data.reason || 'ÿ®ÿØŸàŸÜ ÿ≥ÿ®ÿ®';

        // ÿ•ÿ∏Ÿáÿßÿ± ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ∑ÿ±ÿØ
        alert(
          `ÿ™ŸÖ ÿ∑ÿ±ÿØŸÉ ŸÖŸÜ ÿßŸÑÿØÿ±ÿØÿ¥ÿ© ÿ®Ÿàÿßÿ≥ÿ∑ÿ© ${kickerName}\nÿßŸÑÿ≥ÿ®ÿ®: ${reason}\nŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿπŸàÿØÿ© ÿ®ÿπÿØ 15 ÿØŸÇŸäŸÇÿ©`
        );

        // ÿ•ÿ∏Ÿáÿßÿ± ÿπÿØÿßÿØ ÿßŸÑÿ∑ÿ±ÿØ
        dispatch({ type: 'SET_SHOW_KICK_COUNTDOWN', payload: true });

        // ŸÅÿµŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ®ÿπÿØ 3 ÿ´ŸàÿßŸÜŸä
        setTimeout(() => {
          clearSession(); // ŸÖÿ≥ÿ≠ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ¨ŸÑÿ≥ÿ©
          socketInstance.disconnect();
          window.location.href = '/';
        }, 3000);
      }
    });

    // ŸÖÿπÿßŸÑÿ¨ ÿ≠ÿØÿ´ ÿßŸÑÿ≠ÿ¨ÿ®
    socketInstance.on('blocked', (data: any) => {
      if (currentUserRef.current?.id) {
        const reason = data.reason || 'ÿ®ÿØŸàŸÜ ÿ≥ÿ®ÿ®';
        const moderator = data.moderator || 'ŸÖÿ¥ÿ±ŸÅ';

        // ÿ•ÿ∏Ÿáÿßÿ± ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ≠ÿ¨ÿ®
        alert(`ÿ™ŸÖ ÿ≠ÿ¨ÿ®ŸÉ ŸÜŸáÿßÿ¶ŸäÿßŸã ŸÖŸÜ ÿßŸÑÿØÿ±ÿØÿ¥ÿ© ÿ®Ÿàÿßÿ≥ÿ∑ÿ© ${moderator}\nÿßŸÑÿ≥ÿ®ÿ®: ${reason}`);

        // ŸÅÿµŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÅŸàÿ±ÿßŸã Ÿàÿ•ÿπÿßÿØÿ© ÿ™Ÿàÿ¨ŸäŸáŸá
        clearSession(); // ŸÖÿ≥ÿ≠ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ¨ŸÑÿ≥ÿ©
        socketInstance.disconnect();
        setTimeout(() => {
          window.location.href = '/';
        }, 1000);
      }
    });

    // ŸÖÿπÿßŸÑÿ¨ ÿ£ÿÆÿ∑ÿßÿ° ÿßŸÑŸÖÿµÿßÿØŸÇÿ©
    socketInstance.on('error', (data: any) => {
      if (data.action === 'blocked' || data.action === 'device_blocked') {
        alert(data.message);
        clearSession(); // ŸÖÿ≥ÿ≠ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ¨ŸÑÿ≥ÿ©
        socketInstance.disconnect();
        setTimeout(() => {
          window.location.href = '/';
        }, 1000);
      } else if (data.action === 'banned') {
        const timeLeft = data.timeLeft || 0;
        alert(`${data.message}\nÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÖÿ™ÿ®ŸÇŸä: ${timeLeft} ÿØŸÇŸäŸÇÿ©`);
        dispatch({ type: 'SET_SHOW_KICK_COUNTDOWN', payload: true });
      } else {
        console.error('ÿÆÿ∑ÿ£ ŸÖŸÜ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±:', data.message);
      }
    });
  }, []);

  // Ensure cleanup on unmount
  useEffect(() => {
    return () => {
      if (pingIntervalRef.current) {
        clearInterval(pingIntervalRef.current);
        pingIntervalRef.current = null;
      }
      if (onlineUsersIntervalRef.current) {
        clearInterval(onlineUsersIntervalRef.current);
        onlineUsersIntervalRef.current = null;
      }
      // clear typing timers
      typingTimersRef.current.forEach((id) => {
        try {
          clearTimeout(id);
        } catch {}
      });
      typingTimersRef.current.clear();
    };
  }, []);

  useEffect(() => {
    const handleOnline = () => {
      if (socket.current && !socket.current.connected) {
        try {
          socket.current.connect();
        } catch {}
      }
    };
    const handleOffline = () => {
      dispatch({ type: 'SET_CONNECTION_STATUS', payload: false });
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  useEffect(() => {
    // ÿπŸÜÿØ ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ≠ÿßŸÑŸäÿå ÿßÿ¨ŸÑÿ® ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ™ÿ¨ÿßŸáŸÑŸäŸÜ ÿßŸÑÿÆÿßÿµÿ© ÿ®Ÿá ŸÖÿ±ÿ© Ÿàÿßÿ≠ÿØÿ©
    const fetchIgnored = async () => {
      if (!state.currentUser?.id) return;
      try {
        const data = await apiRequest(`/api/users/${state.currentUser.id}/ignored`);
        const ids: number[] = Array.isArray(data)
          ? data
          : Array.isArray((data as any)?.ignoredUsers)
            ? (data as any).ignoredUsers
            : [];
        ids.forEach((id) => dispatch({ type: 'IGNORE_USER', payload: id }));
      } catch (e) {
        console.warn('ÿ™ÿπÿ∞ÿ± ÿ¨ŸÑÿ® ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ™ÿ¨ÿßŸáŸÑŸäŸÜ:', e);
      }
    };
    fetchIgnored();
  }, [state.currentUser?.id]);

  // Prefetch recent private conversations messages on first entry
  const prefetchedConversationsRef = useRef(false);
  useEffect(() => {
    const PREFETCH_CONVERSATIONS_MAX = 20; // ŸÇÿßÿ®ŸÑ ŸÑŸÑÿ™ÿπÿØŸäŸÑ
    const prefetch = async () => {
      if (!state.currentUser?.id || prefetchedConversationsRef.current) return;
      prefetchedConversationsRef.current = true;
      try {
        const conv = await apiRequest(
          `/api/private-messages/conversations/${state.currentUser.id}?limit=50`
        );
        const items: Array<{ otherUserId: number }> = Array.isArray((conv as any)?.conversations)
          ? (conv as any).conversations
          : [];
        const targets = items.map((i) => i.otherUserId).slice(0, PREFETCH_CONVERSATIONS_MAX);
        await Promise.all(
          targets.map(async (otherId) => {
            try {
              const data = await apiRequest(
                `/api/private-messages/${state.currentUser!.id}/${otherId}?limit=20`
              );
              const formatted = Array.isArray((data as any)?.messages)
                ? mapDbMessagesToChatMessages((data as any).messages)
                : [];
              if (formatted.length > 0) {
                dispatch({
                  type: 'SET_PRIVATE_CONVERSATION',
                  payload: { userId: otherId, messages: formatted },
                });
              }
            } catch {}
          })
        );
      } catch (e) {
        console.warn('ÿ™ÿπÿ∞ÿ± ÿßŸÑÿ¨ŸÑÿ® ÿßŸÑŸÖÿ≥ÿ®ŸÇ ŸÑŸÖÿ≠ÿßÿØÿ´ÿßÿ™ ÿßŸÑÿÆÿßÿµ:', e);
      }
    };
    prefetch();
  }, [state.currentUser?.id]);

  // üî• SIMPLIFIED Connect function
  const connect = useCallback(
    (user: ChatUser) => {
      dispatch({ type: 'SET_CURRENT_USER', payload: user });
      dispatch({ type: 'SET_LOADING', payload: true });

      try {
        // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿßŸÑÿ≥ÿßÿ®ŸÇ
        if (socket.current) {
          socket.current.removeAllListeners();
          socket.current.disconnect();
          socket.current = null;
          if (pingIntervalRef.current) {
            clearInterval(pingIntervalRef.current);
            pingIntervalRef.current = null;
          }
        }
        
        // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿπŸÖŸäŸÑ Socket ÿßŸÑŸÖŸàÿ≠ÿØ
        const s = connectSocket();
        socket.current = s;
        
        // ÿ≠ŸÅÿ∏ ÿßŸÑÿ¨ŸÑÿ≥ÿ©
        saveSession({ userId: user.id, username: user.username, userType: user.userType });

        // ÿ•ÿπÿØÿßÿØ ÿßŸÑŸÖÿ≥ÿ™ŸÖÿπŸäŸÜ
        setupSocketListeners(s);

        // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÖÿ™ÿµŸÑÿßŸã ÿ®ÿßŸÑŸÅÿπŸÑÿå ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑŸÖÿµÿßÿØŸÇÿ© ŸàÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÅŸàÿ±ÿßŸã
        if (s.connected) {
          s.emit('auth', {
            userId: user.id,
            username: user.username,
            userType: user.userType,
          });
          s.emit('joinRoom', {
            roomId: state.currentRoomId || 'general',
            userId: user.id,
            username: user.username,
          });
        }

        // ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÖÿµÿßÿØŸÇÿ© ÿπŸÜÿØ ÿßŸÑÿßÿ™ÿµÿßŸÑ/ÿ•ÿπÿßÿØÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ Ÿäÿ™ŸÖ ŸÖŸÜ ÿÆŸÑÿßŸÑ ÿßŸÑŸàÿ≠ÿØÿ© ÿßŸÑŸÖÿ¥ÿ™ÿ±ŸÉÿ©
        s.on('connect', () => {
          dispatch({ type: 'SET_CONNECTION_STATUS', payload: true });
          dispatch({ type: 'SET_CONNECTION_ERROR', payload: null });
          dispatch({ type: 'SET_LOADING', payload: false });

          // ÿ•ÿπÿßÿØÿ© ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÖÿµÿßÿØŸÇÿ© ŸàÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÑŸÑÿ∫ÿ±ŸÅÿ© ŸÑÿ∂ŸÖÿßŸÜ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿßŸÑÿµÿ≠Ÿäÿ≠
          try {
            s.emit('auth', {
              userId: user.id,
              username: user.username,
              userType: user.userType,
            });
            s.emit('joinRoom', {
              roomId: state.currentRoomId || 'general',
              userId: user.id,
              username: user.username,
            });
          } catch {}

          // Prefetch expected data shortly after connection success
          try {
            // ÿ∫ŸèÿµŸÜ ÿÆŸÅŸäŸÅ ŸÑÿ™ŸÅÿßÿØŸä ÿ•ÿ≤ÿπÿßÿ¨ ÿßŸÑÿ¥ÿ®ŸÉÿ© ŸÅŸàÿ±ÿßŸã
            setTimeout(() => {
              try {
                // Prefetch rooms list
                queryClient.prefetchQuery({
                  queryKey: ['/api/rooms', user.id],
                  queryFn: async () => apiRequest('/api/rooms'),
                  staleTime: 60_000,
                });
                // Prefetch notifications count
                queryClient.prefetchQuery({
                  queryKey: ['/api/notifications/unread-count', user.id],
                  queryFn: async () => apiRequest(`/api/notifications/unread-count?userId=${user.id}`),
                  staleTime: 60_000,
                });
                // Prefetch friends list (if endpoint supported)
                queryClient.prefetchQuery({
                  queryKey: ['/api/friends', user.id],
                  queryFn: async () => apiRequest(`/api/friends/${user.id}`),
                  staleTime: 60_000,
                });
              } catch {}
            }, 300);
          } catch {}
        });

        // ŸÖÿπÿßŸÑÿ¨ ŸÅÿ¥ŸÑ ÿ•ÿπÿßÿØÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿßŸÑŸÜŸáÿßÿ¶Ÿä
        s.on('reconnect_failed', () => {
          console.warn('‚ö†Ô∏è ŸÅÿ¥ŸÑ ŸÅŸä ÿ•ÿπÿßÿØÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿπÿØ ÿπÿØÿ© ŸÖÿ≠ÿßŸàŸÑÿßÿ™');
          dispatch({
            type: 'SET_CONNECTION_ERROR',
            payload: 'ŸÅŸÇÿØÿßŸÜ ÿßŸÑÿßÿ™ÿµÿßŸÑ. Ÿäÿ±ÿ¨Ÿâ ÿ•ÿπÿßÿØÿ© ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸÅÿ≠ÿ©.',
          });
        });

        // ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿπŸÜÿØ ÿßŸÑÿßŸÜŸÅÿµÿßŸÑ
        s.on('disconnect', () => {
          dispatch({ type: 'SET_CONNECTION_STATUS', payload: false });
        });

        // ŸÖÿπÿßŸÑÿ¨ÿ© ÿ£ÿÆÿ∑ÿßÿ° ÿßŸÑÿßÿ™ÿµÿßŸÑ
        s.on('connect_error', (error) => {
          console.error('‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ:', error);
          dispatch({ type: 'SET_CONNECTION_ERROR', payload: 'ŸÅÿ¥ŸÑ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±' });
        });
      } catch (error) {
        console.error('ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ:', error);
        dispatch({ type: 'SET_CONNECTION_ERROR', payload: 'ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿßŸÑÿÆÿßÿØŸÖ' });
        dispatch({ type: 'SET_LOADING', payload: false });
      }
    },
    [setupSocketListeners, state.currentRoomId]
  );

  // üî• SIMPLIFIED Join room function
  const joinRoom = useCallback(
    (roomId: string) => {
      if (!roomId || roomId === 'public' || roomId === 'friends') {
        roomId = 'general';
      }
      if (state.currentRoomId === roomId) {
        return;
      }

      // Do NOT change local room yet; wait for server ack (roomJoined)
      if (socket.current?.connected && state.currentUser?.id) {
        socket.current.emit('joinRoom', {
          roomId,
          userId: state.currentUser.id,
          username: state.currentUser.username,
        });
      }
    },
    [state.currentRoomId, state.currentUser]
  );

  // üî• SIMPLIFIED Send message function
  const sendMessage = useCallback(
    (content: string, messageType: string = 'text', receiverId?: number, roomId?: string) => {
      if (!state.currentUser || !socket.current?.connected) {
        console.error('‚ùå ŸÑÿß ŸäŸÖŸÉŸÜ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© - ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ∫Ÿäÿ± ŸÖÿ™ÿµŸÑ');
        return;
      }

      const trimmed = typeof content === 'string' ? content.trim() : '';
      if (!trimmed) {
        console.warn('‚ö†Ô∏è ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÅÿßÿ±ÿ∫');
        return;
      }

      // ÿßŸÉÿ™ÿ¥ÿßŸÅ ÿßŸÑÿµŸàÿ± ÿßŸÑŸÖÿ±ÿ≥ŸÑÿ© ŸÉŸÄ base64
      const detectedType =
        messageType === 'text' && trimmed.startsWith('data:image') ? 'image' : messageType;

      const messageData = {
        senderId: state.currentUser.id,
        content: trimmed,
        messageType: detectedType,
        isPrivate: !!receiverId,
        receiverId,
        roomId: roomId || state.currentRoomId,
      };

      if (receiverId) {
        // ÿ•ÿ±ÿ≥ÿßŸÑ ÿÆÿßÿµ ÿπÿ®ÿ± ŸÖÿ≥ÿßÿ± ŸÖŸÜŸÅÿµŸÑ ŸÉŸÑŸäÿßŸã
        const endpoint = `/api/private-messages/send`;
        apiRequest(endpoint, {
          method: 'POST',
          body: {
            senderId: messageData.senderId,
            receiverId,
            content: messageData.content,
            messageType: messageData.messageType || 'text',
          },
        }).catch(() => {});
      } else {
        socket.current.emit('publicMessage', messageData);
      }
    },
    [state.currentUser, state.currentRoomId]
  );

  // üî• SIMPLIFIED Send room message function
  const sendRoomMessage = useCallback(
    (content: string, roomId: string, messageType: string = 'text') => {
      return sendMessage(content, messageType, undefined, roomId);
    },
    [sendMessage]
  );

  // üî• SIMPLIFIED Disconnect function
  const disconnect = useCallback(() => {
    clearSession(); // ŸÖÿ≥ÿ≠ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ¨ŸÑÿ≥ÿ©
    if (socket.current) {
      socket.current.removeAllListeners();
      socket.current.disconnect();
      socket.current = null;
      if (pingIntervalRef.current) {
        clearInterval(pingIntervalRef.current);
        pingIntervalRef.current = null;
      }
    }

    // ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿßŸÑÿ≠ÿßŸÑÿ©
    dispatch({ type: 'CLEAR_ALL', payload: undefined });
  }, []);

  // üî• SIMPLIFIED helper functions
  const ignoreUser = useCallback(
    async (userId: number) => {
      try {
        if (!state.currentUser?.id) return;
        await apiRequest(`/api/users/${state.currentUser.id}/ignore/${userId}`, { method: 'POST' });
        dispatch({ type: 'IGNORE_USER', payload: userId });
      } catch (e) {
        console.error('ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ:', e);
      }
    },
    [state.currentUser?.id]
  );

  const unignoreUser = useCallback(
    async (userId: number) => {
      try {
        if (!state.currentUser?.id) return;
        await apiRequest(`/api/users/${state.currentUser.id}/ignore/${userId}`, {
          method: 'DELETE',
        });
        dispatch({ type: 'UNIGNORE_USER', payload: userId });
      } catch (e) {
        console.error('ŸÅÿ¥ŸÑ ŸÅŸä ÿ•ŸÑÿ∫ÿßÿ° ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ:', e);
      }
    },
    [state.currentUser?.id]
  );

  const sendTyping = useCallback(() => {
    if (socket.current?.connected) {
      socket.current.emit('typing', { isTyping: true });
    }
  }, []);

  // Compatibility helpers for UI components
  const handleTyping = useCallback(() => {
    sendTyping();
  }, [sendTyping]);

  const getCurrentRoomMessages = useCallback(() => currentRoomMessages, [currentRoomMessages]);

  const updateCurrentUser = useCallback(
    (updates: Partial<ChatUser>) => {
      if (!state.currentUser) return;
      const merged = { ...state.currentUser, ...updates } as ChatUser;
      dispatch({ type: 'SET_CURRENT_USER', payload: merged });
    },
    [state.currentUser]
  );

  // ÿ™ÿ≠ŸÖŸäŸÑ ÿ≥ÿ¨ŸÑ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ© ÿßŸÑÿÆÿßÿµÿ© ÿπŸÜÿØ ŸÅÿ™ÿ≠Ÿáÿß
  const loadPrivateConversation = useCallback(
    async (otherUserId: number, limit: number = 50) => {
      if (!state.currentUser?.id) return;
      try {
        const data = await apiRequest(
          `/api/private-messages/${state.currentUser.id}/${otherUserId}?limit=${limit}`
        );
        const formatted = Array.isArray((data as any)?.messages)
          ? mapDbMessagesToChatMessages((data as any).messages)
          : [];
        dispatch({
          type: 'SET_PRIVATE_CONVERSATION',
          payload: { userId: otherUserId, messages: formatted },
        });
      } catch (error) {
        console.error('‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿÆÿßÿµ:', error);
      }
    },
    [state.currentUser?.id]
  );

  const loadOlderPrivateConversation = useCallback(
    async (otherUserId: number, limit: number = 20) => {
      if (!state.currentUser?.id) return { addedCount: 0, hasMore: false };
      try {
        const existing = state.privateConversations[otherUserId] || [];
        const earliestTs =
          existing.length > 0 ? new Date(existing[0].timestamp).toISOString() : undefined;
        const url = `/api/private-messages/${state.currentUser.id}/${otherUserId}?limit=${limit}${
          earliestTs ? `&beforeTs=${encodeURIComponent(earliestTs)}` : ''
        }`;
        const data = await apiRequest(url);
        const formatted = Array.isArray((data as any)?.messages)
          ? mapDbMessagesToChatMessages((data as any).messages)
          : [];
        if (formatted.length > 0) {
          dispatch({
            type: 'PREPEND_PRIVATE_MESSAGES',
            payload: { userId: otherUserId, messages: formatted },
          });
        }
        const hasMore = !!(data as any)?.hasMore;
        return { addedCount: formatted.length, hasMore };
      } catch (error) {
        console.error('‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿ±ÿ≥ÿßÿ¶ŸÑ ÿ£ŸÇÿØŸÖ ŸÑŸÑÿÆÿßÿµ:', error);
        return { addedCount: 0, hasMore: false };
      }
    },
    [state.currentUser?.id, state.privateConversations]
  );

  return {
    // State
    currentUser: state.currentUser,
    onlineUsers: memoizedOnlineUsers,
    publicMessages: currentRoomMessages, // ‚úÖ ŸÖÿµÿØÿ± Ÿàÿßÿ≠ÿØ ŸÑŸÑÿ≠ŸÇŸäŸÇÿ©
    privateConversations: state.privateConversations,
    ignoredUsers: state.ignoredUsers,
    isConnected: state.isConnected,
    typingUsers: state.typingUsers,
    connectionError: state.connectionError,
    newMessageSender: state.newMessageSender,
    isLoading: state.isLoading,
    notifications: state.notifications,
    currentRoomId: state.currentRoomId,
    roomMessages: state.roomMessages,
    showKickCountdown: state.showKickCountdown,

    // Notification states
    levelUpNotification,
    setLevelUpNotification,
    achievementNotification,
    setAchievementNotification,
    dailyBonusNotification,
    setDailyBonusNotification,

    // ‚úÖ Actions - ŸÖÿ®ÿ≥ÿ∑ÿ© ŸàŸàÿßÿ∂ÿ≠ÿ©
    connect,
    disconnect,
    sendMessage,
    sendRoomMessage,
    joinRoom,
    loadRoomMessages,
    ignoreUser,
    unignoreUser,
    sendTyping,
    setShowKickCountdown: (show: boolean) =>
      dispatch({ type: 'SET_SHOW_KICK_COUNTDOWN', payload: show }),
    setNewMessageSender: (sender: ChatUser | null) =>
      dispatch({ type: 'SET_NEW_MESSAGE_SENDER', payload: sender }),

    // Convenience wrappers
    sendPublicMessage: (content: string) => sendMessage(content, 'text'),

    // Newly added helpers for compatibility
    handleTyping,
    getCurrentRoomMessages,
    updateCurrentUser,
    loadPrivateConversation,
    loadOlderPrivateConversation,

    // Broadcast handlers registration
    addBroadcastMessageHandler: (handler: (data: any) => void) => {
      broadcastHandlers.current.add(handler);
    },
    removeBroadcastMessageHandler: (handler: (data: any) => void) => {
      broadcastHandlers.current.delete(handler);
    },

    // WebRTC signaling helpers
    sendWebRTCOffer: (targetUserId: number, roomId: string, sdp: any) => {
      if (!socket.current?.connected || !state.currentUser) return;
      socket.current.emit('webrtc-offer', {
        roomId,
        targetUserId,
        sdp,
        senderId: state.currentUser.id,
      });
    },
    sendWebRTCAnswer: (targetUserId: number, roomId: string, sdp: any) => {
      if (!socket.current?.connected || !state.currentUser) return;
      socket.current.emit('webrtc-answer', {
        roomId,
        targetUserId,
        sdp,
        senderId: state.currentUser.id,
      });
    },
    sendWebRTCIceCandidate: (targetUserId: number, roomId: string, candidate: any) => {
      if (!socket.current?.connected || !state.currentUser) return;
      socket.current.emit('webrtc-ice-candidate', {
        roomId,
        targetUserId,
        candidate,
        senderId: state.currentUser.id,
      });
    },
    onWebRTCOffer: (handler: (data: any) => void) => {
      webrtcOfferHandlers.current.add(handler);
    },
    offWebRTCOffer: (handler: (data: any) => void) => {
      webrtcOfferHandlers.current.delete(handler);
    },
    onWebRTCAnswer: (handler: (data: any) => void) => {
      webrtcAnswerHandlers.current.add(handler);
    },
    offWebRTCAnswer: (handler: (data: any) => void) => {
      webrtcAnswerHandlers.current.delete(handler);
    },
    onWebRTCIceCandidate: (handler: (data: any) => void) => {
      webrtcIceHandlers.current.add(handler);
    },
    offWebRTCIceCandidate: (handler: (data: any) => void) => {
      webrtcIceHandlers.current.delete(handler);
    },
  };
};

export type UseChatReturn = ReturnType<typeof useChat>;
