import { useState, useEffect, useRef, useCallback, useMemo, useReducer } from 'react';
import type { Socket } from 'socket.io-client';

import type { PrivateConversation } from '../../../shared/types';

import { apiRequest, queryClient } from '@/lib/queryClient';
import { connectSocket, saveSession, clearSession, getSession } from '@/lib/socket';
import type { ChatUser, ChatMessage } from '@/types/chat';
import type { Notification } from '@/types/chat';
import { mapDbMessagesToChatMessages } from '@/utils/messageUtils';
import { userCache, setCachedUser } from '@/utils/userCacheManager';

// Audio notification function
const playNotificationSound = () => {
  try {
    const audio = new Audio('/notification.mp3');
    audio.volume = 0.3;
    audio.play().catch(() => {
      try {
        const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gain = audioContext.createGain();

        oscillator.connect(gain);
        gain.connect(audioContext.destination);

        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
        gain.gain.setValueAtTime(0.001, audioContext.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.03, audioContext.currentTime + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.3);

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.3);
      } catch {
        // Silent fail
      }
    });
  } catch {
    // Silent fail
  }
};

// üî• SIMPLIFIED State interface - ÿ≠ÿ∞ŸÅ ÿßŸÑÿ™ÿπŸÇŸäÿØÿßÿ™
interface ChatState {
  currentUser: ChatUser | null;
  onlineUsers: ChatUser[];
  currentRoomId: string;
  roomMessages: Record<string, ChatMessage[]>; // ‚úÖ ŸÖÿµÿØÿ± Ÿàÿßÿ≠ÿØ ŸÑŸÑÿ≠ŸÇŸäŸÇÿ©
  privateConversations: PrivateConversation;
  ignoredUsers: Set<number>;
  isConnected: boolean;
  typingUsers: Set<string>;
  connectionError: string | null;
  newMessageSender: ChatUser | null;
  isLoading: boolean;
  notifications: Notification[];
  showKickCountdown: boolean;
  globalSoundEnabled: boolean;
  showSystemMessages: boolean;
}

// üî• SIMPLIFIED Action types - ÿ≠ÿ∞ŸÅ ÿßŸÑÿ™ÿ∂ÿßÿ±ÿ®
type ChatAction =
  | { type: 'SET_CURRENT_USER'; payload: ChatUser | null }
  | { type: 'SET_ONLINE_USERS'; payload: ChatUser[] }
  | { type: 'SET_ROOM_MESSAGES'; payload: { roomId: string; messages: ChatMessage[] } }
  | { type: 'ADD_ROOM_MESSAGE'; payload: { roomId: string; message: ChatMessage } }
  | { type: 'SET_PRIVATE_MESSAGE'; payload: { userId: number; message: ChatMessage } }
  | { type: 'SET_PRIVATE_CONVERSATION'; payload: { userId: number; messages: ChatMessage[] } }
  | { type: 'PREPEND_PRIVATE_MESSAGES'; payload: { userId: number; messages: ChatMessage[] } }
  | { type: 'SET_CONNECTION_STATUS'; payload: boolean }
  | { type: 'SET_TYPING_USERS'; payload: Set<string> }
  | { type: 'SET_CONNECTION_ERROR'; payload: string | null }
  | { type: 'SET_NEW_MESSAGE_SENDER'; payload: ChatUser | null }
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'ADD_NOTIFICATION'; payload: Notification }
  | { type: 'SET_CURRENT_ROOM'; payload: string }
  | { type: 'SET_SHOW_KICK_COUNTDOWN'; payload: boolean }
  | { type: 'IGNORE_USER'; payload: number }
  | { type: 'UNIGNORE_USER'; payload: number }
  | { type: 'CLEAR_ALL'; payload: void }
  | { type: 'UPSERT_ONLINE_USER'; payload: ChatUser }
  | { type: 'REMOVE_ONLINE_USER'; payload: number };

type ReactionCounts = { like: number; dislike: number; heart: number };

// üî• SIMPLIFIED Initial state
const initialState: ChatState = {
  currentUser: null,
  onlineUsers: [],
  currentRoomId: '',
  roomMessages: {},
  privateConversations: {},
  ignoredUsers: new Set(),
  isConnected: false,
  typingUsers: new Set(),
  connectionError: null,
  newMessageSender: null,
  isLoading: false,
  notifications: [],
  showKickCountdown: false,
  globalSoundEnabled: true,
  showSystemMessages: true,
};

// üî• SIMPLIFIED Reducer function - ÿ≠ÿ∞ŸÅ ÿßŸÑÿ™ÿπŸÇŸäÿØÿßÿ™ ŸàÿßŸÑÿ™ÿ∂ÿßÿ±ÿ®
function chatReducer(state: ChatState, action: ChatAction): ChatState {
  switch (action.type) {
    case 'SET_CURRENT_USER':
      return {
        ...state,
        currentUser: action.payload,
        globalSoundEnabled:
          typeof (action.payload as any)?.globalSoundEnabled === 'boolean'
            ? (action.payload as any).globalSoundEnabled
            : state.globalSoundEnabled,
        showSystemMessages:
          typeof (action.payload as any)?.showSystemMessages === 'boolean'
            ? (action.payload as any).showSystemMessages
            : state.showSystemMessages,
      };

    case 'SET_ONLINE_USERS': {
      // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÉÿßÿ¥ ŸÖÿπ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿßŸÑÿ¨ÿØŸäÿØÿ©
      action.payload.forEach(user => {
        if (user && user.id && user.username) {
          setCachedUser(user);
        }
      });
      // ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ ŸÅŸä ÿßŸÑŸÉÿßÿ¥
      userCache.updateOnlineStatus(action.payload.map(u => u.id));
      return { ...state, onlineUsers: action.payload };
    }

    case 'SET_ROOM_MESSAGES': {
      const { roomId, messages } = action.payload;
      return {
        ...state,
        roomMessages: { ...state.roomMessages, [roomId]: messages },
      };
    }

    case 'ADD_ROOM_MESSAGE': {
      const { roomId, message } = action.payload;
      const existingMessages = state.roomMessages[roomId] || [];

      // ‚úÖ ŸÅÿ≠ÿµ ÿ®ÿ≥Ÿäÿ∑ ŸÑŸÑÿ™ŸÉÿ±ÿßÿ± ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ID ÿ£Ÿà timestamp+content
      const isDuplicate = existingMessages.some(
        (msg) =>
          msg.id === message.id ||
          (msg.timestamp === message.timestamp &&
            msg.senderId === message.senderId &&
            msg.content === message.content)
      );

      if (isDuplicate) {
        return state; // ŸÑÿß ŸÜÿ∂ŸäŸÅ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖŸÉÿ±ÿ±ÿ©
      }

      // ÿ•ÿÆŸÅÿßÿ° ÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÜÿ∏ÿßŸÖ ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸäŸÅÿ∂ŸÑ ÿ•ÿÆŸÅÿßÿ°Ÿáÿß
      if (message.messageType === 'system' && state.showSystemMessages === false) {
        return state;
      }

      return {
        ...state,
        roomMessages: {
          ...state.roomMessages,
          [roomId]: [...existingMessages, message],
        },
      };
    }

    // ŸÖŸÑÿßÿ≠ÿ∏ÿ©: ÿ™ÿ≠ÿØŸäÿ´ÿßÿ™ ÿßŸÑÿ™ŸÅÿßÿπŸÑÿßÿ™ ÿ™Ÿèÿ∑ÿ®ŸëŸÇ ÿØÿßÿÆŸÑ ŸÖÿ≥ÿ™ŸÖÿπ ÿßŸÑÿ≥ŸàŸÉÿ™ ŸÖÿ®ÿßÿ¥ÿ±ÿ© ÿπÿ®ÿ± dispatch SET_ROOM_MESSAGES

    case 'SET_PRIVATE_MESSAGE': {
      const { userId, message } = action.payload;
      const existingMessages = state.privateConversations[userId] || [];

      // ŸÖŸÜÿπ ÿßŸÑÿ™ŸÉÿ±ÿßÿ± - ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿ®ŸÜŸÅÿ≥ ID ÿ£Ÿà ŸÜŸÅÿ≥ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ŸàÿßŸÑŸàŸÇÿ™
      const isDuplicate = existingMessages.some(
        (msg) =>
          (message.id && msg.id === message.id) ||
          (msg.content === message.content &&
            msg.senderId === message.senderId &&
            Math.abs(new Date(msg.timestamp).getTime() - new Date(message.timestamp).getTime()) <
              1000)
      );

      if (isDuplicate) {
        return state; // ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖŸÉÿ±ÿ±ÿ©
      }

      return {
        ...state,
        privateConversations: {
          ...state.privateConversations,
          [userId]: [...existingMessages, message],
        },
      };
    }

    case 'SET_PRIVATE_CONVERSATION': {
      const { userId, messages } = action.payload;
      // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ™ŸÉÿ±ÿßÿ±ÿßÿ™ ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ID ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©
      const uniqueMessages = messages.reduce((acc: ChatMessage[], msg) => {
        const exists = acc.some(
          (m) =>
            (msg.id && m.id === msg.id) ||
            (m.content === msg.content &&
              m.senderId === msg.senderId &&
              Math.abs(new Date(m.timestamp).getTime() - new Date(msg.timestamp).getTime()) < 1000)
        );
        if (!exists) {
          acc.push(msg);
        }
        return acc;
      }, []);

      return {
        ...state,
        privateConversations: {
          ...state.privateConversations,
          [userId]: uniqueMessages,
        },
      };
    }

    case 'PREPEND_PRIVATE_MESSAGES': {
      const { userId, messages } = action.payload;
      const existing = state.privateConversations[userId] || [];
      const existingIds = new Set(existing.map((m) => m.id));
      const toPrepend = messages.filter((m) => !existingIds.has(m.id));
      return {
        ...state,
        privateConversations: {
          ...state.privateConversations,
          [userId]: [...toPrepend, ...existing],
        },
      };
    }

    case 'UPSERT_ONLINE_USER': {
      const incoming = action.payload;
      if (!incoming || !incoming.id) {
        return state;
      }
      
      // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÉÿßÿ¥ ŸÖÿπ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ¨ÿØŸäÿØÿ©
      if (incoming.username) {
        setCachedUser(incoming);
      }
      const existingIndex = state.onlineUsers.findIndex((u) => u.id === incoming.id);
      if (existingIndex === -1) {
        // ŸÑÿß ÿ™ÿ∂ŸÅ ŸÖÿ≥ÿ™ÿÆÿØŸÖŸãÿß ÿ¨ÿØŸäÿØŸãÿß ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÖŸÜŸÇŸàÿµÿ© (ÿ™ÿ≠ÿØŸäÿ´ ÿ¨ÿ≤ÿ¶Ÿä ŸÖÿ´ŸÑ ÿßŸÑŸÑŸàŸÜ/ÿßŸÑÿ™ÿ£ÿ´Ÿäÿ±)
        const hasMinimum = !!(incoming.username && incoming.userType);
        if (!hasMinimum) {
          return state;
        }
        return { ...state, onlineUsers: [...state.onlineUsers, incoming] };
      }
      const merged = { ...state.onlineUsers[existingIndex], ...incoming } as ChatUser;
      const next = state.onlineUsers.slice();
      next[existingIndex] = merged;
      return { ...state, onlineUsers: next };
    }

    case 'REMOVE_ONLINE_USER': {
      const userId = action.payload;
      return { ...state, onlineUsers: state.onlineUsers.filter((u) => u.id !== userId) };
    }

    case 'SET_CONNECTION_STATUS':
      return { ...state, isConnected: action.payload };

    case 'SET_TYPING_USERS':
      return { ...state, typingUsers: action.payload };

    case 'SET_CONNECTION_ERROR':
      return { ...state, connectionError: action.payload };

    case 'SET_NEW_MESSAGE_SENDER':
      return { ...state, newMessageSender: action.payload };

    case 'SET_LOADING':
      return { ...state, isLoading: action.payload };

    case 'ADD_NOTIFICATION':
      return {
        ...state,
        notifications: [...state.notifications, action.payload],
      };

    case 'SET_CURRENT_ROOM':
      return { ...state, currentRoomId: action.payload };

    case 'SET_SHOW_KICK_COUNTDOWN':
      return { ...state, showKickCountdown: action.payload };

    case 'IGNORE_USER':
      return {
        ...state,
        ignoredUsers: new Set([...state.ignoredUsers, action.payload]),
      };

    case 'UNIGNORE_USER': {
      const newIgnoredUsers = new Set(state.ignoredUsers);
      newIgnoredUsers.delete(action.payload);
      return { ...state, ignoredUsers: newIgnoredUsers };
    }

    case 'CLEAR_ALL':
      return { ...initialState };

    default:
      return state;
  }
}

export const useChat = () => {
  const [state, dispatch] = useReducer(chatReducer, initialState);
  const socket = useRef<Socket | null>(null);

  // üî• SIMPLIFIED loading management - ŸÖÿµÿØÿ± Ÿàÿßÿ≠ÿØ
  const loadingRooms = useRef<Set<string>>(new Set());

  // Broadcast handlers registry
  const broadcastHandlers = useRef<Set<(data: any) => void>>(new Set());

  // WebRTC signaling handlers registries
  const webrtcOfferHandlers = useRef<Set<(data: any) => void>>(new Set());
  const webrtcAnswerHandlers = useRef<Set<(data: any) => void>>(new Set());
  const webrtcIceHandlers = useRef<Set<(data: any) => void>>(new Set());

  // Notification states
  const [levelUpNotification, setLevelUpNotification] = useState<any>(null);
  const [achievementNotification, setAchievementNotification] = useState<any>(null);
  const [dailyBonusNotification, setDailyBonusNotification] = useState<any>(null);

  // Refs to avoid stale closures in socket listeners
  const currentUserRef = useRef<ChatUser | null>(null);
  const currentRoomIdRef = useRef<string>(initialState.currentRoomId);
  const ignoredUsersRef = useRef<Set<number>>(new Set());
  const roomMessagesRef = useRef<Record<string, ChatMessage[]>>({});
  const typingTimersRef = useRef<Map<number, number>>(new Map());
  // Throttle ŸÑŸÖŸÜÿπ ÿ•ÿ±ÿ≥ÿßŸÑ joinRoom ÿ£ŸÉÿ´ÿ± ŸÖŸÜ ŸÖÿ±ÿ© ÿÆŸÑÿßŸÑ ŸÜÿßŸÅÿ∞ÿ© ÿ≤ŸÖŸÜŸäÿ© ŸÇÿµŸäÿ±ÿ©
  const lastJoinEmitTsRef = useRef<number>(0);
  // Prevent duplicate handling for kick/ban events and centralize navigation
  const kickHandledRef = useRef<boolean>(false);
  // Track pending room join request if requested before socket connects
  const pendingJoinRoomRef = useRef<string | null>(null);

  useEffect(() => {
    currentUserRef.current = state.currentUser;
  }, [state.currentUser]);
  useEffect(() => {
    currentRoomIdRef.current = state.currentRoomId;
  }, [state.currentRoomId]);
  useEffect(() => {
    ignoredUsersRef.current = state.ignoredUsers;
  }, [state.ignoredUsers]);
  useEffect(() => {
    roomMessagesRef.current = state.roomMessages;
  }, [state.roomMessages]);

  // ‚úÖ Memoized current room messages - ÿ≠ŸÑ ŸÖÿ¥ŸÉŸÑÿ© ÿßŸÑŸÄ performance
  const currentRoomMessages = useMemo(() => {
    return state.roomMessages[state.currentRoomId] || [];
  }, [state.roomMessages, state.currentRoomId]);

  // ‚úÖ Memoized online users
  const memoizedOnlineUsers = useMemo(() => {
    const filtered = state.onlineUsers.filter(
      (user) =>
        user && user.id && user.username && user.userType && !state.ignoredUsers.has(user.id)
    );
    // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ™ŸÉÿ±ÿßÿ±ÿßÿ™
    const dedup = new Map<number, ChatUser>();
    for (const u of filtered) {
      if (!dedup.has(u.id)) dedup.set(u.id, u);
    }
    return Array.from(dedup.values());
  }, [state.onlineUsers, state.ignoredUsers]);

  // üî• SIMPLIFIED Message loading - ÿ≠ÿ∞ŸÅ ÿßŸÑÿ™ÿπŸÇŸäÿØÿßÿ™
  const loadRoomMessages = useCallback(
    async (roomId: string, forceReload: boolean = false) => {
      // ŸÜÿπÿ™ŸÖÿØ ÿßŸÑÿ¢ŸÜ ÿπŸÑŸâ Socket ŸÑÿ•ÿ±ÿ≥ÿßŸÑ ÿ¢ÿÆÿ± ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿπŸÜÿØ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖÿå
      // ŸÑŸÉŸÜ ŸÜŸèÿ®ŸÇŸä Ÿáÿ∞ÿß ŸÉŸÜÿ≥ÿÆÿ© ÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿäÿ© ÿ≥ÿ±Ÿäÿπÿ© ÿ™ÿ∑ŸÑÿ® 12 ÿ±ÿ≥ÿßŸÑÿ© ŸÅŸÇÿ∑.

      if (!forceReload && state.roomMessages[roomId]?.length > 0) {
        return;
      }

      if (loadingRooms.current.has(roomId)) {
        return;
      }

      loadingRooms.current.add(roomId);

      try {
        const data = await apiRequest(`/api/messages/room/${roomId}/latest?limit=12`);

        if (data?.messages && Array.isArray(data.messages)) {
          const formattedMessages = mapDbMessagesToChatMessages(data.messages, roomId);
          dispatch({
            type: 'SET_ROOM_MESSAGES',
            payload: { roomId, messages: formattedMessages },
          });
        }
      } catch (error) {
        console.error(`‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ∫ÿ±ŸÅÿ© ${roomId}:`, error);
      } finally {
        loadingRooms.current.delete(roomId);
      }
    },
    [state.roomMessages]
  );

  // Track ping interval to avoid leaks
  const pingIntervalRef = useRef<number | null>(null);
  const backgroundPingIntervalRef = useRef<number | null>(null);
  const isBackgroundRef = useRef<boolean>(false);
  const socketWorkerRef = useRef<Worker | null>(null);
  const serviceWorkerRef = useRef<ServiceWorker | null>(null);

  // üî• SIMPLIFIED Socket event handling - ÿ≠ÿ∞ŸÅ ÿßŸÑÿ™ÿ∂ÿßÿ±ÿ®
  const setupSocketListeners = useCallback((socketInstance: Socket) => {
    // üî• ÿ™ŸáŸäÿ¶ÿ© Service Worker ŸÑŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ ÿßŸÑÿßÿ™ÿµÿßŸÑ ŸÅŸä ÿßŸÑÿÆŸÑŸÅŸäÿ©
    const initServiceWorker = async () => {
      try {
        if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
          serviceWorkerRef.current = navigator.serviceWorker.controller;
          
          // ÿ•ÿπÿØÿßÿØ ŸÖÿπÿßŸÑÿ¨ ÿ±ÿ≥ÿßÿ¶ŸÑ Service Worker
          navigator.serviceWorker.addEventListener('message', (event) => {
            const { type, data } = event.data;
            
            switch (type) {
              case 'background-ping-success':
                console.log('‚úÖ Service Worker: ping ŸÜÿ¨ÿ≠ ŸÅŸä ÿßŸÑÿÆŸÑŸÅŸäÿ©');
                break;
            }
          });
          
          // ÿ™ŸáŸäÿ¶ÿ© Service Worker
          serviceWorkerRef.current.postMessage({
            type: 'init-background-sync',
            data: { serverUrl: window.location.origin }
          });
          
          console.log('üöÄ ÿ™ŸÖ ÿ™ŸáŸäÿ¶ÿ© Service Worker ŸÑŸÑŸÄ Socket.IO');
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è ŸÑÿß ŸäŸÖŸÉŸÜ ÿ™ŸáŸäÿ¶ÿ© Service Worker:', error);
      }
    };
    
    // ÿ™ŸáŸäÿ¶ÿ© Service Worker
    initServiceWorker();
    
    // üî• ÿ™ŸáŸäÿ¶ÿ© Web Worker ŸÑŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ ÿßŸÑÿßÿ™ÿµÿßŸÑ ŸÅŸä ÿßŸÑÿÆŸÑŸÅŸäÿ©
    const initSocketWorker = () => {
      try {
        if (typeof Worker !== 'undefined' && !socketWorkerRef.current) {
          socketWorkerRef.current = new Worker('/socket-worker.js');
          
          // ŸÖÿπÿßŸÑÿ¨ÿ© ÿ±ÿ≥ÿßÿ¶ŸÑ Web Worker
          socketWorkerRef.current.onmessage = (event) => {
            const { type, data } = event.data;
            
            switch (type) {
              case 'send-ping':
                // ÿ•ÿ±ÿ≥ÿßŸÑ ping ŸÑŸÑÿÆÿßÿØŸÖ
                if (socketInstance.connected) {
                  socketInstance.emit('client_ping');
                }
                break;
                
              case 'worker-ready':
                console.log('üîß Web Worker ÿ¨ÿßŸáÿ≤ ŸÑŸÑÿπŸÖŸÑ');
                break;
                
              case 'worker-error':
                console.error('‚ùå ÿÆÿ∑ÿ£ ŸÅŸä Web Worker:', data.error);
                break;
            }
          };
          
          // ÿ™ŸáŸäÿ¶ÿ© Web Worker
          socketWorkerRef.current.postMessage({
            type: 'init',
            data: { pingInterval: 20000 }
          });
          
          console.log('üöÄ ÿ™ŸÖ ÿ™ŸáŸäÿ¶ÿ© Web Worker ŸÑŸÑŸÄ Socket.IO');
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è ŸÑÿß ŸäŸÖŸÉŸÜ ÿ™ŸáŸäÿ¶ÿ© Web Worker:', error);
      }
    };
    
    // ÿ™ŸáŸäÿ¶ÿ© Web Worker
    initSocketWorker();
    // ŸÖÿ≤ÿßŸÖŸÜÿ© ÿ≠ÿßŸÑÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ ŸÖÿπ Web Worker ŸÑŸäÿπÿ±ŸÅ ŸÖÿ™Ÿâ ŸäŸèÿ±ÿ≥ŸÑ ping
    try {
      socketInstance.on('connect', () => {
        try {
          if (socketWorkerRef.current) {
            socketWorkerRef.current.postMessage({
              type: 'socket-status',
              data: { connected: true },
            });
          }
        } catch {}
      });
      socketInstance.on('disconnect', () => {
        try {
          if (socketWorkerRef.current) {
            socketWorkerRef.current.postMessage({
              type: 'socket-status',
              data: { connected: false },
            });
          }
        } catch {}
      });
      socketInstance.on('connect_error', () => {
        try {
          if (socketWorkerRef.current) {
            socketWorkerRef.current.postMessage({
              type: 'socket-status',
              data: { connected: false },
            });
          }
        } catch {}
      });
    } catch {}

    
    // üî• ÿ≠ÿßŸÅÿ∏ ÿπŸÑŸâ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿπÿ®ÿ± ping/pong ŸÖÿ≠ÿ≥ŸëŸÜ ŸÖÿπ ŸÇŸäÿßÿ≥ ÿßŸÑŸÉŸÖŸàŸÜ
    if (pingIntervalRef.current) {
      clearInterval(pingIntervalRef.current);
    }
    if (backgroundPingIntervalRef.current) {
      clearInterval(backgroundPingIntervalRef.current);
    }
    
    let lastPingTime = 0;
    
    // üî• ŸÜÿ∏ÿßŸÖ ping/pong ÿ∞ŸÉŸä Ÿäÿ™ŸÉŸäŸÅ ŸÖÿπ ÿ≠ÿßŸÑÿ© ÿßŸÑÿµŸÅÿ≠ÿ©
    const startPing = (interval: number) => {
      const pingId = window.setInterval(() => {
        if (socketInstance.connected) {
          lastPingTime = Date.now();
          socketInstance.emit('client_ping');
        }
      }, interval);
      return pingId;
    };
    
    // ÿ®ÿØÿ° ping ÿπÿßÿØŸä (ŸÉŸÑ 20 ÿ´ÿßŸÜŸäÿ©)
    pingIntervalRef.current = startPing(20000);
    
    // üî• ŸÇŸäÿßÿ≥ ÿßŸÑŸÉŸÖŸàŸÜ Ÿàÿ™ÿ≥ÿ¨ŸäŸÑ ÿ≠ÿßŸÑÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ
    socketInstance.on('client_pong', (data: any) => {
      if (lastPingTime > 0) {
        const latency = Date.now() - lastPingTime;
        // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÉŸÖŸàŸÜ ŸÑŸÑÿ™ÿ¥ÿÆŸäÿµ (ŸÅŸä ÿ®Ÿäÿ¶ÿ© ÿßŸÑÿ™ÿ∑ŸàŸäÿ± ŸÅŸÇÿ∑)
        if ((import.meta as any)?.env?.DEV && latency > 1000) {
          console.warn(`‚ö†Ô∏è ŸÉŸÖŸàŸÜ ÿπÿßŸÑŸä: ${latency}ms`);
        }
      }
    });

    // üî• ŸÖÿπÿßŸÑÿ¨ÿßÿ™ Page Visibility API ŸÑŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ ÿßŸÑÿßÿ™ÿµÿßŸÑ ŸÅŸä ÿßŸÑÿÆŸÑŸÅŸäÿ©
    const handleVisibilityChange = () => {
      if (document.hidden && !isBackgroundRef.current) {
        // ÿßŸÑÿµŸÅÿ≠ÿ© ÿ£ÿµÿ®ÿ≠ÿ™ ŸÅŸä ÿßŸÑÿÆŸÑŸÅŸäÿ© - ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Web Worker ŸÑŸÑping
        isBackgroundRef.current = true;
        console.log('üîÑ ÿßŸÑÿµŸÅÿ≠ÿ© ŸÅŸä ÿßŸÑÿÆŸÑŸÅŸäÿ© - ÿ™ŸÅÿπŸäŸÑ Web Worker ŸÑŸÑping');
        
        if (pingIntervalRef.current) {
          clearInterval(pingIntervalRef.current);
        }
        
        // ÿ™ŸÅÿπŸäŸÑ Web Worker Ÿà Service Worker ŸÑŸÑping ŸÅŸä ÿßŸÑÿÆŸÑŸÅŸäÿ©
        if (socketWorkerRef.current) {
          socketWorkerRef.current.postMessage({
            type: 'start-ping',
            data: { interval: 60000 } // ping ŸÉŸÑ 60 ÿ´ÿßŸÜŸäÿ© ŸÅŸä ÿßŸÑÿÆŸÑŸÅŸäÿ©
          });
        }
        
        if (serviceWorkerRef.current) {
          serviceWorkerRef.current.postMessage({
            type: 'start-background-ping',
            data: { interval: 60000 } // ping ŸÉŸÑ 60 ÿ´ÿßŸÜŸäÿ© ŸÅŸä ÿßŸÑÿÆŸÑŸÅŸäÿ©
          });
        }
        
        if (!socketWorkerRef.current && !serviceWorkerRef.current) {
          // fallback ÿ•ŸÑŸâ ping ÿ£ÿ®ÿ∑ÿ£ ÿ•ÿ∞ÿß ŸÑŸÖ Ÿäÿ™ŸàŸÅÿ± Web Worker ÿ£Ÿà Service Worker
          backgroundPingIntervalRef.current = startPing(60000);
        }
        
      } else if (!document.hidden && isBackgroundRef.current) {
        // ÿßŸÑÿµŸÅÿ≠ÿ© ÿπÿßÿØÿ™ ŸÑŸÑŸÖŸÇÿØŸÖÿ© - ÿ•ŸäŸÇÿßŸÅ Web Worker Ÿàÿßÿ≥ÿ™ÿπÿßÿØÿ© ping ÿßŸÑÿπÿßÿØŸä
        isBackgroundRef.current = false;
        console.log('üîÑ ÿßŸÑÿµŸÅÿ≠ÿ© ŸÅŸä ÿßŸÑŸÖŸÇÿØŸÖÿ© - ÿ•ŸäŸÇÿßŸÅ Web Worker Ÿàÿßÿ≥ÿ™ÿπÿßÿØÿ© ping ÿßŸÑÿπÿßÿØŸä');
        
        // ÿ•ŸäŸÇÿßŸÅ Web Worker Ÿà Service Worker
        if (socketWorkerRef.current) {
          socketWorkerRef.current.postMessage({
            type: 'stop-ping',
            data: {}
          });
        }
        
        if (serviceWorkerRef.current) {
          serviceWorkerRef.current.postMessage({
            type: 'stop-background-ping',
            data: {}
          });
        }
        
        if (backgroundPingIntervalRef.current) {
          clearInterval(backgroundPingIntervalRef.current);
        }
        // ping ÿπÿßÿØŸä ŸÅŸä ÿßŸÑŸÖŸÇÿØŸÖÿ© (ŸÉŸÑ 20 ÿ´ÿßŸÜŸäÿ©)
        pingIntervalRef.current = startPing(20000);

        // ÿ≠ÿßŸàŸÑ ÿ•ÿπÿßÿØÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ ŸÅŸàÿ± ÿßŸÑÿπŸàÿØÿ© ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑÿßÿ™ÿµÿßŸÑ ŸÖŸÇÿ∑ŸàÿπÿßŸã
        try {
          if (!socketInstance.connected) {
            socketInstance.connect();
          }
        } catch {}
      }
    };

    // ÿ•ÿ∂ÿßŸÅÿ© ŸÖÿπÿßŸÑÿ¨ Page Visibility
    document.addEventListener('visibilitychange', handleVisibilityChange);

    // ÿØÿπŸÖ ÿ£ŸÅÿ∂ŸÑ ŸÑÿØŸàÿ±ÿ© ÿ≠Ÿäÿßÿ© ÿßŸÑÿµŸÅÿ≠ÿ© ÿπŸÑŸâ ÿßŸÑÿ£ÿ¨Ÿáÿ≤ÿ© ÿßŸÑŸÖÿ≠ŸÖŸàŸÑÿ©: pageshow/pagehide
    const handlePageShow = () => {
      try {
        if (socket.current && !socket.current.connected) {
          socket.current.connect();
        }
      } catch {}
    };
    const handlePageHide = () => {
      try {
        // ÿ™ÿ£ŸÉŸäÿØ ÿ™ŸÅÿπŸäŸÑ ÿßŸÑping ŸÅŸä ÿßŸÑÿÆŸÑŸÅŸäÿ© ÿπŸÜÿØ ÿßŸÑÿßŸÜÿ™ŸÇÿßŸÑ ŸÑŸÑÿÆŸÑŸÅŸäÿ©
        if (socketWorkerRef.current) {
          socketWorkerRef.current.postMessage({ type: 'start-ping', data: { interval: 60000 } });
        }
        if (serviceWorkerRef.current) {
          serviceWorkerRef.current.postMessage({ type: 'start-background-ping', data: { interval: 60000 } });
        }
      } catch {}
    };
    window.addEventListener('pageshow', handlePageShow);
    window.addEventListener('pagehide', handlePageHide);
    
    // ÿ™ŸÜÿ∏ŸäŸÅ ŸÖÿπÿßŸÑÿ¨ Page Visibility ÿπŸÜÿØ ÿ•ÿ∫ŸÑÿßŸÇ Socket
    const originalDisconnect = socketInstance.disconnect;
    socketInstance.disconnect = function() {
      try {
        if (socketWorkerRef.current) {
          socketWorkerRef.current.postMessage({
            type: 'socket-status',
            data: { connected: false },
          });
        }
      } catch {}
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      try { window.removeEventListener('pageshow', handlePageShow); } catch {}
      try { window.removeEventListener('pagehide', handlePageHide); } catch {}
      if (pingIntervalRef.current) {
        clearInterval(pingIntervalRef.current);
      }
      if (backgroundPingIntervalRef.current) {
        clearInterval(backgroundPingIntervalRef.current);
      }
      // ÿ™ŸÜÿ∏ŸäŸÅ Web Worker Ÿà Service Worker
      if (socketWorkerRef.current) {
        socketWorkerRef.current.postMessage({ type: 'cleanup' });
        socketWorkerRef.current.terminate();
        socketWorkerRef.current = null;
      }
      
      if (serviceWorkerRef.current) {
        serviceWorkerRef.current.postMessage({
          type: 'stop-background-ping',
          data: {}
        });
        serviceWorkerRef.current = null;
      }
      return originalDisconnect.call(this);
    };

    // ÿ®ÿπÿØ ÿßŸÑŸÖÿµÿßÿØŸÇÿ© ÿßŸÑŸÜÿßÿ¨ÿ≠ÿ© ŸÖŸÜ ÿßŸÑÿÆÿßÿØŸÖÿå ÿßŸÜÿ∂ŸÖ ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã ŸÑŸÑÿ∫ÿ±ŸÅÿ© ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ© ÿ£Ÿà ÿßŸÑÿπÿßŸÖÿ©
    socketInstance.on('authenticated', () => {
      try {
        let desired = (
          pendingJoinRoomRef.current ||
          (() => {
            try { return getSession()?.roomId as string | undefined; } catch { return undefined; }
          })() ||
          currentRoomIdRef.current ||
          'general'
        );
        // ÿ™ÿ¨ÿßŸáŸÑ ŸÖÿπÿ±ŸÅÿßÿ™ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ© Ÿàÿ™ÿ≠ŸàŸäŸÑŸáÿß ŸÑŸÑÿ∫ÿ±ŸÅÿ© ÿßŸÑÿπÿßŸÖÿ©
        if (desired === 'public' || desired === 'friends' || !desired?.trim()) {
          desired = 'general';
        }
        if (!currentUserRef.current) return;
        // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸáŸÜÿßŸÉ ÿ∑ŸÑÿ® ÿßŸÜÿ∂ŸÖÿßŸÖ ÿ¨ÿßÿ±Ÿç ÿ£Ÿà ŸÜÿ≠ŸÜ ÿ®ÿßŸÑŸÅÿπŸÑ ŸÅŸä ŸÜŸÅÿ≥ ÿßŸÑÿ∫ÿ±ŸÅÿ©ÿå ŸÑÿß ÿ™ÿ±ÿ≥ŸÑ
        if (pendingJoinRoomRef.current !== null) return;
        if (currentRoomIdRef.current && currentRoomIdRef.current === desired) return;
        // Throttle: ÿßŸÖŸÜÿπ ÿßŸÑÿ™ŸÉÿ±ÿßÿ± ÿÆŸÑÿßŸÑ ŸÜÿßŸÅÿ∞ÿ© ŸÇÿµŸäÿ±ÿ©
        const now = Date.now();
        if (now - lastJoinEmitTsRef.current < 1500) return;
        pendingJoinRoomRef.current = desired;
        lastJoinEmitTsRef.current = now;
        socketInstance.emit('joinRoom', {
          roomId: desired,
          userId: currentUserRef.current.id,
          username: currentUserRef.current.username,
        });
      } catch {}
    });

    // ŸÑŸÖ ŸÜÿπÿØ ŸÜÿ≥ÿ™ÿÆÿØŸÖ polling ŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ™ÿµŸÑŸäŸÜÿõ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± Ÿäÿ®ÿ´ ÿßŸÑÿ™ÿ≠ÿØŸäÿ´ÿßÿ™ ŸÖÿ®ÿßÿ¥ÿ±ÿ©

    // ‚úÖ ÿßÿ≥ÿ™ŸÇÿ®ÿßŸÑ ÿ•ÿ¥ÿπÿßÿ± ÿ¨ÿØŸäÿØ ŸÖÿ®ÿßÿ¥ÿ± ŸÖŸÜ ÿßŸÑÿÆÿßÿØŸÖ Ÿàÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸàÿßÿ¨Ÿáÿ© ŸÅŸàÿ±ÿßŸã
    socketInstance.on('newNotification', (payload: any) => {
      try {
        // ÿ£ÿ®ŸÑÿ∫ ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ŸÑÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÉÿßÿ¥ ŸàÿßŸÑÿπÿØÿßÿØ ŸÖÿ®ÿßÿ¥ÿ±ÿ©
        const detail = { notification: payload?.notification } as any;
        window.dispatchEvent(new CustomEvent('notificationReceived', { detail }));
        // ÿ≤ŸäÿßÿØÿ© ŸÅŸàÿ±Ÿäÿ© ŸÑÿπÿØÿßÿØ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿ∫Ÿäÿ± ÿßŸÑŸÖŸÇÿ±Ÿàÿ°ÿ© ŸÅŸä Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
        try {
          const userId = currentUserRef.current?.id;
          if (userId) {
            const { queryClient } = require('@/lib/queryClient');
            const qc = queryClient as import('@tanstack/react-query').QueryClient;
            const key = ['/api/notifications/unread-count', userId];
            const old = qc.getQueryData(key) as any;
            const current = typeof old?.count === 'number' ? old.count : 0;
            qc.setQueryData(key, { count: current + 1 });
          }
        } catch {}
      } catch {}
    });

    // ‚úÖ ŸÖÿπÿßŸÑÿ¨ Ÿàÿßÿ≠ÿØ ŸÑŸÑÿ±ÿ≥ÿßÿ¶ŸÑ - ÿ≠ÿ∞ŸÅ ÿßŸÑÿ™ÿ∂ÿßÿ±ÿ®
    socketInstance.on('message', (data: any) => {
      try {
        const envelope = data.envelope || data;

        // ÿ™ŸÖ ÿ•ÿ≤ÿßŸÑÿ© ŸÖÿ≥ÿßÿ± authenticated ÿØÿßÿÆŸÑ ŸÇŸÜÿßÿ© message ŸÑÿ™ÿ¨ŸÜŸëÿ® ÿßŸÜÿ∂ŸÖÿßŸÖ ŸÖŸÉÿ±ÿ±

        // ÿ™ÿ≠ÿØŸäÿ´ ÿ™ÿ£ÿ´Ÿäÿ± ÿßŸÑÿ®ÿ±ŸàŸÅÿßŸäŸÑ ŸÅŸÇÿ∑ ÿπŸÜÿØ ŸàÿµŸàŸÑ ÿ®ÿ´ profileEffectChanged
        if (envelope.type === 'profileEffectChanged') {
          const { userId, profileEffect, user } = envelope as any;
          const targetId = userId || user?.id;
          if (targetId) {
            if (currentUserRef.current?.id === targetId) {
              dispatch({
                type: 'SET_CURRENT_USER',
                payload: {
                  ...currentUserRef.current!,
                  profileEffect:
                    profileEffect ?? user?.profileEffect ?? currentUserRef.current?.profileEffect,
                } as any,
              });
            }
            dispatch({
              type: 'UPSERT_ONLINE_USER',
              payload: { id: targetId, profileEffect: profileEffect ?? user?.profileEffect } as any,
            });
          }
        }

        // ÿ•ÿ¥ÿπÿßÿ± ŸÜÿ∏ÿßŸÖŸä ÿπÿßŸÖ ŸäÿµŸÑ ÿπÿ®ÿ± ŸÇŸÜÿßÿ© ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖŸàÿ≠ÿØÿ©
        if (envelope.type === 'systemNotification') {
          try {
            const detail = { notification: (envelope as any).notification } as any;
            window.dispatchEvent(new CustomEvent('notificationReceived', { detail }));
          } catch {}
        }

        // ÿ®ÿ´ ÿÆÿßÿµ ŸÑÿ™ÿ≠ÿØŸäÿ´ ŸÑŸàŸÜ ÿßŸÑÿßÿ≥ŸÖ ŸÅŸÇÿ∑
        if (envelope.type === 'usernameColorChanged') {
          const { userId, color, user } = envelope as any;
          const targetId = userId || user?.id;
          if (targetId && color) {
            if (currentUserRef.current?.id === targetId) {
              dispatch({
                type: 'SET_CURRENT_USER',
                payload: { ...currentUserRef.current!, usernameColor: color } as any,
              });
            }
            dispatch({
              type: 'UPSERT_ONLINE_USER',
              payload: { id: targetId, usernameColor: color } as any,
            });
          }
        }

        // ÿ™ÿ≠ÿØŸäÿ´ ŸÑŸàŸÜ ÿµŸÜÿØŸàŸÇ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ (profileBackgroundColor)
        if (envelope.type === 'user_background_updated') {
          const { data } = envelope as any;
          const targetId = data?.userId;
          const color = data?.profileBackgroundColor;
          if (targetId && color) {
            if (currentUserRef.current?.id === targetId) {
              dispatch({
                type: 'SET_CURRENT_USER',
                payload: { ...currentUserRef.current!, profileBackgroundColor: color } as any,
              });
            }
            dispatch({
              type: 'UPSERT_ONLINE_USER',
              payload: { id: targetId, profileBackgroundColor: color } as any,
            });
          }
        }

        // ÿ™ÿ≠ÿØŸäÿ´ ÿµŸàÿ±ÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
        if (envelope.type === 'userAvatarUpdated') {
          const { userId, avatarHash, avatarVersion, users } = envelope as any;

          if (userId) {
            // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÅŸä ÿßŸÑŸÇÿßÿ¶ŸÖÿ©
            dispatch({
              type: 'UPSERT_ONLINE_USER',
              payload: { id: userId, avatarHash, avatarVersion } as any,
            });

            // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ≠ÿßŸÑŸä
            if (currentUserRef.current?.id === userId) {
              dispatch({
                type: 'SET_CURRENT_USER',
                payload: {
                  ...currentUserRef.current!,
                  avatarHash: avatarHash || (currentUserRef.current as any).avatarHash,
                  avatarVersion: avatarVersion || (currentUserRef.current as any).avatarVersion,
                } as any,
              });
            }
          }

          // ÿ™ÿ≠ÿØŸäÿ´ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿ•ÿ∞ÿß ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑŸáÿß
          if (users && Array.isArray(users)) {
            dispatch({ type: 'SET_ONLINE_USERS', payload: users });
          }
        }

        // ÿ™ÿ≠ÿØŸäÿ´ ÿµŸàÿ±ÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ≠ÿßŸÑŸä ÿπÿ®ÿ± ÿ¨ŸÖŸäÿπ ÿßŸÑÿ£ÿ¨Ÿáÿ≤ÿ©
        if (envelope.type === 'selfAvatarUpdated') {
          const { avatarHash, avatarVersion } = envelope as any;

          if (currentUserRef.current) {
            dispatch({
              type: 'SET_CURRENT_USER',
              payload: {
                ...currentUserRef.current!,
                avatarHash: avatarHash || (currentUserRef.current as any).avatarHash,
                avatarVersion: avatarVersion || (currentUserRef.current as any).avatarVersion,
              } as any,
            });
          }
        }

        // ÿ™ÿ≠ÿØŸäÿ´ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÖŸàÿ≠ÿØÿ©
        if (envelope.type === 'userUpdated') {
          const updatedUser: ChatUser | undefined = (envelope as any).user;
          if (updatedUser && updatedUser.id) {
            const isCurrent = currentUserRef.current?.id === updatedUser.id;
            const currentRoom = currentRoomIdRef.current;
            const incomingRoom = (updatedUser as any)?.currentRoom as string | null | undefined;

            // ŸÖŸÜÿπ ÿ≠ŸÇŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿπÿ®ÿ± ÿßŸÑÿ∫ÿ±ŸÅ: ŸÑÿß ÿ™ÿ≠ÿØŸëÿ´ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ∫ÿ±ŸÅÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ© ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑÿ™ÿ≠ÿØŸäÿ´ ŸÑÿ∫ÿ±ŸÅÿ© ÿ£ÿÆÿ±Ÿâ
            if (!isCurrent && currentRoom && incomingRoom && incomingRoom !== currentRoom) {
              // ŸÖÿß Ÿäÿ≤ÿßŸÑ ŸÖÿ≥ŸÖŸàÿ≠ÿßŸã ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ≠ÿßŸÑŸä ŸÅŸÇÿ∑
              // ÿ™ÿ¨ÿßŸáŸÑ ÿ•ÿØÿ±ÿßÿ¨ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÅŸä ŸÇÿßÿ¶ŸÖÿ© Ÿáÿ∞Ÿá ÿßŸÑÿ∫ÿ±ŸÅÿ©
            } else {
              if ((updatedUser as any).isHidden === true) {
                dispatch({ type: 'REMOVE_ONLINE_USER', payload: updatedUser.id });
              } else {
                dispatch({ type: 'UPSERT_ONLINE_USER', payload: updatedUser });
              }
            }

            // ÿØŸÖÿ¨ ŸÅŸàÿ±Ÿä ŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ≠ÿßŸÑŸä
            if (isCurrent && currentUserRef.current) {
              dispatch({
                type: 'SET_CURRENT_USER',
                payload: { ...currentUserRef.current, ...updatedUser } as any,
              });
            }

            // ÿ¨ŸÑÿ® ŸÜÿ≥ÿÆÿ© ŸÉÿßŸÖŸÑÿ© ÿπŸÜÿØ ÿßŸÑÿ≠ÿßÿ¨ÿ© ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ≠ÿßŸÑŸä ŸÅŸÇÿ∑
            if (
              isCurrent &&
              (!updatedUser.profileImage ||
                (typeof updatedUser.profileImage === 'string' &&
                  !updatedUser.profileImage.startsWith('data:')))
            ) {
              try {
                apiRequest(`/api/users/${updatedUser.id}`)
                  .then((full: any) => {
                    if (full && full.id) {
                      setCachedUser(full as ChatUser);
                      if (currentUserRef.current?.id === updatedUser.id) {
                        dispatch({
                          type: 'SET_CURRENT_USER',
                          payload: { ...currentUserRef.current!, ...full } as any,
                        });
                      }
                    }
                  })
                  .catch(() => {});
              } catch {}
            }
          }
        }

        switch (envelope.type) {
          case 'typing': {
            const uid = (envelope as any).userId;
            const isTyping = !!(envelope as any).isTyping;
            const username = (envelope as any).username || (uid ? `User#${uid}` : '');
            if (!uid || uid === currentUserRef.current?.id) break;
            const next = new Set(state.typingUsers);
            if (isTyping) {
              next.add(username);
              // clear previous timer
              const t = typingTimersRef.current.get(uid);
              if (t) {
                clearTimeout(t);
                typingTimersRef.current.delete(uid);
              }
              const timeoutId = window.setTimeout(() => {
                const after = new Set(
                  currentRoomIdRef.current ? Array.from(next) : Array.from(state.typingUsers)
                );
                after.delete(username);
                dispatch({ type: 'SET_TYPING_USERS', payload: after });
                const tmp = typingTimersRef.current.get(uid);
                if (tmp) {
                  clearTimeout(tmp);
                  typingTimersRef.current.delete(uid);
                }
              }, 3000);
              typingTimersRef.current.set(uid, timeoutId);
            } else {
              next.delete(username);
              const t = typingTimersRef.current.get(uid);
              if (t) {
                clearTimeout(t);
                typingTimersRef.current.delete(uid);
              }
            }
            dispatch({ type: 'SET_TYPING_USERS', payload: next });
            break;
          }
          case 'newMessage': {
            const { message } = envelope;
            if (message?.sender && message.content) {
              const roomId = message.roomId || 'general';

              // ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÑÿ™ŸÜÿ≥ŸäŸÇ ChatMessage
              const chatMessage: ChatMessage = {
                id: message.id,
                content: message.content,
                senderId: message.sender.id,
                timestamp: message.timestamp || new Date().toISOString(),
                messageType: message.messageType || 'text',
                sender: message.sender,
                roomId,
                isPrivate: Boolean(message.isPrivate),
                reactions: message.reactions || { like: 0, dislike: 0, heart: 0 },
                myReaction: message.myReaction ?? null,
                attachments: message.attachments || [],
                textColor: message.textColor,
                bold: message.bold,
              };

              // ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÑŸÑÿ∫ÿ±ŸÅÿ© ÿßŸÑŸÖŸÜÿßÿ≥ÿ®ÿ© (ÿπÿßŸÖ ŸÅŸÇÿ∑)
              if (!chatMessage.isPrivate) {
                dispatch({
                  type: 'ADD_ROOM_MESSAGE',
                  payload: { roomId, message: chatMessage },
                });
              }

              // ÿ™ÿ¥ÿ∫ŸäŸÑ ÿµŸàÿ™ ÿÆŸÅŸäŸÅ ŸÅŸÇÿ∑ ÿπŸÜÿØ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿπÿßŸÖÿ© ŸÅŸä ÿßŸÑÿ∫ÿ±ŸÅÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©
              if (
                !chatMessage.isPrivate &&
                chatMessage.senderId !== currentUserRef.current?.id &&
                roomId === currentRoomIdRef.current &&
                (currentUserRef.current as any)?.globalSoundEnabled !== false
              ) {
                playNotificationSound();
              }
            }
            break;
          }
          case 'reactionUpdated': {
            const { roomId, messageId, counts, myReaction, reactorId } = envelope as any;
            const targetRoom = roomId || currentRoomIdRef.current;
            if (!targetRoom || !messageId) break;
            const existing = roomMessagesRef.current[targetRoom] || [];
            const next = existing.map((m) =>
              m.id === messageId
                ? {
                    ...m,
                    reactions: {
                      like: counts?.like ?? m.reactions?.like ?? 0,
                      dislike: counts?.dislike ?? m.reactions?.dislike ?? 0,
                      heart: counts?.heart ?? m.reactions?.heart ?? 0,
                    },
                    myReaction:
                      reactorId && reactorId === currentUserRef.current?.id
                        ? (myReaction ?? null)
                        : (m.myReaction ?? null),
                  }
                : m
            );
            dispatch({
              type: 'SET_ROOM_MESSAGES',
              payload: { roomId: targetRoom, messages: next },
            });
            break;
          }
          case 'messageDeleted': {
            const { messageId, roomId } = envelope as any;
            if (messageId && roomId) {
              const existing = roomMessagesRef.current[roomId] || [];
              const next = existing.filter((m) => m.id !== messageId);
              dispatch({ type: 'SET_ROOM_MESSAGES', payload: { roomId, messages: next } });
            }
            break;
          }

          case 'roomMessages': {
            const { messages, roomId: payloadRoomId } = envelope as any;
            if (Array.isArray(messages)) {
              const roomId = payloadRoomId || currentRoomIdRef.current;
              const formattedMessages = mapDbMessagesToChatMessages(messages, roomId);
              dispatch({
                type: 'SET_ROOM_MESSAGES',
                payload: { roomId, messages: formattedMessages },
              });
            }
            break;
          }

          case 'onlineUsers': {
            const roomId = (envelope as any).roomId || 'general';
            if (roomId !== currentRoomIdRef.current) {
              break;
            }
            if (Array.isArray(envelope.users)) {
              const rawUsers = envelope.users as ChatUser[];
              // ŸÅŸÑÿ™ÿ±ÿ© ÿµÿßÿ±ŸÖÿ© + ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑŸÖÿ™ÿ¨ÿßŸáŸÑŸäŸÜ + ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ™ŸÉÿ±ÿßÿ±ÿßÿ™
              const filtered = rawUsers.filter(
                (u) => u && u.id && u.username && u.userType && !ignoredUsersRef.current.has(u.id)
              );
              const dedup = new Map<number, ChatUser>();
              for (const u of filtered) {
                if (!dedup.has(u.id)) dedup.set(u.id, u);
              }
              const nextUsers = Array.from(dedup.values());
              dispatch({ type: 'SET_ONLINE_USERS', payload: nextUsers });
            }
            break;
          }

          case 'roomJoined': {
            const roomId = (envelope as any).roomId;
            if (roomId && roomId !== currentRoomIdRef.current) {
              // Switch local state to the confirmed room and persist session
              dispatch({ type: 'SET_CURRENT_ROOM', payload: roomId });
              try { saveSession({ roomId }); } catch {}
            }
            // ÿ™ŸÜÿ∏ŸäŸÅ queue ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ: ÿ™ŸÖ ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ
            try {
              if (pendingJoinRoomRef.current === roomId) {
                pendingJoinRoomRef.current = null;
              }
            } catch {}
            // ÿßÿ≥ÿ™ÿ®ÿØÿßŸÑ ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿ®ÿßŸÑŸÉÿßŸÖŸÑ ÿ®ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ∫ÿ±ŸÅÿ© ÿßŸÑŸÖÿ±ÿ≥ŸÑÿ© (ŸÖÿπ ŸÅŸÑÿ™ÿ±ÿ© Ÿàÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ™ŸÉÿ±ÿßÿ±ÿßÿ™)
            const users = (envelope as any).users;
            if (Array.isArray(users)) {
              const rawUsers = users as ChatUser[];
              const filtered = rawUsers.filter(
                (u) => u && u.id && u.username && u.userType && !ignoredUsersRef.current.has(u.id)
              );
              const dedup = new Map<number, ChatUser>();
              for (const u of filtered) {
                if (!dedup.has(u.id)) dedup.set(u.id, u);
              }
              dispatch({ type: 'SET_ONLINE_USERS', payload: Array.from(dedup.values()) });
            }
            break;
          }

          // userJoinedRoom/userLeftRoom ÿ™ŸÖ ÿßÿ≥ÿ™ÿ®ÿØÿßŸÑŸáŸÖÿß ÿ®ÿ±ÿ≥ÿßÿ¶ŸÑ system ŸÖÿ≠ŸÅŸàÿ∏ÿ©
          case 'userDisconnected': {
            const uid = (envelope as any).userId;
            if (uid) {
              dispatch({ type: 'REMOVE_ONLINE_USER', payload: uid });
            }
            break;
          }
          case 'userConnected': {
            const u = (envelope as any).user;
            if (u && u.id) {
              dispatch({ type: 'UPSERT_ONLINE_USER', payload: u });
            }
            break;
          }

          case 'kicked': {
            // ÿ•ÿ∏Ÿáÿßÿ± ÿπÿØŸëÿßÿØ ÿßŸÑÿ∑ÿ±ÿØ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÖÿ≥ÿ™ŸáÿØŸÅ ŸÅŸÇÿ∑
            const targetId = envelope.targetUserId;
            if (targetId && targetId === currentUserRef.current?.id) {
              if (!kickHandledRef.current) {
                kickHandledRef.current = true;
                // ÿπÿ±ÿ∂ ÿßŸÑÿπÿØŸëÿßÿØ Ÿàÿ™ÿπÿ∑ŸäŸÑ ÿßŸÑÿ¨ŸÑÿ≥ÿ© ŸÅŸàÿ±ÿßŸã ÿ®ÿØŸàŸÜ ÿ•ÿπÿßÿØÿ© ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ¢ŸÜ
                dispatch({ type: 'SET_SHOW_KICK_COUNTDOWN', payload: true });
                try { clearSession(); } catch {}
                try { socket.current?.disconnect(); } catch {}
              }
              // ÿ•ÿ¥ÿπÿßÿ± ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÖÿ±ÿ© Ÿàÿßÿ≠ÿØÿ© ŸÅŸÇÿ∑
              const duration = (envelope as any).duration || 15;
              const reason = (envelope as any).reason || 'ÿ®ÿØŸàŸÜ ÿ≥ÿ®ÿ®';
              const moderator = (envelope as any).moderator || 'ŸÖÿ¥ÿ±ŸÅ';
              alert(
                `ÿ™ŸÖ ÿ∑ÿ±ÿØŸÉ ŸÖŸÜ ÿßŸÑÿØÿ±ÿØÿ¥ÿ© ÿ®Ÿàÿßÿ≥ÿ∑ÿ© ${moderator}\nÿßŸÑÿ≥ÿ®ÿ®: ${reason}\nÿßŸÑŸÖÿØÿ©: ${duration} ÿØŸÇŸäŸÇÿ©`
              );
            }
            break;
          }

          case 'blocked': {
            // ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ≠ÿ¨ÿ® ÿßŸÑŸÜŸáÿßÿ¶Ÿä
            if (currentUserRef.current?.id) {
              const reason = (envelope as any).reason || 'ÿ®ÿØŸàŸÜ ÿ≥ÿ®ÿ®';
              const moderator = (envelope as any).moderator || 'ŸÖÿ¥ÿ±ŸÅ';
              alert(`ÿ™ŸÖ ÿ≠ÿ¨ÿ®ŸÉ ŸÜŸáÿßÿ¶ŸäÿßŸã ŸÖŸÜ ÿßŸÑÿØÿ±ÿØÿ¥ÿ© ÿ®Ÿàÿßÿ≥ÿ∑ÿ© ${moderator}\nÿßŸÑÿ≥ÿ®ÿ®: ${reason}`);
              // ŸÅÿµŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ Ÿàÿ•ÿπÿßÿØÿ© ÿ™Ÿàÿ¨ŸäŸáŸá
              setTimeout(() => {
                window.location.href = '/';
              }, 3000);
            }
            break;
          }

          case 'moderationAction': {
            // ŸÅŸä ÿ≠ÿßŸÑÿ© ŸàÿµŸàŸÑ ÿ®ÿ´ ÿπÿßŸÖ ÿ®ÿ•ÿ¨ÿ±ÿßÿ° "banned"ÿå ŸÅÿπŸëŸÑ ÿßŸÑÿπÿØŸëÿßÿØ ÿ•ÿ∞ÿß ŸÉŸÜÿ™ ÿ£ŸÜÿ™ ÿßŸÑŸáÿØŸÅ
            const action = (envelope as any).action;
            const targetId = (envelope as any).targetUserId;
            if (action === 'banned' && targetId && targetId === currentUserRef.current?.id) {
              dispatch({ type: 'SET_SHOW_KICK_COUNTDOWN', payload: true });
            }
            break;
          }

          case 'error':
          case 'warning': {
            console.warn('‚ö†Ô∏è ÿÆÿ∑ÿ£ ŸÖŸÜ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±:', envelope.message);
            
            // ÿπÿ±ÿ∂ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿÆÿ∑ÿ£ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿ™ÿ™ÿπŸÑŸÇ ÿ®ÿ∫ÿ±ŸÅÿ© ŸÖŸÇŸÅŸÑÿ©
            if (envelope.message && (envelope.message.includes('ŸÖŸÇŸÅŸÑÿ©') || envelope.message.includes('locked'))) {
              // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ≠ÿØÿ´ ŸÖÿÆÿµÿµ ŸÑÿπÿ±ÿ∂ ÿ±ÿ≥ÿßŸÑÿ© ÿÆÿ∑ÿ£
              try {
                window.dispatchEvent(new CustomEvent('roomLockError', { 
                  detail: { message: envelope.message }
                }));
              } catch {}
            }
            break;
          }

          // ‚úÖ ÿ®ÿ´Ÿàÿµ ÿßŸÑÿ£ÿµÿØŸÇÿßÿ°: ÿ™ÿ≠ŸàŸäŸÑŸáÿß ÿ•ŸÑŸâ ÿ£ÿ≠ÿØÿßÿ´ ŸÖÿ™ÿµŸÅÿ≠ ŸÑÿ™ŸÅÿπŸäŸÑ ÿ•ÿ®ÿ∑ÿßŸÑ ÿßŸÑŸÉÿßÿ¥ ÿπÿ®ÿ± useNotificationManager
          case 'friendRequestReceived': {
            const targetId = (envelope as any).targetUserId;
            if (targetId && targetId === currentUserRef.current?.id) {
              const detail = {
                senderName: (envelope as any).senderName,
                senderId: (envelope as any).senderId,
              } as any;
              try {
                window.dispatchEvent(new CustomEvent('friendRequestReceived', { detail }));
              } catch {}
            }
            break;
          }
          case 'friendRequestAccepted': {
            const targetId = (envelope as any).targetUserId;
            if (targetId && targetId === currentUserRef.current?.id) {
              const detail = { friendName: (envelope as any).senderName } as any;
              try {
                window.dispatchEvent(new CustomEvent('friendRequestAccepted', { detail }));
              } catch {}
            }
            break;
          }
          case 'friendAdded': {
            const targetId = (envelope as any).targetUserId;
            if (targetId && targetId === currentUserRef.current?.id) {
              const detail = {
                friendId: (envelope as any).friendId,
                friendName: (envelope as any).friendName,
              } as any;
              try {
                window.dispatchEvent(new CustomEvent('friendAdded', { detail }));
              } catch {}
            }
            break;
          }

          default: {
            break;
          }
        }
      } catch (error) {
        console.error('‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿ±ÿ≥ÿßŸÑÿ© Socket:', error);
      }
    });

    // ÿ£ÿ≠ÿØÿßÿ´ ŸÖÿ®ÿßÿ¥ÿ±ÿ© ŸÖÿ≠ÿ™ŸÖŸÑÿ© ŸÑÿ™ÿ≠ÿØŸäÿ´ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ™ÿµŸÑŸäŸÜ ŸÅŸàÿ±ÿßŸã ÿ•ŸÜ ŸàŸèÿ¨ÿØÿ™ ÿπŸÑŸâ ÿßŸÑÿÆÿßÿØŸÖ
    socketInstance.on('userDisconnected', (payload: any) => {
      const uid = payload?.userId || payload?.id;
      if (uid) {
        dispatch({ type: 'REMOVE_ONLINE_USER', payload: uid });
      }
    });
    socketInstance.on('userConnected', (payload: any) => {
      const user = payload?.user || payload;
      if (user?.id) {
        dispatch({ type: 'UPSERT_ONLINE_USER', payload: user });
      }
    });

    // ÿ®ÿ´ ÿ™ÿ≠ÿØŸäÿ´ÿßÿ™ ÿ∫ÿ±ŸÅÿ© ÿßŸÑÿ®ÿ´ Ÿàÿ£ÿ≠ÿØÿßÿ´ ÿßŸÑŸÖÿßŸäŸÉ ÿπÿ®ÿ± ŸÇŸÜŸàÿßÿ™ Socket ÿßŸÑŸÖÿÆÿµÿµÿ©
    const emitToBroadcastHandlers = (payload: any) => {
      broadcastHandlers.current.forEach((handler) => {
        try {
          handler(payload);
        } catch (err) {
          /* ignore single handler error */
        }
      });
    };

    socketInstance.on('roomUpdate', (message: any) => {
      emitToBroadcastHandlers(message);
    });

    // Handle chat lock updates
    socketInstance.on('chatLockUpdated', (message: any) => {
      emitToBroadcastHandlers({ type: 'chatLockUpdated', ...message });
    });

    // ÿ™ŸàÿßŸÅŸÇ ŸÖÿπ REST endpoints ÿßŸÑÿ™Ÿä ÿ™ÿ®ÿ´ ÿ£ÿ≠ÿØÿßÿ´ ÿßŸÑŸÖÿßŸäŸÉ ŸÉÿ£ÿ≠ÿØÿßÿ´ ŸÖÿ≥ÿ™ŸÇŸÑÿ©
    socketInstance.on('micRequested', (message: any) => {
      emitToBroadcastHandlers({ type: 'micRequest', ...message });
    });
    socketInstance.on('micApproved', (message: any) => {
      emitToBroadcastHandlers({ type: 'micApproved', ...message });
    });
    socketInstance.on('micRejected', (message: any) => {
      emitToBroadcastHandlers({ type: 'micRejected', ...message });
    });
    socketInstance.on('speakerRemoved', (message: any) => {
      emitToBroadcastHandlers({ type: 'speakerRemoved', ...message });
    });

    // WebRTC signaling relays
    socketInstance.on('webrtc-offer', (payload: any) => {
      webrtcOfferHandlers.current.forEach((h) => {
        try {
          h(payload);
        } catch (e) {
          console.warn('webrtc offer handler error', e);
        }
      });
    });
    socketInstance.on('webrtc-answer', (payload: any) => {
      webrtcAnswerHandlers.current.forEach((h) => {
        try {
          h(payload);
        } catch (e) {
          console.warn('webrtc answer handler error', e);
        }
      });
    });
    socketInstance.on('webrtc-ice-candidate', (payload: any) => {
      webrtcIceHandlers.current.forEach((h) => {
        try {
          h(payload);
        } catch (e) {
          console.warn('webrtc ice handler error', e);
        }
      });
    });

    // ŸÖÿπÿßŸÑÿ¨ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿÆÿßÿµÿ© ÿßŸÑŸÖÿ≠ÿ≥ŸÜ
    const handlePrivateMessage = (incoming: any) => {
      try {
        const envelope = incoming?.envelope ? incoming.envelope : incoming;
        const payload = envelope?.message ?? envelope;
        const message = payload?.message ?? payload;

        if (message?.sender && currentUserRef.current) {
          const chatMessage: ChatMessage = {
            id: message.id,
            content: message.content,
            senderId: message.sender.id,
            timestamp: message.timestamp || new Date().toISOString(),
            messageType: message.messageType || 'text',
            sender: message.sender,
            receiverId: message.receiverId,
            isPrivate: true,
            attachments: message.attachments || [],
          };

          // ÿ™ÿ¨ÿßŸáŸÑ ÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ≠ÿßŸÑÿßÿ™ ŸÅŸä ŸÖÿ≠ÿßÿØÿ´ÿßÿ™ ÿßŸÑÿ∑ÿ±ŸÅŸäŸÜ ÿ•ÿ∞ÿß ÿ£ÿ±ÿØŸÜÿß ŸÅÿµŸÑŸáÿß ŸÑÿßÿ≠ŸÇÿßŸã (ÿ≥ŸÜÿ®ŸÇŸäŸáÿß ÿßŸÑÿ¢ŸÜ ŸàŸÑŸÉŸÜ ŸÜÿ∂ÿπ ÿπŸÑÿßŸÖÿ©)
          const isStoryChannel = Array.isArray(chatMessage.attachments) && chatMessage.attachments.some((a: any) => a?.channel === 'story');

          // ÿ™ÿ≠ÿØŸäÿØ ŸÖÿπÿ±ŸÅ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ© ÿ®ÿ¥ŸÉŸÑ ŸÖÿ≠ÿ≥ŸÜ
          let conversationId: number;
          if (message.senderId === currentUserRef.current.id) {
            conversationId = message.receiverId;
          } else {
            conversationId = message.senderId;
          }

          // ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿµÿ≠ÿ© ŸÖÿπÿ±ŸÅ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
          if (
            conversationId &&
            !isNaN(conversationId) &&
            conversationId !== currentUserRef.current.id
          ) {
            dispatch({
              type: 'SET_PRIVATE_MESSAGE',
              payload: { userId: conversationId, message: chatMessage },
            });

            // ÿ™ÿ¥ÿ∫ŸäŸÑ ÿµŸàÿ™ ÿßŸÑÿ•ÿ¥ÿπÿßÿ± ŸÅŸÇÿ∑ ŸÑŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸàÿßÿ±ÿØÿ©
            if (chatMessage.senderId !== currentUserRef.current.id) {
              if ((currentUserRef.current as any)?.globalSoundEnabled !== false) {
                playNotificationSound();
              }
              // ÿπÿ±ÿ∂ ÿ™ŸÜÿ®ŸäŸá ŸÖÿ±ÿ¶Ÿä ŸÑŸÑŸÖŸèÿ±ÿ≥ŸÑ
              try {
                dispatch({ type: 'SET_NEW_MESSAGE_SENDER', payload: message.sender as any });
              } catch {}
            }

            // ÿ•ÿ¥ÿπÿßÿ± ÿßŸÑŸàÿßÿ¨Ÿáÿ© ÿ®ŸàÿµŸàŸÑ/ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ÿ≥ÿßŸÑÿ© ÿÆÿßÿµÿ© ŸÑÿ™ÿ≠ÿØŸäÿ´ ÿ™ÿ®ŸàŸäÿ® ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ŸÅŸàÿ±ÿßŸã
            try {
              const detail = {
                otherUserId: conversationId,
                senderId: message.senderId,
                receiverId: message.receiverId,
                storyChannel: isStoryChannel,
              } as any;
              window.dispatchEvent(new CustomEvent('privateMessageReceived', { detail }));
            } catch {}
          }
        }
      } catch (error) {
        console.error('‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿÆÿßÿµÿ©:', error);
      }
    };

    socketInstance.on('privateMessage', handlePrivateMessage);

    // ŸÖÿπÿßŸÑÿ¨ ÿ≠ÿØÿ´ ÿßŸÑÿ∑ÿ±ÿØ (ŸÜÿ≥ÿÆÿ© ŸÖÿ®ÿ≥ÿ∑ÿ© ÿ®ÿØŸàŸÜ ÿ•ÿπÿßÿØÿ© ÿ™Ÿàÿ¨ŸäŸá ŸÅŸàÿ±Ÿä)
    socketInstance.on('kicked', (data: any) => {
      if (currentUserRef.current?.id === data.userId) {
        if (!kickHandledRef.current) {
          kickHandledRef.current = true;
          const kickerName = data.kickerName || 'ŸÖÿ¥ÿ±ŸÅ';
          const reason = data.reason || 'ÿ®ÿØŸàŸÜ ÿ≥ÿ®ÿ®';
          alert(
            `ÿ™ŸÖ ÿ∑ÿ±ÿØŸÉ ŸÖŸÜ ÿßŸÑÿØÿ±ÿØÿ¥ÿ© ÿ®Ÿàÿßÿ≥ÿ∑ÿ© ${kickerName}\nÿßŸÑÿ≥ÿ®ÿ®: ${reason}\nŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿπŸàÿØÿ© ÿ®ÿπÿØ 15 ÿØŸÇŸäŸÇÿ©`
          );
          dispatch({ type: 'SET_SHOW_KICK_COUNTDOWN', payload: true });
          try { clearSession(); } catch {}
          try { socketInstance.disconnect(); } catch {}
        }
      }
    });

    // ŸÖÿπÿßŸÑÿ¨ ÿ≠ÿØÿ´ ÿßŸÑÿ≠ÿ¨ÿ®
    socketInstance.on('blocked', (data: any) => {
      if (currentUserRef.current?.id) {
        const reason = data.reason || 'ÿ®ÿØŸàŸÜ ÿ≥ÿ®ÿ®';
        const moderator = data.moderator || 'ŸÖÿ¥ÿ±ŸÅ';

        // ÿ•ÿ∏Ÿáÿßÿ± ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ≠ÿ¨ÿ®
        alert(`ÿ™ŸÖ ÿ≠ÿ¨ÿ®ŸÉ ŸÜŸáÿßÿ¶ŸäÿßŸã ŸÖŸÜ ÿßŸÑÿØÿ±ÿØÿ¥ÿ© ÿ®Ÿàÿßÿ≥ÿ∑ÿ© ${moderator}\nÿßŸÑÿ≥ÿ®ÿ®: ${reason}`);

        // ŸÅÿµŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÅŸàÿ±ÿßŸã Ÿàÿ•ÿπÿßÿØÿ© ÿ™Ÿàÿ¨ŸäŸáŸá
        clearSession(); // ŸÖÿ≥ÿ≠ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ¨ŸÑÿ≥ÿ©
        socketInstance.disconnect();
        setTimeout(() => {
          window.location.href = '/';
        }, 1000);
      }
    });

    // ŸÖÿπÿßŸÑÿ¨ ÿ£ÿÆÿ∑ÿßÿ° ÿßŸÑŸÖÿµÿßÿØŸÇÿ©
    socketInstance.on('error', (data: any) => {
      if (data.action === 'blocked' || data.action === 'device_blocked') {
        alert(data.message);
        clearSession(); // ŸÖÿ≥ÿ≠ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ¨ŸÑÿ≥ÿ©
        socketInstance.disconnect();
        setTimeout(() => {
          window.location.href = '/';
        }, 1000);
      } else if (data.action === 'banned') {
        const timeLeft = data.timeLeft || 0;
        alert(`${data.message}\nÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÖÿ™ÿ®ŸÇŸä: ${timeLeft} ÿØŸÇŸäŸÇÿ©`);
        dispatch({ type: 'SET_SHOW_KICK_COUNTDOWN', payload: true });
      } else {
        console.error('ÿÆÿ∑ÿ£ ŸÖŸÜ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±:', data.message);
      }
    });
  }, []);

  // Ensure cleanup on unmount
  useEffect(() => {
    return () => {
      if (pingIntervalRef.current) {
        clearInterval(pingIntervalRef.current);
        pingIntervalRef.current = null;
      }
      if (backgroundPingIntervalRef.current) {
        clearInterval(backgroundPingIntervalRef.current);
        backgroundPingIntervalRef.current = null;
      }
      // ÿ™ŸÜÿ∏ŸäŸÅ Web Worker Ÿà Service Worker
      if (socketWorkerRef.current) {
        socketWorkerRef.current.postMessage({ type: 'cleanup' });
        socketWorkerRef.current.terminate();
        socketWorkerRef.current = null;
      }
      
      if (serviceWorkerRef.current) {
        serviceWorkerRef.current.postMessage({
          type: 'stop-background-ping',
          data: {}
        });
        serviceWorkerRef.current = null;
      }
      // clear typing timers
      typingTimersRef.current.forEach((id) => {
        try {
          clearTimeout(id);
        } catch {}
      });
      typingTimersRef.current.clear();
    };
  }, []);

  useEffect(() => {
    const handleOnline = () => {
      if (socket.current && !socket.current.connected) {
        try {
          socket.current.connect();
        } catch {}
      }
    };
    const handleOffline = () => {
      dispatch({ type: 'SET_CONNECTION_STATUS', payload: false });
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  useEffect(() => {
    // ÿπŸÜÿØ ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ≠ÿßŸÑŸäÿå ÿßÿ¨ŸÑÿ® ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ™ÿ¨ÿßŸáŸÑŸäŸÜ ÿßŸÑÿÆÿßÿµÿ© ÿ®Ÿá ŸÖÿ±ÿ© Ÿàÿßÿ≠ÿØÿ©
    const fetchIgnored = async () => {
      if (!state.currentUser?.id) return;
      try {
        const data = await apiRequest(`/api/users/${state.currentUser.id}/ignored`);
        const ids: number[] = Array.isArray(data)
          ? data
          : Array.isArray((data as any)?.ignoredUsers)
            ? (data as any).ignoredUsers
            : [];
        ids.forEach((id) => dispatch({ type: 'IGNORE_USER', payload: id }));
      } catch (e) {
        console.warn('ÿ™ÿπÿ∞ÿ± ÿ¨ŸÑÿ® ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ™ÿ¨ÿßŸáŸÑŸäŸÜ:', e);
      }
    };
    fetchIgnored();
  }, [state.currentUser?.id]);

  // Prefetch recent private conversations messages on first entry
  const prefetchedConversationsRef = useRef(false);
  useEffect(() => {
    const PREFETCH_CONVERSATIONS_MAX = 20; // ŸÇÿßÿ®ŸÑ ŸÑŸÑÿ™ÿπÿØŸäŸÑ
    const prefetch = async () => {
      if (!state.currentUser?.id || prefetchedConversationsRef.current) return;
      prefetchedConversationsRef.current = true;
      try {
        const conv = await apiRequest(
          `/api/private-messages/conversations/${state.currentUser.id}?limit=50`
        );
        const items: Array<{ otherUserId: number }> = Array.isArray((conv as any)?.conversations)
          ? (conv as any).conversations
          : [];
        const targets = items.map((i) => i.otherUserId).slice(0, PREFETCH_CONVERSATIONS_MAX);
        await Promise.all(
          targets.map(async (otherId) => {
            try {
              const data = await apiRequest(
                `/api/private-messages/${state.currentUser!.id}/${otherId}?limit=20`
              );
              const formatted = Array.isArray((data as any)?.messages)
                ? mapDbMessagesToChatMessages((data as any).messages)
                : [];
              if (formatted.length > 0) {
                dispatch({
                  type: 'SET_PRIVATE_CONVERSATION',
                  payload: { userId: otherId, messages: formatted },
                });
              }
            } catch {}
          })
        );
      } catch (e) {
        console.warn('ÿ™ÿπÿ∞ÿ± ÿßŸÑÿ¨ŸÑÿ® ÿßŸÑŸÖÿ≥ÿ®ŸÇ ŸÑŸÖÿ≠ÿßÿØÿ´ÿßÿ™ ÿßŸÑÿÆÿßÿµ:', e);
      }
    };
    prefetch();
  }, [state.currentUser?.id]);

  // üî• SIMPLIFIED Connect function
  const connect = useCallback(
    (user: ChatUser) => {
      dispatch({ type: 'SET_CURRENT_USER', payload: user });
      dispatch({ type: 'SET_LOADING', payload: true });

      try {
        // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿßŸÑÿ≥ÿßÿ®ŸÇ
        if (socket.current) {
          socket.current.removeAllListeners();
          socket.current.disconnect();
          socket.current = null;
          if (pingIntervalRef.current) {
            clearInterval(pingIntervalRef.current);
            pingIntervalRef.current = null;
          }
        }
        
        // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿπŸÖŸäŸÑ Socket ÿßŸÑŸÖŸàÿ≠ÿØ
        const s = connectSocket();
        socket.current = s;
        
        // ÿ≠ŸÅÿ∏ ÿßŸÑÿ¨ŸÑÿ≥ÿ©
        saveSession({ userId: user.id, username: user.username, userType: user.userType });

        // ÿ•ÿπÿØÿßÿØ ÿßŸÑŸÖÿ≥ÿ™ŸÖÿπŸäŸÜ
        setupSocketListeners(s);

        // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÖÿ™ÿµŸÑÿßŸã ÿ®ÿßŸÑŸÅÿπŸÑÿå ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑŸÖÿµÿßÿØŸÇÿ© ŸÅŸÇÿ∑ÿå ŸàÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿ≥Ÿäÿ™ŸÖ ÿ®ÿπÿØ ÿßŸÑÿ™ÿ£ŸÉŸäÿØ
        if (s.connected) {
          s.emit('auth', {
            userId: user.id,
            username: user.username,
            userType: user.userType,
          });
        }

        // ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÖÿµÿßÿØŸÇÿ© ÿπŸÜÿØ ÿßŸÑÿßÿ™ÿµÿßŸÑ/ÿ•ÿπÿßÿØÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ Ÿäÿ™ŸÖ ŸÖŸÜ ÿÆŸÑÿßŸÑ ÿßŸÑŸàÿ≠ÿØÿ© ÿßŸÑŸÖÿ¥ÿ™ÿ±ŸÉÿ©
        s.on('connect', () => {
          dispatch({ type: 'SET_CONNECTION_STATUS', payload: true });
          dispatch({ type: 'SET_CONNECTION_ERROR', payload: null });
          dispatch({ type: 'SET_LOADING', payload: false });

          // ÿ•ÿπÿßÿØÿ© ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÖÿµÿßÿØŸÇÿ© ŸÅŸÇÿ∑ÿå ŸàÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÑŸÑÿ∫ÿ±ŸÅÿ© ÿ®ÿπÿØ Event roomJoined
          try {
            s.emit('auth', {
              userId: user.id,
              username: user.username,
              userType: user.userType,
            });
          } catch {}

          // Prefetch expected data shortly after connection success
          try {
            // ÿ∫ŸèÿµŸÜ ÿÆŸÅŸäŸÅ ŸÑÿ™ŸÅÿßÿØŸä ÿ•ÿ≤ÿπÿßÿ¨ ÿßŸÑÿ¥ÿ®ŸÉÿ© ŸÅŸàÿ±ÿßŸã
            setTimeout(() => {
              try {
                // Prefetch rooms list
                queryClient.prefetchQuery({
                  queryKey: ['/api/rooms', user.id],
                  queryFn: async () => apiRequest('/api/rooms'),
                  staleTime: 60_000,
                });
                // Prefetch notifications count
                queryClient.prefetchQuery({
                  queryKey: ['/api/notifications/unread-count', user.id],
                  queryFn: async () => apiRequest(`/api/notifications/${user.id}/unread-count`),
                  staleTime: 60_000,
                });
                // Prefetch friends list (if endpoint supported)
                queryClient.prefetchQuery({
                  queryKey: ['/api/friends', user.id],
                  queryFn: async () => apiRequest(`/api/friends/${user.id}`),
                  staleTime: 60_000,
                });
              } catch {}
            }, 300);
          } catch {}
        });

        // ŸÖÿπÿßŸÑÿ¨ ŸÅÿ¥ŸÑ ÿ•ÿπÿßÿØÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿßŸÑŸÜŸáÿßÿ¶Ÿä
        s.on('reconnect_failed', () => {
          console.warn('‚ö†Ô∏è ŸÅÿ¥ŸÑ ŸÅŸä ÿ•ÿπÿßÿØÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿπÿØ ÿπÿØÿ© ŸÖÿ≠ÿßŸàŸÑÿßÿ™');
          dispatch({
            type: 'SET_CONNECTION_ERROR',
            payload: 'ŸÅŸÇÿØÿßŸÜ ÿßŸÑÿßÿ™ÿµÿßŸÑ. Ÿäÿ±ÿ¨Ÿâ ÿ•ÿπÿßÿØÿ© ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸÅÿ≠ÿ©.',
          });
        });

        // ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿßŸÑÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿπŸÜÿØ ÿßŸÑÿßŸÜŸÅÿµÿßŸÑ
        s.on('disconnect', () => {
          dispatch({ type: 'SET_CONNECTION_STATUS', payload: false });
        });

        // ŸÖÿπÿßŸÑÿ¨ÿ© ÿ£ÿÆÿ∑ÿßÿ° ÿßŸÑÿßÿ™ÿµÿßŸÑ
        s.on('connect_error', (error) => {
          console.error('‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ:', error);
          dispatch({ type: 'SET_CONNECTION_ERROR', payload: 'ŸÅÿ¥ŸÑ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±' });
        });
      } catch (error) {
        console.error('ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ:', error);
        dispatch({ type: 'SET_CONNECTION_ERROR', payload: 'ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿßŸÑÿÆÿßÿØŸÖ' });
        dispatch({ type: 'SET_LOADING', payload: false });
      }
    },
    [setupSocketListeners, state.currentRoomId]
  );

  // üî• SIMPLIFIED Join room function
  const joinRoom = useCallback(
    (roomId: string) => {
      if (!roomId || roomId === 'public' || roomId === 'friends') {
        console.warn('Invalid room ID provided to joinRoom:', roomId);
        return;
      }
      // ÿ≠ÿßÿ±ÿ≥ ŸÑŸÖŸÜÿπ ÿßŸÑÿ™ŸÉÿ±ÿßÿ±: ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ŸÜŸÅÿ≥ ÿßŸÑÿ∫ÿ±ŸÅÿ© ŸÖÿ≠ŸÑŸäÿßŸã ÿ£Ÿà ŸÉÿßŸÜÿ™ ŸÅŸä ŸÇÿßÿ¶ŸÖÿ© ÿßŸÜÿ™ÿ∏ÿßÿ± ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖÿå ŸÑÿß ÿ™ÿπŸäÿØ ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑ
      if (state.currentRoomId === roomId || pendingJoinRoomRef.current === roomId) {
        return;
      }

      // Do NOT change local room yet; wait for server ack (roomJoined)
      if (socket.current?.connected && state.currentUser?.id) {
        const now = Date.now();
        if (now - lastJoinEmitTsRef.current < 1000) {
          return;
        }
        lastJoinEmitTsRef.current = now;
        socket.current.emit('joinRoom', {
          roomId,
          userId: state.currentUser.id,
          username: state.currentUser.username,
        });
        // ÿ™ŸÖŸäŸäÿ≤ ÿ£ŸÜ ŸÑÿØŸäŸÜÿß ÿ∑ŸÑÿ® ÿßŸÜÿ∂ŸÖÿßŸÖ ÿ¨ÿßÿ±Ÿç ŸÑÿ™ŸÅÿßÿØŸä ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑ ŸÖŸÜ ŸÖÿ≥ÿßÿ±ÿßÿ™ ÿ£ÿÆÿ±Ÿâ
        pendingJoinRoomRef.current = roomId;
        // ŸÑÿß ŸÜÿ≠ÿØÿ´ lastSeen ŸÖÿ≠ŸÑŸäÿßŸã ÿ•ÿ∑ŸÑÿßŸÇÿßŸãÿõ ÿßŸÑÿßÿπÿ™ŸÖÿßÿØ ÿπŸÑŸâ ÿ®ÿ´ ÿßŸÑÿÆÿßÿØŸÖ ŸÅŸÇÿ∑
        try { saveSession({ roomId }); } catch {}
      } else {
        // Queue join until we reconnect
        pendingJoinRoomRef.current = roomId;
        // ŸÑÿß ÿ™ÿ≠ÿØŸäÿ´ÿßÿ™ ŸÖÿ≠ŸÑŸäÿ© ŸÑŸÑÿ≠ÿßŸÑÿ© ÿßŸÑÿ≤ŸÖŸÜŸäÿ©ÿõ ŸÅŸÇÿ∑ ÿ≠ŸÅÿ∏ ÿßŸÑÿ¨ŸÑÿ≥ÿ© ŸÑÿ•ÿπÿßÿØÿ© ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ
        try { saveSession({ roomId }); } catch {}
      }
    },
    [state.currentRoomId, state.currentUser]
  );

  // ŸÑÿß ŸÜŸÇŸàŸÖ ÿ®ÿ™ŸàŸÑŸäÿØ lastSeen ŸÖÿ≠ŸÑŸäÿßŸã. ÿßŸÑÿÆÿßÿØŸÖ ŸáŸà ÿßŸÑŸÖÿµÿØÿ± ÿßŸÑŸàÿ≠ŸäÿØ ŸÑŸÑÿ≠ŸÇŸäŸÇÿ©.

  // üî• SIMPLIFIED Send message function
  const sendMessage = useCallback(
    (
      content: string,
      messageType: string = 'text',
      receiverId?: number,
      roomId?: string,
      textColor?: string,
      bold?: boolean
    ): Promise<boolean> | void => {
      if (!state.currentUser) {
        console.error('‚ùå ŸÑÿß ŸäŸÖŸÉŸÜ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© - ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ≠ÿßŸÑŸä');
        return;
      }

      const trimmed = typeof content === 'string' ? content.trim() : '';
      if (!trimmed) {
        console.warn('‚ö†Ô∏è ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÅÿßÿ±ÿ∫');
        return;
      }

      // ÿßŸÉÿ™ÿ¥ÿßŸÅ ÿßŸÑÿµŸàÿ± ÿßŸÑŸÖÿ±ÿ≥ŸÑÿ© ŸÉŸÄ base64
      const detectedType =
        messageType === 'text' && trimmed.startsWith('data:image') ? 'image' : messageType;

      if (receiverId) {
        // ÿ•ÿ±ÿ≥ÿßŸÑ ÿÆÿßÿµ ÿπÿ®ÿ± REST ŸÖÿπ ÿ•ÿ±ÿ¨ÿßÿπ Promise ŸàÿßŸïÿ∂ÿßŸÅÿ© ÿ™ŸÅÿßÿ§ŸÑŸäÿ© ŸÑŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
        const endpoint = `/api/private-messages/send`;
        return apiRequest(endpoint, {
          method: 'POST',
          body: {
            senderId: state.currentUser.id,
            receiverId,
            content: trimmed,
            messageType: detectedType || 'text',
            textColor,
            bold,
          },
        })
          .then((res: any) => {
            const sender = state.currentUser as ChatUser;
            const apiMsg = (res && (res as any).message) || null;
            const chatMessage: ChatMessage = {
              id: apiMsg?.id ?? Date.now(),
              content: trimmed,
              senderId: sender.id,
              timestamp: (apiMsg?.timestamp as string) || new Date().toISOString(),
              messageType: detectedType || 'text',
              sender: apiMsg?.sender || sender,
              receiverId,
              isPrivate: true,
              attachments: apiMsg?.attachments || [],
            } as any;
            // ÿ•ÿ∂ÿßŸÅÿ© ÿ™ŸÅÿßÿ§ŸÑŸäÿ© ŸÑŸÑŸÖÿ≠ÿßÿØÿ´ÿ© ÿ≠ÿ™Ÿâ ŸäÿµŸÑ ÿ®ÿ´ ÿßŸÑÿÆÿßÿØŸÖ
            dispatch({ type: 'SET_PRIVATE_MESSAGE', payload: { userId: receiverId, message: chatMessage } });
            return true;
          });
      }

      // ÿ•ÿ±ÿ≥ÿßŸÑ ÿπÿßŸÖ ÿπÿ®ÿ± Socket.IO ‚Äî Ÿäÿ™ÿ∑ŸÑÿ® ÿßÿ™ÿµÿßŸÑÿßŸã ŸàÿßŸÜÿ∂ŸÖÿßŸÖÿßŸã ŸÑŸÑÿ∫ÿ±ŸÅÿ©
      if (!socket.current?.connected) {
        console.error('‚ùå ŸÑÿß ŸäŸÖŸÉŸÜ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿπÿßŸÖÿ© - ÿ∫Ÿäÿ± ŸÖÿ™ÿµŸÑ');
        return;
      }
      const targetRoomId = roomId || state.currentRoomId || 'general';
      socket.current.emit('publicMessage', {
        senderId: state.currentUser.id,
        content: trimmed,
        messageType: detectedType,
        isPrivate: false,
        receiverId: undefined,
        roomId: targetRoomId,
        textColor,
        bold,
      });
    },
    [state.currentUser, state.currentRoomId, dispatch]
  );

  // üî• SIMPLIFIED Send room message function
  const sendRoomMessage = useCallback(
    (content: string, roomId: string, messageType: string = 'text') => {
      return sendMessage(content, messageType, undefined, roomId);
    },
    [sendMessage]
  );

  // üî• SIMPLIFIED Disconnect function
  const disconnect = useCallback(() => {
    clearSession(); // ŸÖÿ≥ÿ≠ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ¨ŸÑÿ≥ÿ©
    if (socket.current) {
      socket.current.removeAllListeners();
      socket.current.disconnect();
      socket.current = null;
      if (pingIntervalRef.current) {
        clearInterval(pingIntervalRef.current);
        pingIntervalRef.current = null;
      }
    }

    // ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿßŸÑÿ≠ÿßŸÑÿ©
    dispatch({ type: 'CLEAR_ALL', payload: undefined });
  }, []);

  // üî• SIMPLIFIED helper functions
  const ignoreUser = useCallback(
    async (userId: number) => {
      try {
        if (!state.currentUser?.id) return;
        await apiRequest(`/api/users/${state.currentUser.id}/ignore/${userId}`, { method: 'POST' });
        dispatch({ type: 'IGNORE_USER', payload: userId });
      } catch (e) {
        console.error('ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ:', e);
      }
    },
    [state.currentUser?.id]
  );

  const unignoreUser = useCallback(
    async (userId: number) => {
      try {
        if (!state.currentUser?.id) return;
        await apiRequest(`/api/users/${state.currentUser.id}/ignore/${userId}`, {
          method: 'DELETE',
        });
        dispatch({ type: 'UNIGNORE_USER', payload: userId });
      } catch (e) {
        console.error('ŸÅÿ¥ŸÑ ŸÅŸä ÿ•ŸÑÿ∫ÿßÿ° ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ:', e);
      }
    },
    [state.currentUser?.id]
  );

  const sendTyping = useCallback(() => {
    // ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ŸÖÿ§ÿ¥ÿ± ÿßŸÑŸÉÿ™ÿßÿ®ÿ© ŸÅŸä ÿßŸÑÿ∫ÿ±ŸÅ ÿßŸÑÿπÿßŸÖÿ©
  }, []);

  // ÿ•ÿ±ÿ≥ÿßŸÑ ŸÖÿ§ÿ¥ÿ± ŸÉÿ™ÿßÿ®ÿ© ŸÑŸÑÿÆÿßÿµ (DM)
  const sendPrivateTyping = useCallback((targetUserId: number) => {
    try {
      if (!targetUserId || !socket.current?.connected) return;
      socket.current.emit('privateTyping', { targetUserId, isTyping: true });
    } catch {}
  }, []);

  // Compatibility helpers for UI components
  const handleTyping = useCallback(() => {
    sendTyping();
  }, [sendTyping]);

  const getCurrentRoomMessages = useCallback(() => currentRoomMessages, [currentRoomMessages]);

  const updateCurrentUser = useCallback(
    (updates: Partial<ChatUser>) => {
      if (!state.currentUser) return;
      const merged = { ...state.currentUser, ...updates } as ChatUser;
      dispatch({ type: 'SET_CURRENT_USER', payload: merged });
    },
    [state.currentUser]
  );

  // ÿ™ÿ≠ŸÖŸäŸÑ ÿ≥ÿ¨ŸÑ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ© ÿßŸÑÿÆÿßÿµÿ© ÿπŸÜÿØ ŸÅÿ™ÿ≠Ÿáÿß
  const loadPrivateConversation = useCallback(
    async (otherUserId: number, limit: number = 50) => {
      if (!state.currentUser?.id) return;
      try {
        const data = await apiRequest(
          `/api/private-messages/${state.currentUser.id}/${otherUserId}?limit=${limit}`
        );
        const formatted = Array.isArray((data as any)?.messages)
          ? mapDbMessagesToChatMessages((data as any).messages)
          : [];
        dispatch({
          type: 'SET_PRIVATE_CONVERSATION',
          payload: { userId: otherUserId, messages: formatted },
        });
      } catch (error) {
        console.error('‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿÆÿßÿµ:', error);
      }
    },
    [state.currentUser?.id]
  );

  const loadOlderPrivateConversation = useCallback(
    async (otherUserId: number, limit: number = 20) => {
      if (!state.currentUser?.id) return { addedCount: 0, hasMore: false };
      try {
        const existing = state.privateConversations[otherUserId] || [];
        const earliestTs =
          existing.length > 0 ? new Date(existing[0].timestamp).toISOString() : undefined;
        const url = `/api/private-messages/${state.currentUser.id}/${otherUserId}?limit=${limit}${
          earliestTs ? `&beforeTs=${encodeURIComponent(earliestTs)}` : ''
        }`;
        const data = await apiRequest(url);
        const formatted = Array.isArray((data as any)?.messages)
          ? mapDbMessagesToChatMessages((data as any).messages)
          : [];
        if (formatted.length > 0) {
          dispatch({
            type: 'PREPEND_PRIVATE_MESSAGES',
            payload: { userId: otherUserId, messages: formatted },
          });
        }
        const hasMore = !!(data as any)?.hasMore;
        return { addedCount: formatted.length, hasMore };
      } catch (error) {
        console.error('‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿ±ÿ≥ÿßÿ¶ŸÑ ÿ£ŸÇÿØŸÖ ŸÑŸÑÿÆÿßÿµ:', error);
        return { addedCount: 0, hasMore: false };
      }
    },
    [state.currentUser?.id, state.privateConversations]
  );

  return {
    // State
    currentUser: state.currentUser,
    onlineUsers: memoizedOnlineUsers,
    publicMessages: currentRoomMessages, // ‚úÖ ŸÖÿµÿØÿ± Ÿàÿßÿ≠ÿØ ŸÑŸÑÿ≠ŸÇŸäŸÇÿ©
    privateConversations: state.privateConversations,
    ignoredUsers: state.ignoredUsers,
    isConnected: state.isConnected,
    typingUsers: state.typingUsers,
    connectionError: state.connectionError,
    newMessageSender: state.newMessageSender,
    isLoading: state.isLoading,
    notifications: state.notifications,
    currentRoomId: state.currentRoomId,
    roomMessages: state.roomMessages,
    showKickCountdown: state.showKickCountdown,

    // Notification states
    levelUpNotification,
    setLevelUpNotification,
    achievementNotification,
    setAchievementNotification,
    dailyBonusNotification,
    setDailyBonusNotification,

    // ‚úÖ Actions - ŸÖÿ®ÿ≥ÿ∑ÿ© ŸàŸàÿßÿ∂ÿ≠ÿ©
    connect,
    disconnect,
    sendMessage,
    sendRoomMessage,
    joinRoom,
    loadRoomMessages,
    ignoreUser,
    unignoreUser,
    sendTyping,
    setShowKickCountdown: (show: boolean) =>
      dispatch({ type: 'SET_SHOW_KICK_COUNTDOWN', payload: show }),
    setNewMessageSender: (sender: ChatUser | null) =>
      dispatch({ type: 'SET_NEW_MESSAGE_SENDER', payload: sender }),

    // Convenience wrappers
    sendPublicMessage: (content: string) => sendMessage(content, 'text'),

    // Newly added helpers for compatibility
    handleTyping,
    sendPrivateTyping,
    getCurrentRoomMessages,
    updateCurrentUser,
    loadPrivateConversation,
    loadOlderPrivateConversation,

    // Broadcast handlers registration
    addBroadcastMessageHandler: (handler: (data: any) => void) => {
      broadcastHandlers.current.add(handler);
    },
    removeBroadcastMessageHandler: (handler: (data: any) => void) => {
      broadcastHandlers.current.delete(handler);
    },

    // WebRTC signaling helpers
    sendWebRTCOffer: (targetUserId: number, roomId: string, sdp: any) => {
      if (!socket.current?.connected || !state.currentUser) return;
      socket.current.emit('webrtc-offer', {
        roomId,
        targetUserId,
        sdp,
        senderId: state.currentUser.id,
      });
    },
    sendWebRTCAnswer: (targetUserId: number, roomId: string, sdp: any) => {
      if (!socket.current?.connected || !state.currentUser) return;
      socket.current.emit('webrtc-answer', {
        roomId,
        targetUserId,
        sdp,
        senderId: state.currentUser.id,
      });
    },
    sendWebRTCIceCandidate: (targetUserId: number, roomId: string, candidate: any) => {
      if (!socket.current?.connected || !state.currentUser) return;
      socket.current.emit('webrtc-ice-candidate', {
        roomId,
        targetUserId,
        candidate,
        senderId: state.currentUser.id,
      });
    },
    onWebRTCOffer: (handler: (data: any) => void) => {
      webrtcOfferHandlers.current.add(handler);
    },
    offWebRTCOffer: (handler: (data: any) => void) => {
      webrtcOfferHandlers.current.delete(handler);
    },
    onWebRTCAnswer: (handler: (data: any) => void) => {
      webrtcAnswerHandlers.current.add(handler);
    },
    offWebRTCAnswer: (handler: (data: any) => void) => {
      webrtcAnswerHandlers.current.delete(handler);
    },
    onWebRTCIceCandidate: (handler: (data: any) => void) => {
      webrtcIceHandlers.current.add(handler);
    },
    offWebRTCIceCandidate: (handler: (data: any) => void) => {
      webrtcIceHandlers.current.delete(handler);
    },
  };
};

export type UseChatReturn = ReturnType<typeof useChat>;
