# حل مشكلة تذبذب أسماء المستخدمين في تبويب الرسائل

## المشكلة الأساسية
كانت أسماء المستخدمين تتذبذب من الاسم الحقيقي (مثل "أحمد") إلى اسم افتراضي (مثل "مستخدم #3") عند حدوث:
- انقطاع مؤقت في الاتصال
- بطء في استجابة الخادم
- فشل في جلب بيانات المستخدم
- تبديل بين التبويبات

## السبب الجذري
الكود السابق كان يعتمد على:
1. كاش محلي ضعيف في `MessagesPanel` فقط
2. عدم وجود آلية مركزية لتخزين أسماء المستخدمين
3. استخدام fallback فوري للاسم الافتراضي عند عدم توفر البيانات

## الحل المطبق

### 1. نظام تخزين مؤقت مركزي (`userCacheManager.ts`)
تم إنشاء نظام كاش قوي يوفر:

#### الميزات الأساسية:
- **تخزين مستمر**: حفظ البيانات في `localStorage` للاحتفاظ بها حتى بعد إعادة تحميل الصفحة
- **كاش ذكي**: يحتفظ بآخر 500 مستخدم مع إعطاء أولوية للمشرفين والمالكين
- **تحديث تلقائي**: يتم تحديث الكاش عند استقبال بيانات جديدة من أي مصدر
- **Fallback متدرج**: يبحث في عدة مصادر قبل استخدام الاسم الافتراضي

#### آلية العمل:
```typescript
// عند استقبال بيانات مستخدم
setCachedUser(user);

// عند الحاجة لاسم مستخدم
const username = getCachedUsername(userId, fallbackName);

// النتيجة:
// 1. إذا كان في الكاش -> يعيد الاسم المحفوظ
// 2. إذا تم توفير fallback صالح -> يحفظه ويعيده
// 3. آخر خيار فقط -> "مستخدم #ID"
```

### 2. التكامل مع المكونات

#### في `MessagesPanel.tsx`:
- استبدال الكاش المحلي بالكاش المركزي
- استخدام `getCachedUserWithMerge` للحصول على بيانات كاملة

#### في `useChat.ts`:
- تحديث الكاش عند استقبال قائمة المستخدمين
- تحديث الكاش عند تحديث بيانات أي مستخدم
- تحديث حالة الاتصال للمستخدمين المحفوظين

#### في `ChatInterface.tsx` و `PrivateMessageBox.tsx`:
- استخدام الكاش عند جلب بيانات مستخدم جديد
- استخدام `getCachedUsername` لعرض الأسماء

### 3. مدة الاحتفاظ بالبيانات

| نوع المستخدم | مدة الكاش |
|-------------|-----------|
| مستخدم عادي | 24 ساعة |
| VIP/مشرف/مالك | 7 أيام |

### 4. التنظيف التلقائي
- تنظيف تلقائي كل ساعة للبيانات القديمة جداً
- الاحتفاظ بآخر 500 مستخدم نشط
- حذف البيانات التي تجاوزت ضعف مدة الصلاحية

## الفوائد المحققة

### 1. استقرار الأسماء
- لا مزيد من التذبذب عند انقطاع الاتصال
- الأسماء تبقى ثابتة حتى مع بطء الشبكة

### 2. أداء محسّن
- تقليل طلبات API للخادم
- استجابة فورية من الكاش المحلي

### 3. تجربة مستخدم أفضل
- عرض الأسماء الصحيحة حتى للمستخدمين غير المتصلين
- لا حاجة لإعادة جلب البيانات عند كل فتح للتبويب

### 4. موثوقية عالية
- البيانات محفوظة حتى بعد إعادة تحميل الصفحة
- نظام fallback متعدد المستويات

## الاختبار

تم إنشاء ملف اختبار شامل في:
```
client/src/utils/__tests__/userCacheManager.test.ts
```

يغطي:
- تخزين واسترجاع البيانات
- آلية Fallback
- التخزين المستمر
- تحديث حالة الاتصال
- إحصائيات الكاش

## الصيانة المستقبلية

### نصائح للمطورين:
1. **عند إضافة مصدر جديد لبيانات المستخدمين**: تأكد من استدعاء `setCachedUser`
2. **عند عرض اسم مستخدم**: استخدم `getCachedUsername` بدلاً من الوصول المباشر
3. **للبيانات الكاملة**: استخدم `getCachedUserWithMerge` للدمج الذكي

### تحسينات مقترحة:
1. إضافة آلية مزامنة مع الخادم للتحديثات الجماعية
2. إضافة إعدادات للمستخدم للتحكم في حجم الكاش
3. إضافة مؤشرات أداء لمراقبة فعالية الكاش

## الخلاصة
الحل يوفر نظام كاش قوي ومرن يضمن استقرار أسماء المستخدمين وتحسين الأداء العام للتطبيق، مع الحفاظ على البساطة في الاستخدام والصيانة.