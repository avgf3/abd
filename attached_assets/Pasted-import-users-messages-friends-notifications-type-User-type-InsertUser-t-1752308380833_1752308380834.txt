import {
  users,
  messages,
  friends,
  notifications,
  type User,
  type InsertUser,
  type Message,
  type InsertMessage,
  type Friend,
  type InsertFriend,
  type Notification,
  type InsertNotification,
} from "../shared/schema";
import { db } from "./db";
import { eq, desc } from "drizzle-orm";

export interface IStorage {
  // User operations
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  updateUser(id: number, updates: Partial<User>): Promise<User | undefined>;
  setUserOnlineStatus(id: number, isOnline: boolean): Promise<void>;
  setUserHiddenStatus(id: number, isHidden: boolean): Promise<void>;
  addIgnoredUser(userId: number, ignoredUserId: number): Promise<void>;
  removeIgnoredUser(userId: number, ignoredUserId: number): Promise<void>;
  getIgnoredUsers(userId: number): Promise<number[]>;
  getOnlineUsers(): Promise<User[]>;
  getAllUsers(): Promise<User[]>;

  // Message operations
  createMessage(message: InsertMessage): Promise<Message>;
  getPublicMessages(limit?: number): Promise<Message[]>;
  getPrivateMessages(userId1: number, userId2: number, limit?: number): Promise<Message[]>;

  // Friend operations
  addFriend(userId: number, friendId: number): Promise<Friend>;
  getFriends(userId: number): Promise<User[]>;
  updateFriendStatus(userId: number, friendId: number, status: string): Promise<void>;
  getBlockedUsers(userId: number): Promise<User[]>;
  removeFriend(userId: number, friendId: number): Promise<boolean>;
  getFriendship(userId1: number, userId2: number): Promise<Friend | undefined>;
  
  // Friend request operations - محسن ومنظم
  createFriendRequest(senderId: number, receiverId: number): Promise<any>;
  getFriendRequest(senderId: number, receiverId: number): Promise<any>;
  getFriendRequestById(requestId: number): Promise<any>;
  getIncomingFriendRequests(userId: number): Promise<any[]>;
  getOutgoingFriendRequests(userId: number): Promise<any[]>;
  acceptFriendRequest(requestId: number): Promise<boolean>;
  declineFriendRequest(requestId: number): Promise<boolean>;
  ignoreFriendRequest(requestId: number): Promise<boolean>;
  deleteFriendRequest(requestId: number): Promise<boolean>;
  
  // User verification and security
  verifyUserCredentials(username: string, password: string): Promise<User | null>;

  // Notification operations
  createNotification(notification: InsertNotification): Promise<Notification>;
  getUserNotifications(userId: number, limit?: number): Promise<Notification[]>;
  markNotificationAsRead(notificationId: number): Promise<boolean>;
  markAllNotificationsAsRead(userId: number): Promise<boolean>;
  deleteNotification(notificationId: number): Promise<boolean>;
  getUnreadNotificationCount(userId: number): Promise<number>;
}

// Mixed storage: Database for members, Memory for guests
export class MixedStorage implements IStorage {
  private users: Map<number, User>;
  private messages: Map<number, Message>;
  private friends: Map<number, Friend>;
  private friendRequests: Map<number, any>;
  private currentUserId: number;
  private currentMessageId: number;
  private currentFriendId: number;
  private currentRequestId: number;

  constructor() {
    this.users = new Map();
    this.messages = new Map();
    this.friends = new Map();
    this.friendRequests = new Map();
    this.currentUserId = 1000; // Start guest IDs from 1000 to avoid conflicts
    this.currentMessageId = 1;
    this.currentFriendId = 1;
    this.currentRequestId = 1;

    // Initialize owner user in database
    this.initializeOwner();
  }

  private async initializeOwner() {
    try {
      // Check if owner already exists
      const existing = await db.select().from(users).where(eq(users.username, "عبدالكريم"));
      if (existing.length === 0) {
        // Create owner user in database
        await db.insert(users).values({
          username: "عبدالكريم",
          password: "عبدالكريم22333",
          userType: "owner",
          profileImage: "/default_avatar.svg",
          status: "مالك الموقع",
          gender: "ذكر",
          age: 30,
          country: "السعودية",
          relation: "مرتبط",
          isOnline: true,
          lastSeen: new Date(),
          joinDate: new Date(),
        });
      }

      // Check if admin already exists
      const existingAdmin = await db.select().from(users).where(eq(users.username, "عبود"));
      if (existingAdmin.length === 0) {
        // Create admin user in database
        await db.insert(users).values({
          username: "عبود",
          password: "22333",
          userType: "owner",
          profileImage: "/default_avatar.svg",
          status: "مشرف مؤقت",
          gender: "ذكر",
          age: 25,
          country: "العراق",
          relation: "أعزب",
          isOnline: false,
          lastSeen: new Date(),
          joinDate: new Date(),
        });
      }
    } catch (error) {
      console.error('Error initializing owner:', error);
    }
  }

  async getUser(id: number): Promise<User | undefined> {
    // Check memory first (for guests)
    const memUser = this.users.get(id);
    if (memUser) return memUser;
    
    // Check database (for members)
    try {
      const [dbUser] = await db.select().from(users).where(eq(users.id, id));
      return dbUser || undefined;
    } catch (error) {
      return undefined;
    }
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    // Check memory first (for guests)
    const memUser = Array.from(this.users.values()).find(
      (user) => user.username === username,
    );
    if (memUser) return memUser;
    
    // Check database (for members)
    const [dbUser] = await db.select().from(users).where(eq(users.username, username));
    return dbUser || undefined;
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    if (insertUser.userType === 'member' || insertUser.userType === 'owner') {
      // Store members in database with profile picture support
      const [dbUser] = await db
        .insert(users)
        .values({
          username: insertUser.username,
          password: insertUser.password,
          userType: insertUser.userType,
          profileImage: insertUser.profileImage || "/default_avatar.svg",
          profileBanner: insertUser.profileBanner || null,
          status: insertUser.status,
          gender: insertUser.gender,
          age: insertUser.age,
          country: insertUser.country,
          relation: insertUser.relation,
          isOnline: true,
          lastSeen: new Date(),
          joinDate: new Date(),
          usernameColor: '#FFFFFF',
          userTheme: 'default'
        })
        .returning();
      return dbUser;
    } else {
      // Store guests in memory (temporary, no profile picture upload)
      const id = this.currentUserId++;
      const user: User = {
        id,
        username: insertUser.username,
        password: insertUser.password || null,
        userType: insertUser.userType || "guest",
        profileImage: "/default_avatar.svg", // Guests always use default
        profileBanner: null, // Guests cannot have banners
        status: insertUser.status || null,
        gender: insertUser.gender || null,
        age: insertUser.age || null,
        country: insertUser.country || null,
        relation: insertUser.relation || null,
        isOnline: true,
        lastSeen: new Date(),
        joinDate: new Date(),
        isMuted: false,
        muteExpiry: null,
        isBanned: false,
        banExpiry: null,
        isBlocked: false,
        ipAddress: null,
        deviceId: null,
        ignoredUsers: [],
        usernameColor: '#FFFFFF',
        userTheme: 'default',
        isHidden: false
      };
      
      this.users.set(id, user);
      return user;
    }
  }

  async updateUser(id: number, updates: Partial<User>): Promise<User | undefined> {
    // Check if user is in memory (guest)
    const memUser = this.users.get(id);
    if (memUser) {
      // Guests cannot upload profile pictures or banners
      if (updates.profileImage && memUser.userType === 'guest') {
        delete updates.profileImage;
      }
      if (updates.profileBanner && memUser.userType === 'guest') {
        delete updates.profileBanner;
      }
      const updatedUser = { ...memUser, ...updates };
      this.users.set(id, updatedUser);
      return updatedUser;
    }
    
    // Check if user is in database (member)
    try {
      const [existing] = await db.select().from(users).where(eq(users.id, id));
      if (existing && (existing.userType === 'member' || existing.userType === 'owner')) {
        // Members can upload profile pictures and change themes
        const updateData: any = { ...updates };
        
        // تأكد من أن الحقول المطلوبة موجودة
        if (updates.userTheme !== undefined) {
          updateData.userTheme = updates.userTheme;
        }
        if (updates.usernameColor !== undefined) {
          updateData.usernameColor = updates.usernameColor;
        }
        
        const [updatedUser] = await db
          .update(users)
          .set(updateData)
          .where(eq(users.id, id))
          .returning();
        
        console.log('Updated user in database:', updatedUser);
        return updatedUser;
      }
    } catch (error) {
      console.error('Error updating user:', error);
    }
    
    return undefined;
  }

  async setUserOnlineStatus(id: number, isOnline: boolean): Promise<void> {
    // Check memory first (guests)
    const memUser = this.users.get(id);
    if (memUser) {
      memUser.isOnline = isOnline;
      memUser.lastSeen = new Date();
      this.users.set(id, memUser);
      return;
    }

    // Check database (members)
    try {
      await db
        .update(users)
        .set({ 
          isOnline: isOnline,
          lastSeen: new Date()
        })
        .where(eq(users.id, id));
    } catch (error) {
      console.error('Error updating user online status:', error);
    }
  }

  async getOnlineUsers(): Promise<User[]> {
    const memUsers = Array.from(this.users.values()).filter(user => user.isOnline && !user.isHidden);
    
    // Get online members from database (excluding hidden)
    try {
      const dbUsers = await db.select().from(users).where(eq(users.isOnline, true));
      
      // تنظيف حالة الكتم والطرد للمستخدمين المنتهية المدة
      const now = new Date();
      const cleanedDbUsers = dbUsers.map(user => {
        let cleaned = { ...user };
        
        // إذا انتهت مدة الكتم، نلغيها
        if (user.isMuted && user.muteExpiry && new Date(user.muteExpiry) <= now) {
          console.log(`🔄 إزالة الكتم المنتهي للمستخدم: ${user.username}`);
          cleaned.isMuted = false;
          cleaned.muteExpiry = null;
          // تحديث في قاعدة البيانات بشكل غير متزامن
          this.updateUser(user.id, { 
            isMuted: false, 
            muteExpiry: null 
          }).catch(console.error);
        }
        
        // إذا انتهت مدة الطرد، نلغيها
        if (user.isBanned && user.banExpiry && new Date(user.banExpiry) <= now) {
          console.log(`🔄 إزالة الطرد المنتهي للمستخدم: ${user.username}`);
          cleaned.isBanned = false;
          cleaned.banExpiry = null;
          // تحديث في قاعدة البيانات بشكل غير متزامن
          this.updateUser(user.id, { 
            isBanned: false, 
            banExpiry: null 
          }).catch(console.error);
        }
        
        return cleaned;
      });
      
      const visibleDbUsers = cleanedDbUsers.filter(user => !user.isHidden);
      return [...memUsers, ...visibleDbUsers];
    } catch (error) {
      return memUsers;
    }
  }

  async setUserHiddenStatus(id: number, isHidden: boolean): Promise<void> {
    // Check memory first (guests)
    const memUser = this.users.get(id);
    if (memUser) {
      memUser.isHidden = isHidden;
      this.users.set(id, memUser);
      return;
    }

    // Check database (members)
    try {
      await db.update(users).set({ isHidden }).where(eq(users.id, id));
    } catch (error) {
      console.error('Error updating user hidden status:', error);
    }
  }

  async addIgnoredUser(userId: number, ignoredUserId: number): Promise<void> {
    // Check memory first (guests)
    const memUser = this.users.get(userId);
    if (memUser) {
      if (!memUser.ignoredUsers) memUser.ignoredUsers = [];
      if (!memUser.ignoredUsers.includes(ignoredUserId.toString())) {
        memUser.ignoredUsers.push(ignoredUserId.toString());
        this.users.set(userId, memUser);
      }
      return;
    }

    // Check database (members)
    try {
      const [dbUser] = await db.select().from(users).where(eq(users.id, userId));
      if (dbUser) {
        const currentIgnored = dbUser.ignoredUsers || [];
        if (!currentIgnored.includes(ignoredUserId.toString())) {
          currentIgnored.push(ignoredUserId.toString());
          await db.update(users).set({ ignoredUsers: currentIgnored }).where(eq(users.id, userId));
        }
      }
    } catch (error) {
      console.error('Error adding ignored user:', error);
    }
  }

  async removeIgnoredUser(userId: number, ignoredUserId: number): Promise<void> {
    // Check memory first (guests)
    const memUser = this.users.get(userId);
    if (memUser && memUser.ignoredUsers) {
      memUser.ignoredUsers = memUser.ignoredUsers.filter(id => id !== ignoredUserId.toString());
      this.users.set(userId, memUser);
      return;
    }

    // Check database (members)
    try {
      const [dbUser] = await db.select().from(users).where(eq(users.id, userId));
      if (dbUser && dbUser.ignoredUsers) {
        const filteredIgnored = dbUser.ignoredUsers.filter(id => id !== ignoredUserId.toString());
        await db.update(users).set({ ignoredUsers: filteredIgnored }).where(eq(users.id, userId));
      }
    } catch (error) {
      console.error('Error removing ignored user:', error);
    }
  }

  async getIgnoredUsers(userId: number): Promise<number[]> {
    // Check memory first (guests)
    const memUser = this.users.get(userId);
    if (memUser && memUser.ignoredUsers) {
      return memUser.ignoredUsers.map(id => parseInt(id));
    }
    
    // Check database (members)
    try {
      const [dbUser] = await db.select().from(users).where(eq(users.id, userId));
      if (dbUser && dbUser.ignoredUsers) {
        return dbUser.ignoredUsers.map(id => parseInt(id));
      }
    } catch (error) {
      console.error('Error getting ignored users:', error);
    }
    
    return [];
  }

  async createMessage(insertMessage: InsertMessage): Promise<Message> {
    try {
      // Always try database first for persistence
      const [dbMessage] = await db
        .insert(messages)
        .values({
          senderId: insertMessage.senderId,
          receiverId: insertMessage.receiverId,
          content: insertMessage.content,
          messageType: insertMessage.messageType || 'text',
          isPrivate: insertMessage.isPrivate || false,
          timestamp: new Date(),
        })
        .returning();
      
      return dbMessage;
    } catch (error) {
      console.error('Database insert failed, using memory:', error);
      // Fallback to memory for guests or if database fails
      const message: Message = {
        id: this.currentMessageId++,
        senderId: insertMessage.senderId,
        receiverId: insertMessage.receiverId,
        content: insertMessage.content,
        messageType: insertMessage.messageType || 'text',
        isPrivate: insertMessage.isPrivate || false,
        timestamp: new Date(),
      };
      
      this.messages.set(message.id, message);
      return message;
    }
  }

  async getPublicMessages(limit: number = 50): Promise<Message[]> {
    // Get from memory first
    const memMessages = Array.from(this.messages.values())
      .filter(msg => !msg.isPrivate)
      .sort((a, b) => (a.timestamp || new Date()).getTime() - (b.timestamp || new Date()).getTime());
    
    // Try to get from database as well
    try {
      const dbMessages = await db.select().from(messages)
        .where(eq(messages.isPrivate, false))
        .orderBy(desc(messages.timestamp))
        .limit(limit);
      
      // Combine both sources and remove duplicates
      const allMessages = [...memMessages, ...dbMessages];
      const uniqueMessages = allMessages.filter((msg, index, arr) => 
        index === arr.findIndex(m => m.id === msg.id)
      );
      
      return uniqueMessages
        .sort((a, b) => (a.timestamp || new Date()).getTime() - (b.timestamp || new Date()).getTime())
        .slice(-limit);
    } catch (error) {
      console.error('Error getting database messages:', error);
      return memMessages.slice(-limit);
    }
  }

  async getPrivateMessages(userId1: number, userId2: number, limit: number = 50): Promise<Message[]> {
    return Array.from(this.messages.values())
      .filter(msg => 
        msg.isPrivate && 
        ((msg.senderId === userId1 && msg.receiverId === userId2) ||
         (msg.senderId === userId2 && msg.receiverId === userId1))
      )
      .sort((a, b) => (a.timestamp || new Date()).getTime() - (b.timestamp || new Date()).getTime())
      .slice(-limit);
  }

  async addFriend(userId: number, friendId: number): Promise<Friend> {
    // إضافة الصداقة في الاتجاه الأول
    const id1 = this.currentFriendId++;
    const friend1: Friend = {
      id: id1,
      userId,
      friendId,
      status: "accepted",
      createdAt: new Date(),
    };
    this.friends.set(id1, friend1);

    // إضافة الصداقة في الاتجاه المعاكس
    const id2 = this.currentFriendId++;
    const friend2: Friend = {
      id: id2,
      userId: friendId,
      friendId: userId,
      status: "accepted",
      createdAt: new Date(),
    };
    this.friends.set(id2, friend2);

    return friend1;
  }

  async getFriends(userId: number): Promise<User[]> {
    const friendships = Array.from(this.friends.values())
      .filter(f => (f.userId === userId || f.friendId === userId) && f.status === "accepted");
    
    const friendIds = [...new Set(friendships.map(f => 
      f.userId === userId ? f.friendId : f.userId
    ))]; // إزالة التكرار
    
    const friends: User[] = [];
    
    for (const friendId of friendIds) {
      if (friendId) {
        // Check memory first
        const memFriend = this.users.get(friendId);
        if (memFriend) {
          friends.push(memFriend);
        } else {
          // Check database
          try {
            const [dbFriend] = await db.select().from(users).where(eq(users.id, friendId));
            if (dbFriend) friends.push(dbFriend);
          } catch (error) {
            console.error('Error fetching friend from database:', error);
          }
        }
      }
    }
    
    return friends;
  }

  async updateFriendStatus(userId: number, friendId: number, status: string): Promise<void> {
    const friendship = Array.from(this.friends.values())
      .find(f => (f.userId === userId && f.friendId === friendId) || 
                  (f.userId === friendId && f.friendId === userId));
    
    if (friendship) {
      friendship.status = status;
      this.friends.set(friendship.id, friendship);
    }
  }

  async getBlockedUsers(userId: number): Promise<User[]> {
    const blockedFriendships = Array.from(this.friends.values())
      .filter(f => f.userId === userId && f.status === "blocked");
    
    const blockedIds = blockedFriendships.map(f => f.friendId);
    return blockedIds.map(id => this.users.get(id!)).filter(Boolean) as User[];
  }

  // Enhanced friend request operations
  async getIncomingFriendRequests(userId: number): Promise<any[]> {
    const incomingRequests = Array.from(this.friends.values())
      .filter(f => f.friendId === userId && f.status === 'pending');
    
    return await Promise.all(incomingRequests.map(async (request) => {
      const user = await this.getUser(request.userId!);
      return {
        ...request,
        user
      };
    }));
  }

  async getOutgoingFriendRequests(userId: number): Promise<any[]> {
    const outgoingRequests = Array.from(this.friends.values())
      .filter(f => f.userId === userId && f.status === 'pending');
    
    return await Promise.all(outgoingRequests.map(async (request) => {
      const user = await this.getUser(request.friendId!);
      return {
        ...request,
        user
      };
    }));
  }

  async acceptFriendRequest(requestId: number): Promise<boolean> {
    const request = this.friends.get(requestId);
    if (!request || request.status !== 'pending') return false;
    
    request.status = 'accepted';
    this.friends.set(requestId, request);
    return true;
  }

  async declineFriendRequest(requestId: number): Promise<boolean> {
    const request = this.friendRequests.get(requestId);
    if (!request || request.status !== 'pending') return false;
    
    request.status = 'declined';
    this.friendRequests.set(requestId, request);
    return true;
  }

  async ignoreFriendRequest(requestId: number): Promise<boolean> {
    const request = this.friendRequests.get(requestId);
    if (!request || request.status !== 'pending') return false;
    
    request.status = 'ignored';
    this.friendRequests.set(requestId, request);
    return true;
  }

  async deleteFriendRequest(requestId: number): Promise<boolean> {
    const request = this.friendRequests.get(requestId);
    if (!request) return false;
    
    this.friendRequests.delete(requestId);
    return true;
  }

  async removeFriend(userId: number, friendId: number): Promise<boolean> {
    const friendship = Array.from(this.friends.values())
      .find(f => (f.userId === userId && f.friendId === friendId) || 
                 (f.userId === friendId && f.friendId === userId));
    
    if (!friendship) return false;
    
    this.friends.delete(friendship.id);
    return true;
  }

  // Friend Request Operations
  async getAllUsers(): Promise<User[]> {
    try {
      const dbUsers = await db.select().from(users);
      const memoryUsers = Array.from(this.users.values());
      return [...dbUsers, ...memoryUsers];
    } catch (error) {
      console.error("خطأ في الحصول على جميع المستخدمين:", error);
      return Array.from(this.users.values());
    }
  }

  async getFriendship(userId1: number, userId2: number): Promise<Friend | undefined> {
    return Array.from(this.friends.values()).find(
      f => ((f.userId === userId1 && f.friendId === userId2) ||
           (f.userId === userId2 && f.friendId === userId1)) &&
           f.status === "accepted"
    );
  }

  async createFriendRequest(senderId: number, receiverId: number): Promise<any> {
    const request = {
      id: this.currentRequestId++,
      senderId,
      receiverId,
      status: 'pending',
      createdAt: new Date().toISOString(),
      sender: await this.getUser(senderId),
      receiver: await this.getUser(receiverId)
    };

    this.friendRequests.set(request.id, request);
    return request;
  }

  async getFriendRequest(senderId: number, receiverId: number): Promise<any> {
    return Array.from(this.friendRequests.values()).find(
      r => r.senderId === senderId && r.receiverId === receiverId && r.status === 'pending'
    );
  }

  async getFriendRequestById(requestId: number): Promise<any> {
    return this.friendRequests.get(requestId);
  }

  async getIncomingFriendRequests(userId: number): Promise<any[]> {
    const requests = Array.from(this.friendRequests.values()).filter(
      r => r.receiverId === userId && r.status === 'pending'
    );

    for (const request of requests) {
      request.sender = await this.getUser(request.senderId);
    }

    return requests;
  }

  async getOutgoingFriendRequests(userId: number): Promise<any[]> {
    const requests = Array.from(this.friendRequests.values()).filter(
      r => r.senderId === userId && r.status === 'pending'
    );

    for (const request of requests) {
      request.receiver = await this.getUser(request.receiverId);
    }

    return requests;
  }

  async acceptFriendRequest(requestId: number): Promise<boolean> {
    const request = this.friendRequests.get(requestId);
    if (!request) return false;

    request.status = 'accepted';
    this.friendRequests.set(requestId, request);
    return true;
  }

  async declineFriendRequest(requestId: number): Promise<boolean> {
    const request = this.friendRequests.get(requestId);
    if (!request) return false;

    request.status = 'declined';
    this.friendRequests.set(requestId, request);
    return true;
  }

  async deleteFriendRequest(requestId: number): Promise<boolean> {
    return this.friendRequests.delete(requestId);
  }

  // Notification operations
  async createNotification(notification: InsertNotification): Promise<Notification> {
    try {
      const [newNotification] = await db
        .insert(notifications)
        .values(notification)
        .returning();
      return newNotification;
    } catch (error) {
      console.error('Error creating notification:', error);
      throw error;
    }
  }

  async getUserNotifications(userId: number, limit: number = 50): Promise<Notification[]> {
    try {
      const userNotifications = await db
        .select()
        .from(notifications)
        .where(eq(notifications.userId, userId))
        .orderBy(desc(notifications.createdAt))
        .limit(limit);
      return userNotifications;
    } catch (error) {
      console.error('Error getting user notifications:', error);
      return [];
    }
  }

  async markNotificationAsRead(notificationId: number): Promise<boolean> {
    try {
      await db
        .update(notifications)
        .set({ isRead: true })
        .where(eq(notifications.id, notificationId));
      return true;
    } catch (error) {
      console.error('Error marking notification as read:', error);
      return false;
    }
  }

  async markAllNotificationsAsRead(userId: number): Promise<boolean> {
    try {
      await db
        .update(notifications)
        .set({ isRead: true })
        .where(eq(notifications.userId, userId));
      return true;
    } catch (error) {
      console.error('Error marking all notifications as read:', error);
      return false;
    }
  }

  async deleteNotification(notificationId: number): Promise<boolean> {
    try {
      await db.delete(notifications).where(eq(notifications.id, notificationId));
      return true;
    } catch (error) {
      console.error('Error deleting notification:', error);
      return false;
    }
  }

  async getUnreadNotificationCount(userId: number): Promise<number> {
    try {
      const result = await db
        .select()
        .from(notifications)
        .where(eq(notifications.userId, userId))
        .where(eq(notifications.isRead, false));
      return result.length;
    } catch (error) {
      console.error('Error getting unread notification count:', error);
      return 0;
    }
  }
}

export const storage = new MixedStorage();
import type { Express } from "express";
import { createServer, type Server } from "http";
import { WebSocketServer, WebSocket } from "ws";
import { storage } from "./storage";
import { setupDownloadRoute } from "./download-route";
import { insertUserSchema, insertMessageSchema } from "@shared/schema";
import { spamProtection } from "./spam-protection";
import { moderationSystem } from "./moderation";
import { sanitizeInput, validateMessageContent, checkIPSecurity, authLimiter, messageLimiter } from "./security";

import { advancedSecurity, advancedSecurityMiddleware } from "./advanced-security";
import securityApiRoutes from "./api-security";
import { z } from "zod";
import multer from "multer";
import path from "path";
import fs from "fs";

interface WebSocketClient extends WebSocket {
  userId?: number;
  username?: string;
}

// إعداد multer لرفع الصور
const storage_multer = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadDir = path.join(process.cwd(), 'client', 'public', 'uploads', 'profiles');
    
    // التأكد من وجود المجلد
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    const ext = path.extname(file.originalname);
    cb(null, `profile-${uniqueSuffix}${ext}`);
  }
});

const upload = multer({
  storage: storage_multer,
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB
  },
  fileFilter: (req, file, cb) => {
    // التحقق من نوع الملف
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('يرجى رفع ملف صورة صحيح'));
    }
  }
});

let wss: WebSocketServer;

// إنشاء خدمات محسنة ومنظمة
const authService = new (class AuthService {
  async login(username: string, password: string) {
    const user = await storage.getUserByUsername(username.trim());
    if (!user || user.password !== password.trim()) {
      throw new Error('بيانات الدخول غير صحيحة');
    }
    await storage.setUserOnlineStatus(user.id, true);
    return user;
  }
  
  async register(userData: any) {
    const existingUser = await storage.getUserByUsername(userData.username);
    if (existingUser) {
      throw new Error('اسم المستخدم موجود مسبقاً');
    }
    return await storage.createUser(userData);
  }
})();

const messageService = new (class MessageService {
  async sendMessage(senderId: number, messageData: any) {
    const sender = await storage.getUser(senderId);
    if (!sender) throw new Error('المرسل غير موجود');
    
    if (sender.isMuted && !messageData.isPrivate) {
      throw new Error('أنت مكتوم ولا يمكنك إرسال رسائل عامة');
    }
    
    return await storage.createMessage({ ...messageData, senderId });
  }
})();

const friendService = new (class FriendService {
  async sendFriendRequest(senderId: number, receiverId: number) {
    if (senderId === receiverId) {
      throw new Error('لا يمكنك إرسال طلب صداقة لنفسك');
    }
    
    const existingRequest = await storage.getFriendRequest(senderId, receiverId);
    if (existingRequest) {
      throw new Error('طلب الصداقة مرسل مسبقاً');
    }
    
    return await storage.createFriendRequest(senderId, receiverId);
  }
})();

export async function registerRoutes(app: Express): Promise<Server> {
  // رفع صور البروفايل (الصورة الشخصية) - مع تأكيد الحفظ
  app.post('/api/upload/profile-image', upload.single('profileImage'), async (req, res) => {
    try {
      console.log('🖼️ طلب رفع صورة البروفايل - الملف:', req.file?.filename);
      console.log('البيانات المرسلة:', req.body);

      if (!req.file) {
        return res.status(400).json({ error: 'لم يتم رفع أي ملف' });
      }

      const userId = req.body.userId;
      const confirmSave = req.body.confirmSave; // تأكيد الحفظ من المستخدم

      if (!userId) {
        return res.status(400).json({ error: 'معرف المستخدم مطلوب' });
      }

      // إذا لم يكن هناك تأكيد حفظ، نرجع مسار الصورة المؤقت فقط للمعاينة
      const tempImageUrl = `/uploads/profiles/${req.file.filename}`;
      
      if (!confirmSave || confirmSave === 'false') {
        console.log('📋 معاينة الصورة فقط - لم يتم الحفظ بعد');
        return res.json({
          success: true,
          preview: true,
          message: 'تم رفع الصورة للمعاينة - اضغط حفظ للتأكيد',
          tempImageUrl: tempImageUrl,
          filename: req.file.filename
        });
      }

      // إذا كان هناك تأكيد حفظ، نحفظ في قاعدة البيانات
      const user = await storage.getUser(parseInt(userId));
      if (!user) {
        return res.status(404).json({ error: 'المستخدم غير موجود' });
      }

      // حذف الصورة القديمة إذا كانت موجودة (وليست الافتراضية)
      if (user.profileImage && user.profileImage !== '/default_avatar.svg') {
        const oldImagePath = path.join(process.cwd(), 'client', 'public', user.profileImage);
        if (fs.existsSync(oldImagePath)) {
          fs.unlinkSync(oldImagePath);
          console.log('🗑️ تم حذف الصورة القديمة:', user.profileImage);
        }
      }

      // تحديث المستخدم في قاعدة البيانات بالصورة الجديدة
      const updatedUser = await storage.updateUser(parseInt(userId), { profileImage: tempImageUrl });
      
      console.log('✅ تم تحديث صورة البروفايل للمستخدم:', updatedUser?.username);

      // إرسال تحديث WebSocket لجميع المستخدمين
      if (wss && updatedUser) {
        wss.clients.forEach((client: WebSocketClient) => {
          if (client.readyState === WebSocket.OPEN) {
            client.send(JSON.stringify({
              type: 'userUpdated',
              user: updatedUser
            }));
          }
        });
      }

      res.json({
        success: true,
        message: 'تم حفظ صورة البروفايل بنجاح',
        imageUrl: tempImageUrl,
        user: updatedUser
      });

    } catch (error) {
      console.error('❌ خطأ في رفع صورة البروفايل:', error);
      res.status(500).json({ 
        error: error instanceof Error ? error.message : 'خطأ في رفع الصورة' 
      });
    }
  });

  // رفع صور البانر (الخلفية) - مع تأكيد الحفظ
  app.post('/api/upload/profile-banner', upload.single('profileBanner'), async (req, res) => {
    try {
      console.log('🎨 طلب رفع صورة البانر - الملف:', req.file?.filename);
      console.log('البيانات المرسلة:', req.body);

      if (!req.file) {
        return res.status(400).json({ error: 'لم يتم رفع أي ملف' });
      }

      const userId = req.body.userId;
      const confirmSave = req.body.confirmSave; // تأكيد الحفظ من المستخدم

      if (!userId) {
        return res.status(400).json({ error: 'معرف المستخدم مطلوب' });
      }

      // إذا لم يكن هناك تأكيد حفظ، نرجع مسار الصورة المؤقت فقط للمعاينة
      const tempBannerUrl = `/uploads/profiles/${req.file.filename}`;
      
      if (!confirmSave || confirmSave === 'false') {
        console.log('📋 معاينة صورة البانر فقط - لم يتم الحفظ بعد');
        return res.json({
          success: true,
          preview: true,
          message: 'تم رفع صورة البانر للمعاينة - اضغط حفظ للتأكيد',
          tempBannerUrl: tempBannerUrl,
          filename: req.file.filename
        });
      }

      // إذا كان هناك تأكيد حفظ، نحفظ في قاعدة البيانات
      const user = await storage.getUser(parseInt(userId));
      if (!user) {
        return res.status(404).json({ error: 'المستخدم غير موجود' });
      }

      // حذف صورة البانر القديمة إذا كانت موجودة
      if (user.profileBanner && user.profileBanner !== '') {
        const oldBannerPath = path.join(process.cwd(), 'client', 'public', user.profileBanner);
        if (fs.existsSync(oldBannerPath)) {
          fs.unlinkSync(oldBannerPath);
          console.log('🗑️ تم حذف صورة البانر القديمة:', user.profileBanner);
        }
      }

      // تحديث المستخدم في قاعدة البيانات بصورة البانر الجديدة
      const updatedUser = await storage.updateUser(parseInt(userId), { profileBanner: tempBannerUrl });
      
      console.log('✅ تم تحديث صورة البانر للمستخدم:', updatedUser?.username);

      // إرسال تحديث WebSocket لجميع المستخدمين
      if (wss && updatedUser) {
        wss.clients.forEach((client: WebSocketClient) => {
          if (client.readyState === WebSocket.OPEN) {
            client.send(JSON.stringify({
              type: 'userUpdated',
              user: updatedUser
            }));
          }
        });
      }

      res.json({
        success: true,
        message: 'تم حفظ صورة البانر بنجاح',
        bannerUrl: tempBannerUrl,
        user: updatedUser
      });

    } catch (error) {
      console.error('Error uploading profile banner:', error);
      res.status(500).json({ 
        error: error instanceof Error ? error.message : 'خطأ في رفع صورة البروفايل' 
      });
    }
  });

  // إدارة الإخفاء للإدمن والمالك
  app.post("/api/users/:userId/toggle-hidden", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const { isHidden } = req.body;
      
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ error: "المستخدم غير موجود" });
      }
      
      // فقط الإدمن والمالك يمكنهم تفعيل الإخفاء
      if (user.userType !== 'admin' && user.userType !== 'owner') {
        return res.status(403).json({ error: "غير مسموح لك بهذا الإجراء" });
      }
      
      await storage.setUserHiddenStatus(userId, isHidden);
      
      res.json({ 
        message: isHidden ? "تم تفعيل وضع المراقبة المخفية" : "تم إلغاء وضع المراقبة المخفية",
        isHidden 
      });
    } catch (error) {
      res.status(500).json({ error: "خطأ في تحديث حالة الإخفاء" });
    }
  });

  // إدارة التجاهل
  app.post("/api/users/:userId/ignore/:targetId", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const targetId = parseInt(req.params.targetId);
      
      await storage.addIgnoredUser(userId, targetId);
      
      res.json({ message: "تم تجاهل المستخدم" });
    } catch (error) {
      res.status(500).json({ error: "خطأ في تجاهل المستخدم" });
    }
  });

  app.delete("/api/users/:userId/ignore/:targetId", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const targetId = parseInt(req.params.targetId);
      
      await storage.removeIgnoredUser(userId, targetId);
      
      res.json({ message: "تم إلغاء تجاهل المستخدم" });
    } catch (error) {
      res.status(500).json({ error: "خطأ في إلغاء تجاهل المستخدم" });
    }
  });

  app.get("/api/users/:userId/ignored", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const ignoredUsers = await storage.getIgnoredUsers(userId);
      
      res.json({ ignoredUsers });
    } catch (error) {
      res.status(500).json({ error: "خطأ في جلب قائمة المتجاهلين" });
    }
  });

  // API endpoints للإدارة
  app.get("/api/moderation/actions", async (req, res) => {
    try {
      // فحص صلاحيات الإدمن
      const { userId } = req.query;
      if (!userId) {
        return res.status(401).json({ error: "غير مسموح - للإدمن والمالك فقط" });
      }
      
      const user = await storage.getUser(parseInt(userId as string));
      if (!user || (user.userType !== 'admin' && user.userType !== 'owner')) {
        return res.status(403).json({ error: "غير مسموح - للإدمن والمالك فقط" });
      }
      
      const actions = moderationSystem.getModerationLog();
      res.json({ actions });
    } catch (error) {
      res.status(500).json({ error: "خطأ في جلب سجل الإدارة" });
    }
  });

  app.get("/api/moderation/reports", async (req, res) => {
    try {
      const { userId } = req.query;
      if (!userId) {
        return res.status(401).json({ error: "غير مسموح - للإدمن والمالك فقط" });
      }
      
      const user = await storage.getUser(parseInt(userId as string));
      if (!user || (user.userType !== 'admin' && user.userType !== 'owner')) {
        return res.status(403).json({ error: "غير مسموح - للإدمن والمالك فقط" });
      }
      
      const reports = spamProtection.getPendingReports();
      res.json({ reports });
    } catch (error) {
      res.status(500).json({ error: "خطأ في جلب التقارير" });
    }
  });

  app.post("/api/moderation/report", async (req, res) => {
    try {
      const { reporterId, reportedUserId, reason, content, messageId } = req.body;
      
      const report = spamProtection.addReport(reporterId, reportedUserId, reason, content, messageId);
      res.json({ message: "تم إرسال التقرير بنجاح", report });
    } catch (error) {
      res.status(500).json({ error: "خطأ في إرسال التقرير" });
    }
  });

  app.post("/api/moderation/mute", async (req, res) => {
    try {
      const { moderatorId, targetUserId, reason, duration } = req.body;
      
      const success = await moderationSystem.muteUser(moderatorId, targetUserId, reason, duration);
      if (success) {
        res.json({ message: "تم كتم المستخدم بنجاح" });
      } else {
        res.status(400).json({ error: "فشل في كتم المستخدم" });
      }
    } catch (error) {
      res.status(500).json({ error: "خطأ في كتم المستخدم" });
    }
  });

  app.post("/api/moderation/ban", async (req, res) => {
    try {
      const { moderatorId, targetUserId, reason, duration } = req.body;
      
      const success = await moderationSystem.banUser(moderatorId, targetUserId, reason, duration);
      if (success) {
        res.json({ message: "تم طرد المستخدم بنجاح" });
      } else {
        res.status(400).json({ error: "فشل في طرد المستخدم" });
      }
    } catch (error) {
      res.status(500).json({ error: "خطأ في طرد المستخدم" });
    }
  });

  app.post("/api/moderation/block", async (req, res) => {
    try {
      const { moderatorId, targetUserId, reason } = req.body;
      
      const success = await moderationSystem.blockUser(moderatorId, targetUserId, reason);
      if (success) {
        res.json({ message: "تم حجب المستخدم بنجاح" });
      } else {
        res.status(400).json({ error: "فشل في حجب المستخدم" });
      }
    } catch (error) {
      res.status(500).json({ error: "خطأ في حجب المستخدم" });
    }
  });

  app.post("/api/moderation/promote", async (req, res) => {
    try {
      const { moderatorId, targetUserId, newRole } = req.body;
      
      const success = await moderationSystem.promoteUser(moderatorId, targetUserId, newRole);
      if (success) {
        res.json({ message: "تم ترقية المستخدم بنجاح" });
      } else {
        res.status(400).json({ error: "فشل في ترقية المستخدم" });
      }
    } catch (error) {
      res.status(500).json({ error: "خطأ في ترقية المستخدم" });
    }
  });

  app.post("/api/moderation/unmute", async (req, res) => {
    try {
      const { moderatorId, targetUserId } = req.body;
      
      const success = await moderationSystem.unmuteUser(moderatorId, targetUserId);
      if (success) {
        res.json({ message: "تم إلغاء الكتم بنجاح" });
      } else {
        res.status(400).json({ error: "فشل في إلغاء الكتم" });
      }
    } catch (error) {
      res.status(500).json({ error: "خطأ في إلغاء الكتم" });
    }
  });

  app.post("/api/moderation/unblock", async (req, res) => {
    try {
      const { moderatorId, targetUserId } = req.body;
      
      const success = await moderationSystem.unblockUser(moderatorId, targetUserId);
      if (success) {
        res.json({ message: "تم إلغاء الحجب بنجاح" });
      } else {
        res.status(400).json({ error: "فشل في إلغاء الحجب" });
      }
    } catch (error) {
      res.status(500).json({ error: "خطأ في إلغاء الحجب" });
    }
  });

  // API لتبديل وضع الإخفاء للإدمن والمالك
  app.post("/api/users/:userId/toggle-hidden", async (req, res) => {
    try {
      const { userId } = req.params;
      const { isHidden } = req.body;
      const userIdNum = parseInt(userId);
      
      // التحقق من وجود المستخدم
      const user = await storage.getUser(userIdNum);
      if (!user) {
        return res.status(404).json({ error: "المستخدم غير موجود" });
      }
      
      // التحقق من الصلاحيات - فقط للإدمن والمالك
      if (user.userType !== 'admin' && user.userType !== 'owner') {
        return res.status(403).json({ error: "هذه الخاصية للإدمن والمالك فقط" });
      }
      
      // تحديث حالة الإخفاء
      await storage.setUserHiddenStatus(userIdNum, isHidden);
      
      // إرسال إشعار WebSocket لتحديث قائمة المتصلين
      wss.clients.forEach((client: WebSocketClient) => {
        if (client.readyState === WebSocket.OPEN) {
          client.send(JSON.stringify({
            type: 'userVisibilityChanged',
            userId: userIdNum,
            isHidden: isHidden
          }));
        }
      });
      
      res.json({ 
        message: isHidden ? "تم تفعيل الوضع المخفي" : "تم إلغاء الوضع المخفي",
        isHidden: isHidden
      });
      
    } catch (error) {
      console.error('خطأ في تبديل وضع الإخفاء:', error);
      res.status(500).json({ error: "خطأ في تبديل وضع الإخفاء" });
    }
  });

  // API لتحديث لون اسم المستخدم
  app.post("/api/users/:userId/username-color", async (req, res) => {
    try {
      const { userId } = req.params;
      const { color } = req.body;
      const userIdNum = parseInt(userId);
      
      // التحقق من صحة اللون (hex color)
      if (!color || !/^#[0-9A-F]{6}$/i.test(color)) {
        return res.status(400).json({ error: "لون غير صحيح" });
      }
      
      // التحقق من وجود المستخدم
      const user = await storage.getUser(userIdNum);
      if (!user) {
        return res.status(404).json({ error: "المستخدم غير موجود" });
      }
      
      // تحديث لون الاسم
      await storage.updateUser(userIdNum, { usernameColor: color });
      
      // إرسال إشعار WebSocket لتحديث لون الاسم
      wss.clients.forEach((client: WebSocketClient) => {
        if (client.readyState === WebSocket.OPEN) {
          client.send(JSON.stringify({
            type: 'usernameColorChanged',
            userId: userIdNum,
            color: color
          }));
        }
      });
      
      res.json({ 
        message: "تم تحديث لون اسم المستخدم بنجاح",
        color: color
      });
      
    } catch (error) {
      console.error('خطأ في تحديث لون الاسم:', error);
      res.status(500).json({ error: "خطأ في تحديث لون الاسم" });
    }
  });

  const httpServer = createServer(app);
  wss = new WebSocketServer({ server: httpServer, path: '/ws' });
  
  // تطبيق فحص الأمان على جميع الطلبات
  app.use(checkIPSecurity);
  app.use(advancedSecurityMiddleware);

  // Store connected clients
  const clients = new Set<WebSocketClient>();

  // Member registration route - مع أمان محسن
  app.post("/api/auth/register", async (req, res) => {
    try {
      const { username, password, confirmPassword, gender } = req.body;
      
      // فحص الأمان الأساسي
      if (!username?.trim() || !password?.trim() || !confirmPassword?.trim()) {
        return res.status(400).json({ error: "جميع الحقول مطلوبة" });
      }

      // فحص اسم المستخدم - منع الأحرف الخاصة
      if (!/^[\u0600-\u06FFa-zA-Z0-9_]{3,20}$/.test(username.trim())) {
        return res.status(400).json({ error: "اسم المستخدم يجب أن يكون بين 3-20 حرف ولا يحتوي على رموز خاصة" });
      }

      if (password !== confirmPassword) {
        return res.status(400).json({ error: "كلمات المرور غير متطابقة" });
      }

      // فحص قوة كلمة المرور
      if (password.length < 6) {
        return res.status(400).json({ error: "كلمة المرور يجب أن تكون 6 أحرف على الأقل" });
      }
      
      if (!/(?=.*[0-9])/.test(password)) {
        return res.status(400).json({ error: "كلمة المرور يجب أن تحتوي على رقم واحد على الأقل" });
      }

      // Check if username already exists
      const existing = await storage.getUserByUsername(username);
      if (existing) {
        return res.status(400).json({ error: "اسم المستخدم موجود بالفعل" });
      }

      const user = await storage.createUser({
        username,
        password,
        userType: "member",
        gender: gender || "male",
        profileImage: "/default_avatar.svg",
      });

      res.json({ user, message: "تم التسجيل بنجاح" });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // Authentication routes
  app.post("/api/auth/guest", authLimiter, async (req, res) => {
    try {
      const { username, gender } = req.body;
      
      if (!username?.trim()) {
        return res.status(400).json({ error: "اسم المستخدم مطلوب" });
      }

      // Check if username already exists
      const existing = await storage.getUserByUsername(username);
      if (existing) {
        return res.status(400).json({ error: "الاسم مستخدم بالفعل" });
      }

      const user = await storage.createUser({
        username,
        userType: "guest",
        gender: gender || "male",
        profileImage: "/default_avatar.svg",
      });

      res.json({ user });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  app.post("/api/auth/member", authLimiter, async (req, res) => {
    try {
      const { username, password } = req.body;
      
      if (!username?.trim() || !password?.trim()) {
        return res.status(400).json({ error: "اسم المستخدم وكلمة المرور مطلوبان" });
      }

      const user = await storage.getUserByUsername(username);
      if (!user) {
        return res.status(401).json({ error: "اسم المستخدم غير موجود" });
      }

      if (user.password !== password) {
        return res.status(401).json({ error: "كلمة المرور غير صحيحة" });
      }

      await storage.setUserOnlineStatus(user.id, true);
      res.json({ user });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // User routes - إضافة مسار الحصول على جميع المستخدمين
  app.get("/api/users", async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      res.json({ users });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  app.get("/api/all-users", async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      res.json({ users });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  app.get("/api/users/online", async (req, res) => {
    try {
      const users = await storage.getOnlineUsers();
      res.json({ users });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  app.put("/api/users/:id", async (req, res) => {
    try {
      const userId = parseInt(req.params.id);
      const updates = req.body;
      
      const user = await storage.updateUser(userId, updates);
      if (!user) {
        return res.status(404).json({ error: "المستخدم غير موجود" });
      }

      // Broadcast user update to all connected clients
      const connectedClients = Array.from(clients);
      connectedClients.forEach(client => {
        if (client.readyState === WebSocket.OPEN) {
          client.send(JSON.stringify({
            type: 'userUpdated',
            user: user,
          }));
        }
      });

      res.json({ user });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // Message routes
  // إضافة مسار إنشاء الرسائل
  app.post("/api/messages", async (req, res) => {
    try {
      const { senderId, receiverId, content, messageType, isPrivate = false } = req.body;
      
      if (!senderId || !content || !messageType) {
        return res.status(400).json({ error: "البيانات المطلوبة مفقودة" });
      }

      const message = await storage.createMessage({
        senderId,
        receiverId: isPrivate ? receiverId : null,
        content,
        messageType,
        isPrivate,
        timestamp: new Date()
      });

      // Broadcast message to connected clients
      if (wss) {
        wss.clients.forEach((client: WebSocketClient) => {
          if (client.readyState === WebSocket.OPEN) {
            client.send(JSON.stringify({
              type: 'newMessage',
              message: {
                ...message,
                sender: {
                  id: senderId,
                  username: '',
                  userType: ''
                }
              }
            }));
          }
        });
      }

      res.json({ message, success: true });
    } catch (error) {
      console.error("خطأ في إنشاء الرسالة:", error);
      res.status(500).json({ error: "خطأ في إنشاء الرسالة" });
    }
  });

  app.get("/api/messages/public", async (req, res) => {
    try {
      const limit = parseInt(req.query.limit as string) || 50;
      const messages = await storage.getPublicMessages(limit);
      
      // Get user details for each message
      const messagesWithUsers = await Promise.all(
        messages.map(async (msg) => {
          const sender = msg.senderId ? await storage.getUser(msg.senderId) : null;
          return { ...msg, sender };
        })
      );

      res.json({ messages: messagesWithUsers });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  app.get("/api/messages/private/:userId1/:userId2", async (req, res) => {
    try {
      const userId1 = parseInt(req.params.userId1);
      const userId2 = parseInt(req.params.userId2);
      const limit = parseInt(req.query.limit as string) || 50;
      
      const messages = await storage.getPrivateMessages(userId1, userId2, limit);
      
      const messagesWithUsers = await Promise.all(
        messages.map(async (msg) => {
          const sender = msg.senderId ? await storage.getUser(msg.senderId) : null;
          return { ...msg, sender };
        })
      );

      res.json({ messages: messagesWithUsers });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // Profile picture upload (members only)
  app.post('/api/users/:id/profile-image', async (req, res) => {
    try {
      const userId = parseInt(req.params.id);
      const { imageData } = req.body;
      
      if (!imageData) {
        return res.status(400).json({ error: "صورة مطلوبة" });
      }

      // Check if user is a member
      const existingUser = await storage.getUser(userId);
      if (!existingUser) {
        return res.status(404).json({ error: "المستخدم غير موجود" });
      }

      // Allow members and owners to upload profile pictures (not guests)
      if (existingUser.userType === 'guest') {
        return res.status(403).json({ 
          error: "رفع الصور الشخصية متاح للأعضاء فقط",
          userType: existingUser.userType,
          userId: userId
        });
      }

      const user = await storage.updateUser(userId, { profileImage: imageData });
      if (!user) {
        return res.status(500).json({ error: "فشل في تحديث الصورة" });
      }

      // Broadcast user update to all connected clients
      broadcast({
        type: 'userUpdated',
        user
      });

      res.json({ user, message: "تم تحديث الصورة الشخصية بنجاح" });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // Friend routes
  app.get("/api/friends/:userId", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const friends = await storage.getFriends(userId);
      res.json({ friends });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  app.post("/api/friends", async (req, res) => {
    try {
      const { userId, friendId } = req.body;
      const friendship = await storage.addFriend(userId, friendId);
      res.json({ friendship });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });



  // Update username color
  app.post('/api/users/:userId/color', async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const { color } = req.body;
      
      if (!userId || !color) {
        return res.status(400).json({ message: 'معرف المستخدم واللون مطلوبان' });
      }

      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: 'المستخدم غير موجود' });
      }

      // Update username color
      await storage.updateUser(userId, { usernameColor: color });
      
      // Broadcast the color change to all connected clients
      broadcast({
        type: 'usernameColorChanged',
        userId: userId,
        color: color,
        username: user.username
      });
      
      res.json({ 
        success: true, 
        message: 'تم تحديث لون الاسم بنجاح',
        color 
      });
    } catch (error) {
      console.error('Error updating username color:', error);
      res.status(500).json({ message: 'خطأ في تحديث لون الاسم' });
    }
  });

  // WebSocket handling
  wss.on('connection', (ws: WebSocketClient) => {
    console.log('اتصال WebSocket جديد');
    clients.add(ws);
    
    // إرسال رسالة ترحيب فورية
    ws.send(JSON.stringify({
      type: 'connected',
      message: 'متصل بنجاح'
    }));
    
    // heartbeat للحفاظ على الاتصال
    const heartbeat = setInterval(() => {
      if (ws.readyState === WebSocket.OPEN) {
        ws.ping();
      } else {
        clearInterval(heartbeat);
      }
    }, 30000);

    ws.on('message', async (data) => {
      try {
        const message = JSON.parse(data.toString());
        console.log(`رسالة WebSocket من ${ws.username || 'غير معروف'}: ${message.type}`);
        
        switch (message.type) {
          case 'auth':
            ws.userId = message.userId;
            ws.username = message.username;
            
            // فحص حالة المستخدم قبل السماح بالاتصال
            const authUserStatus = await moderationSystem.checkUserStatus(message.userId);
            if (authUserStatus.isBlocked) {
              ws.send(JSON.stringify({
                type: 'error',
                message: 'أنت محجوب نهائياً من الدردشة',
                action: 'blocked'
              }));
              ws.close();
              return;
            }
            
            if (authUserStatus.isBanned) {
              ws.send(JSON.stringify({
                type: 'error',
                message: `أنت مطرود من الدردشة لمدة ${authUserStatus.timeLeft} دقيقة`,
                action: 'banned'
              }));
              ws.close();
              return;
            }
            
            await storage.setUserOnlineStatus(message.userId, true);
            
            // Broadcast user joined
            broadcast({
              type: 'userJoined',
              user: await storage.getUser(message.userId),
            }, ws);
            
            // Send online users list with moderation status
            const onlineUsers = await storage.getOnlineUsers();
            const usersWithStatus = await Promise.all(
              onlineUsers.map(async (user) => {
                const status = await moderationSystem.checkUserStatus(user.id);
                return {
                  ...user,
                  isMuted: status.isMuted,
                  isBlocked: status.isBlocked,
                  isBanned: status.isBanned
                };
              })
            );
            
            ws.send(JSON.stringify({
              type: 'onlineUsers',
              users: usersWithStatus,
            }));
            break;

          case 'publicMessage':
            if (ws.userId) {
              // فحص حالة الكتم والحظر
              const userStatus = await moderationSystem.checkUserStatus(ws.userId);
              if (userStatus.isMuted) {
                ws.send(JSON.stringify({
                  type: 'error',
                  message: 'أنت مكتوم ولا يمكنك إرسال رسائل في الدردشة العامة. يمكنك التحدث في الرسائل الخاصة.',
                  action: 'muted'
                }));
                console.log(`🔇 المستخدم ${ws.username} محاول الكتابة وهو مكتوم`);
                break;
              }
              
              if (userStatus.isBanned) {
                ws.send(JSON.stringify({
                  type: 'error',
                  message: 'أنت مطرود من الدردشة',
                  action: 'banned'
                }));
                break;
              }
              
              if (userStatus.isBlocked) {
                ws.send(JSON.stringify({
                  type: 'error',
                  message: 'أنت محجوب نهائياً من الدردشة',
                  action: 'blocked'
                }));
                // قطع الاتصال للمحجوبين
                ws.close();
                break;
              }

              // تنظيف المحتوى
              const sanitizedContent = sanitizeInput(message.content);
              
              // فحص صحة المحتوى
              const contentCheck = validateMessageContent(sanitizedContent);
              if (!contentCheck.isValid) {
                ws.send(JSON.stringify({
                  type: 'error',
                  message: contentCheck.reason
                }));
                break;
              }
              
              // فحص الرسالة ضد السبام
              const spamCheck = spamProtection.checkMessage(ws.userId, sanitizedContent);
              if (!spamCheck.isAllowed) {
                ws.send(JSON.stringify({
                  type: 'error',
                  message: spamCheck.reason,
                  action: spamCheck.action
                }));
                
                // إرسال تحذير إذا لزم الأمر
                if (spamCheck.action === 'warn') {
                  ws.send(JSON.stringify({
                    type: 'warning',
                    message: 'تم إعطاؤك تحذير بسبب مخالفة قوانين الدردشة'
                  }));
                }
                break;
              }

              const newMessage = await storage.createMessage({
                senderId: ws.userId,
                content: sanitizedContent,
                messageType: message.messageType || 'text',
                isPrivate: false,
              });
              
              const sender = await storage.getUser(ws.userId);
              broadcast({
                type: 'newMessage',
                message: { ...newMessage, sender },
              });
            }
            break;

          case 'privateMessage':
            if (ws.userId) {
              // منع إرسال رسالة للنفس
              if (ws.userId === message.receiverId) {
                ws.send(JSON.stringify({
                  type: 'error',
                  message: 'لا يمكن إرسال رسالة لنفسك',
                  action: 'blocked'
                }));
                break;
              }

              // تنظيف المحتوى
              const sanitizedContent = sanitizeInput(message.content);
              
              // فحص صحة المحتوى
              const contentCheck = validateMessageContent(sanitizedContent);
              if (!contentCheck.isValid) {
                ws.send(JSON.stringify({
                  type: 'error',
                  message: contentCheck.reason
                }));
                break;
              }
              
              // فحص الرسالة الخاصة ضد السبام
              const spamCheck = spamProtection.checkMessage(ws.userId, sanitizedContent);
              if (!spamCheck.isAllowed) {
                ws.send(JSON.stringify({
                  type: 'error',
                  message: spamCheck.reason,
                  action: spamCheck.action
                }));
                break;
              }

              const newMessage = await storage.createMessage({
                senderId: ws.userId,
                receiverId: message.receiverId,
                content: sanitizedContent,
                messageType: message.messageType || 'text',
                isPrivate: true,
              });
              
              const sender = await storage.getUser(ws.userId);
              const messageWithSender = { ...newMessage, sender };
              
              // Send to receiver only (don't send to sender)
              const receiverClient = Array.from(clients).find(
                client => client.userId === message.receiverId
              );
              if (receiverClient && receiverClient.readyState === WebSocket.OPEN) {
                receiverClient.send(JSON.stringify({
                  type: 'privateMessage',
                  message: messageWithSender,
                }));
              }
              
              // Send back to sender with confirmation
              ws.send(JSON.stringify({
                type: 'privateMessage',
                message: messageWithSender,
              }));
            }
            break;

          case 'typing':
            if (ws.userId) {
              broadcast({
                type: 'userTyping',
                userId: ws.userId,
                username: ws.username,
                isTyping: message.isTyping,
              }, ws);
            }
            break;
        }
      } catch (error) {
        console.error('WebSocket message error:', error);
      }
    });

    ws.on('close', async () => {
      clients.delete(ws);
      if (ws.userId) {
        await storage.setUserOnlineStatus(ws.userId, false);
        broadcast({
          type: 'userLeft',
          userId: ws.userId,
          username: ws.username,
        }, ws);
      }
    });
  });

  function broadcast(message: any, sender?: WebSocketClient) {
    const messageStr = JSON.stringify(message);
    clients.forEach(client => {
      if (client !== sender && client.readyState === WebSocket.OPEN) {
        client.send(messageStr);
      }
    });
  }

  // Friend system APIs
  
  // البحث عن المستخدمين
  app.get("/api/users/search", async (req, res) => {
    try {
      const { q, userId } = req.query;
      
      if (!q || !userId) {
        return res.status(400).json({ error: "معاملات البحث مطلوبة" });
      }

      const allUsers = await storage.getAllUsers();
      const searchTerm = (q as string).toLowerCase();
      
      const filteredUsers = allUsers.filter(user => 
        user.id !== parseInt(userId as string) && // استبعاد المستخدم الحالي
        user.username.toLowerCase().includes(searchTerm)
      ).slice(0, 10); // حد أقصى 10 نتائج

      res.json({ users: filteredUsers });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // إرسال طلب صداقة
  app.post("/api/friend-requests", async (req, res) => {
    try {
      const { senderId, receiverId } = req.body;
      
      if (!senderId || !receiverId) {
        return res.status(400).json({ error: "معلومات المرسل والمستقبل مطلوبة" });
      }

      if (senderId === receiverId) {
        return res.status(400).json({ error: "لا يمكنك إرسال طلب صداقة لنفسك" });
      }

      // التحقق من وجود طلب سابق
      const existingRequest = await storage.getFriendRequest(senderId, receiverId);
      if (existingRequest) {
        return res.status(400).json({ error: "طلب الصداقة موجود بالفعل" });
      }

      // التحقق من الصداقة الموجودة
      const friendship = await storage.getFriendship(senderId, receiverId);
      if (friendship) {
        return res.status(400).json({ error: "أنتما أصدقاء بالفعل" });
      }

      const request = await storage.createFriendRequest(senderId, receiverId);
      
      // إرسال إشعار عبر WebSocket
      const sender = await storage.getUser(senderId);
      broadcast({
        type: 'friendRequestReceived',
        targetUserId: receiverId,
        senderName: sender?.username,
        senderId: senderId
      });

      // إنشاء إشعار حقيقي في قاعدة البيانات
      await storage.createNotification({
        userId: receiverId,
        type: 'friendRequest',
        title: '👫 طلب صداقة جديد',
        message: `أرسل ${sender?.username} طلب صداقة إليك`,
        data: { requestId: request.id, senderId: senderId, senderName: sender?.username }
      });

      res.json({ message: "تم إرسال طلب الصداقة", request });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // الحصول على طلبات الصداقة الواردة
  app.get("/api/friend-requests/incoming/:userId", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const requests = await storage.getIncomingFriendRequests(userId);
      res.json({ requests });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // الحصول على طلبات الصداقة الصادرة
  app.get("/api/friend-requests/outgoing/:userId", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const requests = await storage.getOutgoingFriendRequests(userId);
      res.json({ requests });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // قبول طلب صداقة
  app.post("/api/friend-requests/:requestId/accept", async (req, res) => {
    try {
      const requestId = parseInt(req.params.requestId);
      const { userId } = req.body;
      
      const request = await storage.getFriendRequestById(requestId);
      if (!request || request.receiverId !== userId) {
        return res.status(403).json({ error: "غير مسموح" });
      }

      // قبول طلب الصداقة وإضافة الصداقة
      await storage.acceptFriendRequest(requestId);
      await storage.addFriend(request.senderId, request.receiverId);
      
      // الحصول على بيانات المستخدمين
      const receiver = await storage.getUser(userId);
      const sender = await storage.getUser(request.senderId);
      
      // إرسال إشعار WebSocket لتحديث قوائم الأصدقاء
      broadcast({
        type: 'friendAdded',
        targetUserId: request.senderId,
        friendId: request.receiverId,
        friendName: receiver?.username
      });
      
      broadcast({
        type: 'friendAdded', 
        targetUserId: request.receiverId,
        friendId: request.senderId,
        friendName: sender?.username
      });
      broadcast({
        type: 'friendRequestAccepted',
        targetUserId: request.senderId,
        senderName: receiver?.username
      });

      // إنشاء إشعار حقيقي في قاعدة البيانات
      await storage.createNotification({
        userId: request.senderId,
        type: 'friendAccepted',
        title: '✅ تم قبول طلب الصداقة',
        message: `قبل ${receiver?.username} طلب صداقتك`,
        data: { friendId: userId, friendName: receiver?.username }
      });

      res.json({ message: "تم قبول طلب الصداقة" });
    } catch (error) {
      console.error("خطأ في قبول طلب الصداقة:", error);
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // رفض طلب صداقة
  app.post("/api/friend-requests/:requestId/decline", async (req, res) => {
    try {
      const requestId = parseInt(req.params.requestId);
      const { userId } = req.body;
      
      const request = await storage.getFriendRequestById(requestId);
      if (!request || request.receiverId !== userId) {
        return res.status(403).json({ error: "غير مسموح" });
      }

      await storage.declineFriendRequest(requestId);
      res.json({ message: "تم رفض طلب الصداقة" });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // إلغاء طلب صداقة
  app.post("/api/friend-requests/:requestId/cancel", async (req, res) => {
    try {
      const requestId = parseInt(req.params.requestId);
      const { userId } = req.body;
      
      const request = await storage.getFriendRequestById(requestId);
      if (!request || request.senderId !== userId) {
        return res.status(403).json({ error: "غير مسموح" });
      }

      await storage.deleteFriendRequest(requestId);
      res.json({ message: "تم إلغاء طلب الصداقة" });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // تجاهل طلب صداقة
  app.post("/api/friend-requests/:requestId/ignore", async (req, res) => {
    try {
      const requestId = parseInt(req.params.requestId);
      const { userId } = req.body;
      
      const request = await storage.getFriendRequestById(requestId);
      if (!request || request.receiverId !== userId) {
        return res.status(403).json({ error: "غير مسموح" });
      }

      await storage.ignoreFriendRequest(requestId);
      res.json({ message: "تم تجاهل طلب الصداقة" });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // الحصول على قائمة الأصدقاء
  app.get("/api/friends/:userId", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const friends = await storage.getFriends(userId);
      res.json({ friends });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // إزالة صديق
  app.delete("/api/friends/:userId/:friendId", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const friendId = parseInt(req.params.friendId);
      
      await storage.removeFriend(userId, friendId);
      res.json({ message: "تم إزالة الصديق" });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // API routes for spam protection and reporting
  
  // إضافة تبليغ
  app.post("/api/reports", async (req, res) => {
    try {
      const { reporterId, reportedUserId, reason, content, messageId } = req.body;
      
      if (!reporterId || !reportedUserId || !reason || !content) {
        return res.status(400).json({ error: "جميع الحقول مطلوبة" });
      }

      // منع البلاغ على الإدمن والمشرف والمالك
      const reportedUser = await storage.getUser(reportedUserId);
      if (reportedUser && ['admin', 'moderator', 'owner'].includes(reportedUser.userType)) {
        return res.status(403).json({ 
          error: "لا يمكن الإبلاغ عن أعضاء الإدارة (المشرف، الإدمن، المالك)" 
        });
      }

      const report = spamProtection.addReport(reporterId, reportedUserId, reason, content, messageId);
      res.json({ report, message: "تم إرسال التبليغ بنجاح" });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // الحصول على التبليغات المعلقة (للمشرفين)
  app.get("/api/reports/pending", async (req, res) => {
    try {
      const { userId } = req.query;
      
      // التحقق من أن المستخدم مشرف
      const user = await storage.getUser(parseInt(userId as string));
      if (!user || user.userType !== 'owner') {
        return res.status(403).json({ error: "غير مسموح" });
      }

      const reports = spamProtection.getPendingReports();
      res.json({ reports });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // مراجعة تبليغ (للمشرفين)
  app.patch("/api/reports/:reportId", async (req, res) => {
    try {
      const { reportId } = req.params;
      const { action, userId } = req.body;
      
      // التحقق من أن المستخدم مشرف
      const user = await storage.getUser(userId);
      if (!user || user.userType !== 'owner') {
        return res.status(403).json({ error: "غير مسموح" });
      }

      const success = spamProtection.reviewReport(parseInt(reportId), action);
      if (success) {
        res.json({ message: "تم مراجعة التبليغ" });
      } else {
        res.status(404).json({ error: "التبليغ غير موجود" });
      }
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // الحصول على حالة المستخدم
  app.get("/api/users/:userId/spam-status", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const status = spamProtection.getUserStatus(userId);
      res.json({ status });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // إعادة تعيين نقاط السبام (للمشرفين)
  app.post("/api/users/:userId/reset-spam", async (req, res) => {
    try {
      const { userId } = req.params;
      const { adminId } = req.body;
      
      // التحقق من أن المستخدم مشرف
      const admin = await storage.getUser(adminId);
      if (!admin || admin.userType !== 'owner') {
        return res.status(403).json({ error: "غير مسموح" });
      }

      spamProtection.resetUserSpamScore(parseInt(userId));
      res.json({ message: "تم إعادة تعيين نقاط السبام" });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // إحصائيات السبام (للمشرفين)
  app.get("/api/spam-stats", async (req, res) => {
    try {
      const { userId } = req.query;
      
      // التحقق من أن المستخدم مشرف
      const user = await storage.getUser(parseInt(userId as string));
      if (!user || user.userType !== 'owner') {
        return res.status(403).json({ error: "غير مسموح" });
      }

      const stats = spamProtection.getStats();
      res.json({ stats });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // Moderation routes
  app.post("/api/moderation/mute", async (req, res) => {
    try {
      const { moderatorId, targetUserId, reason, duration } = req.body;
      const clientIP = req.ip || req.connection.remoteAddress || 'unknown';
      const deviceId = req.headers['user-agent'] || 'unknown';
      
      const success = await moderationSystem.muteUser(
        moderatorId, 
        targetUserId, 
        reason, 
        duration, 
        clientIP, 
        deviceId
      );
      
      if (success) {
        const moderator = await storage.getUser(moderatorId);
        const target = await storage.getUser(targetUserId);
        
        // إرسال إشعار للدردشة العامة
        const systemMessage = `🔇 تم كتم ${target?.username} من قبل ${moderator?.username} لمدة ${duration} دقيقة - السبب: ${reason}`;
        
        broadcast({
          type: 'moderationAction',
          action: 'muted',
          targetUserId: targetUserId,
          message: systemMessage,
          reason,
          duration
        });

        // إرسال إشعار للمستخدم المكتوم
        broadcast({
          type: 'notification',
          targetUserId: targetUserId,
          notificationType: 'muted',
          message: `تم كتمك من قبل ${moderator?.username} لمدة ${duration} دقيقة - السبب: ${reason}`,
          moderatorName: moderator?.username
        });
        
        // لا يتم قطع الاتصال - المستخدم يبقى في الدردشة لكن مكتوم
        res.json({ message: "تم كتم المستخدم بنجاح - يمكنه البقاء في الدردشة ولكن لا يمكنه التحدث في العام" });
      } else {
        res.status(403).json({ error: "غير مسموح لك بهذا الإجراء" });
      }
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  app.post("/api/moderation/unmute", async (req, res) => {
    try {
      const { moderatorId, targetUserId } = req.body;
      
      const success = await moderationSystem.unmuteUser(moderatorId, targetUserId);
      
      if (success) {
        const moderator = await storage.getUser(moderatorId);
        const target = await storage.getUser(targetUserId);
        
        // إرسال إشعار للدردشة العامة
        const systemMessage = `🔊 تم إلغاء كتم ${target?.username} من قبل ${moderator?.username}`;
        
        broadcast({
          type: 'moderationAction',
          action: 'unmuted',
          targetUserId: targetUserId,
          message: systemMessage
        });
        
        res.json({ message: "تم إلغاء الكتم بنجاح" });
      } else {
        res.status(403).json({ error: "غير مسموح لك بهذا الإجراء" });
      }
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  app.post("/api/moderation/ban", async (req, res) => {
    try {
      const { moderatorId, targetUserId, reason, duration } = req.body;
      const clientIP = req.ip || req.connection.remoteAddress || 'unknown';
      const deviceId = req.headers['user-agent'] || 'unknown';
      
      const success = await moderationSystem.banUser(
        moderatorId, 
        targetUserId, 
        reason, 
        duration, 
        clientIP, 
        deviceId
      );
      
      if (success) {
        const moderator = await storage.getUser(moderatorId);
        const target = await storage.getUser(targetUserId);
        
        // إرسال إشعار خاص للمستخدم المطرود
        const targetClient = Array.from(wss.clients).find((client: any) => client.userId === targetUserId);
        if (targetClient && targetClient.readyState === WebSocket.OPEN) {
          targetClient.send(JSON.stringify({
            type: 'kicked',
            targetUserId: targetUserId,
            duration: duration,
            reason: reason
          }));
        }

        // إرسال إشعار للدردشة العامة
        const systemMessage = `⏰ تم طرد ${target?.username} من قبل ${moderator?.username} لمدة ${duration} دقيقة - السبب: ${reason}`;
        
        broadcast({
          type: 'moderationAction',
          action: 'banned',
          targetUserId: targetUserId,
          message: systemMessage
        });
        
        // إجبار قطع الاتصال
        clients.forEach(client => {
          if (client.userId === targetUserId) {
            client.close();
          }
        });
        
        res.json({ message: "تم طرد المستخدم بنجاح" });
      } else {
        res.status(403).json({ error: "غير مسموح لك بهذا الإجراء" });
      }
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  app.post("/api/moderation/block", async (req, res) => {
    try {
      const { moderatorId, targetUserId, reason, ipAddress, deviceId } = req.body;
      const clientIP = req.ip || req.connection.remoteAddress || ipAddress || 'unknown';
      const clientDevice = req.headers['user-agent'] || deviceId || 'unknown';
      
      const success = await moderationSystem.blockUser(
        moderatorId, 
        targetUserId, 
        reason, 
        clientIP, 
        clientDevice
      );
      
      if (success) {
        const moderator = await storage.getUser(moderatorId);
        const target = await storage.getUser(targetUserId);
        
        // إرسال إشعار خاص للمستخدم المحجوب
        const targetClient = Array.from(wss.clients).find((client: any) => client.userId === targetUserId);
        if (targetClient && targetClient.readyState === WebSocket.OPEN) {
          targetClient.send(JSON.stringify({
            type: 'blocked',
            targetUserId: targetUserId,
            reason: reason
          }));
        }

        // إرسال إشعار للدردشة العامة
        const systemMessage = `🚫 تم حجب ${target?.username} نهائياً من قبل ${moderator?.username} - السبب: ${reason}`;
        
        broadcast({
          type: 'moderationAction',
          action: 'blocked',
          targetUserId: targetUserId,
          message: systemMessage
        });
        
        // إجبار قطع الاتصال
        clients.forEach(client => {
          if (client.userId === targetUserId) {
            client.close();
          }
        });
        
        res.json({ message: "تم حجب المستخدم بنجاح" });
      } else {
        res.status(403).json({ error: "غير مسموح لك بهذا الإجراء" });
      }
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  app.post("/api/moderation/promote", async (req, res) => {
    try {
      const { moderatorId, targetUserId, role } = req.body;
      
      // التحقق من أن المتقدم بالطلب هو المالك فقط
      const moderator = await storage.getUser(moderatorId);
      if (!moderator || moderator.userType !== 'owner') {
        return res.status(403).json({ error: "هذه الميزة للمالك فقط" });
      }

      // التحقق من أن المستخدم المراد ترقيته عضو وليس زائر
      const target = await storage.getUser(targetUserId);
      if (!target || target.userType !== 'member') {
        return res.status(400).json({ error: "يمكن ترقية الأعضاء فقط" });
      }
      
      // التأكد من أن الرتبة صحيحة (إدمن أو مشرف فقط)
      if (!['admin', 'moderator'].includes(role)) {
        return res.status(400).json({ error: "رتبة غير صالحة - يمكن الترقية لإدمن أو مشرف فقط" });
      }
      
      // تحديث المستخدم في قاعدة البيانات
      await storage.updateUser(targetUserId, { userType: role });
      const updatedUser = await storage.getUser(targetUserId);
      
      const roleDisplay = role === 'admin' ? 'إدمن ⭐' : 'مشرف 🛡️';
      const rolePermissions = role === 'admin' ? 'يمكنه كتم وطرد المستخدمين' : 'يمكنه كتم المستخدمين فقط';
      
      // إرسال إشعار للمستخدم المرقى
      const targetClient = Array.from(wss.clients).find((client: any) => client.userId === targetUserId);
      if (targetClient && targetClient.readyState === WebSocket.OPEN) {
        targetClient.send(JSON.stringify({
          type: 'promotion',
          newRole: role,
          message: `تهانينا! تمت ترقيتك إلى ${roleDisplay} - ${rolePermissions}`
        }));
      }
      
      // إشعار جميع المستخدمين بالترقية
      broadcast({
        type: 'userUpdated',
        user: updatedUser
      });

      // إشعار عام في الدردشة
      broadcast({
        type: 'systemNotification',
        message: `🎉 تم ترقية ${target.username} إلى ${roleDisplay}`,
        timestamp: new Date().toISOString()
      });
      
      res.json({ 
        success: true,
        message: `تمت ترقية ${target.username} إلى ${roleDisplay}`,
        user: updatedUser
      });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  app.post("/api/moderation/unmute", async (req, res) => {
    try {
      const { moderatorId, targetUserId } = req.body;
      
      const success = await moderationSystem.unmuteUser(moderatorId, targetUserId);
      
      if (success) {
        res.json({ message: "تم فك الكتم بنجاح" });
      } else {
        res.status(403).json({ error: "غير مسموح لك بهذا الإجراء" });
      }
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  app.post("/api/moderation/unblock", async (req, res) => {
    try {
      const { moderatorId, targetUserId } = req.body;
      
      const success = await moderationSystem.unblockUser(moderatorId, targetUserId);
      
      if (success) {
        res.json({ message: "تم فك الحجب بنجاح" });
      } else {
        res.status(403).json({ error: "غير مسموح لك بهذا الإجراء" });
      }
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  app.get("/api/moderation/log", async (req, res) => {
    try {
      const userId = parseInt(req.query.userId as string);
      const user = await storage.getUser(userId);
      
      // للإدمن والمالك فقط
      if (!user || (user.userType !== 'owner' && user.userType !== 'admin')) {
        return res.status(403).json({ error: "غير مسموح لك بالوصول - للإدمن والمالك فقط" });
      }

      const log = moderationSystem.getModerationLog();
      res.json({ log });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // إضافة endpoint سجل الإجراءات للإدمن
  app.get("/api/moderation/actions", async (req, res) => {
    try {
      const userId = parseInt(req.query.userId as string);
      const user = await storage.getUser(userId);
      
      // للإدمن والمالك فقط
      if (!user || (user.userType !== 'owner' && user.userType !== 'admin')) {
        return res.status(403).json({ error: "غير مسموح - للإدمن والمالك فقط" });
      }

      const actions = moderationSystem.getModerationLog()
        .map(action => ({
          ...action,
          moderatorName: '', 
          targetName: '' 
        }));
      
      // إضافة أسماء المستخدمين للإجراءات
      for (const action of actions) {
        const moderator = await storage.getUser(action.moderatorId);
        const target = await storage.getUser(action.targetUserId);
        action.moderatorName = moderator?.username || 'مجهول';
        action.targetName = target?.username || 'مجهول';
      }

      console.log(`📋 ${user.username} طلب سجل الإجراءات - ${actions.length} إجراء`);
      res.json(actions);
    } catch (error) {
      console.error("خطأ في الحصول على سجل الإجراءات:", error);
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // Friends routes
  app.get("/api/friends/:userId", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const friends = await storage.getFriends(userId);
      
      res.json({ friends });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  app.post("/api/friends", async (req, res) => {
    try {
      const { userId, friendId } = req.body;
      
      // التحقق من أن المستخدمين موجودين
      const user = await storage.getUser(userId);
      const friend = await storage.getUser(friendId);
      
      if (!user || !friend) {
        return res.status(404).json({ error: "المستخدم غير موجود" });
      }
      
      // التحقق من أن المستخدم لا يضيف نفسه
      if (userId === friendId) {
        return res.status(400).json({ error: "لا يمكنك إضافة نفسك كصديق" });
      }
      
      const friendship = await storage.addFriend(userId, friendId);
      
      // إرسال تنبيه WebSocket للمستخدم المستهدف
      broadcast({
        type: 'friendRequest',
        targetUserId: friendId,
        senderUserId: userId,
        senderUsername: user.username,
        message: `${user.username} يريد إضافتك كصديق`
      });
      
      res.json({ 
        message: "تم إرسال طلب الصداقة",
        friendship 
      });
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  app.delete("/api/friends/:userId/:friendId", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const friendId = parseInt(req.params.friendId);
      
      const success = await storage.removeFriend(userId, friendId);
      
      if (success) {
        res.json({ message: "تم حذف الصديق" });
      } else {
        res.status(404).json({ error: "الصداقة غير موجودة" });
      }
    } catch (error) {
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });



  // إضافة endpoint لوحة إجراءات المشرفين
  app.get("/api/moderation/actions", async (req, res) => {
    try {
      const { userId } = req.query;
      const user = await storage.getUser(Number(userId));
      
      // التحقق من أن المستخدم مشرف أو مالك
      if (!user || (user.userType !== 'admin' && user.userType !== 'owner')) {
        return res.status(403).json({ error: "غير مسموح - للمشرفين فقط" });
      }

      const actions = moderationSystem.getModerationLog()
        .map(action => ({
          ...action,
          moderatorName: '', // سيتم إضافة اسم المشرف
          targetName: '' // سيتم إضافة اسم المستهدف
        }));
      
      // إضافة أسماء المستخدمين للإجراءات
      for (const action of actions) {
        const moderator = await storage.getUser(action.moderatorId);
        const target = await storage.getUser(action.targetUserId);
        action.moderatorName = moderator?.username || 'مجهول';
        action.targetName = target?.username || 'مجهول';
      }

      console.log(`📋 ${user.username} طلب تاريخ الإجراءات - ${actions.length} إجراء`);
      res.json(actions);
    } catch (error) {
      console.error("خطأ في الحصول على تاريخ الإجراءات:", error);
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // إضافة endpoint لسجل البلاغات
  app.get("/api/reports", async (req, res) => {
    try {
      const { userId } = req.query;
      const user = await storage.getUser(Number(userId));
      
      if (!user || (user.userType !== 'admin' && user.userType !== 'owner')) {
        return res.status(403).json({ error: "غير مسموح - للمشرفين فقط" });
      }

      const reports = spamProtection.getPendingReports()
        .concat(spamProtection.getReviewedReports())
        .map(report => ({
          ...report,
          reporterName: '',
          reportedUserName: ''
        }));
      
      // إضافة أسماء المستخدمين للبلاغات
      for (const report of reports) {
        const reporter = await storage.getUser(report.reporterId);
        const reported = await storage.getUser(report.reportedUserId);
        report.reporterName = reporter?.username || 'مجهول';
        report.reportedUserName = reported?.username || 'مجهول';
      }

      console.log(`📋 ${user.username} طلب سجل البلاغات - ${reports.length} بلاغ`);
      res.json(reports);
    } catch (error) {
      console.error("خطأ في الحصول على البلاغات:", error);
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // إضافة endpoint لمراجعة البلاغات
  app.post("/api/reports/:id/review", async (req, res) => {
    try {
      const reportId = parseInt(req.params.id);
      const { action, moderatorId } = req.body;
      
      const user = await storage.getUser(moderatorId);
      if (!user || (user.userType !== 'admin' && user.userType !== 'owner')) {
        return res.status(403).json({ error: "غير مسموح" });
      }

      const success = spamProtection.reviewReport(reportId, action);
      
      if (success) {
        console.log(`📋 ${user.username} راجع البلاغ ${reportId} - ${action}`);
        res.json({ message: "تمت مراجعة البلاغ" });
      } else {
        res.status(404).json({ error: "البلاغ غير موجود" });
      }
    } catch (error) {
      console.error("خطأ في مراجعة البلاغ:", error);
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // إضافة endpoint لترقية المستخدمين
  app.post("/api/moderation/promote", async (req, res) => {
    try {
      const { moderatorId, targetUserId, newRole } = req.body;
      
      const moderator = await storage.getUser(moderatorId);
      const target = await storage.getUser(targetUserId);
      
      if (!moderator || moderator.userType !== 'owner') {
        return res.status(403).json({ error: "فقط المالك يمكنه ترقية المستخدمين" });
      }
      
      if (!target) {
        return res.status(404).json({ error: "المستخدم غير موجود" });
      }
      
      if (target.userType !== 'member') {
        return res.status(400).json({ error: "يمكن ترقية الأعضاء فقط" });
      }
      
      if (!['admin', 'owner'].includes(newRole)) {
        return res.status(400).json({ error: "رتبة غير صالحة" });
      }
      
      // تحديث نوع المستخدم
      await storage.updateUser(targetUserId, { userType: newRole as any });
      
      // إرسال إشعار عبر WebSocket
      const promotionMessage = {
        type: 'systemNotification',
        message: `🎉 تم ترقية ${target.username} إلى ${newRole === 'admin' ? 'مشرف' : 'مالك'} بواسطة ${moderator.username}`,
        timestamp: new Date().toISOString()
      };
      
      broadcast(promotionMessage);
      
      console.log(`👑 ${moderator.username} رقى ${target.username} إلى ${newRole}`);
      res.json({ message: `تم ترقية ${target.username} إلى ${newRole === 'admin' ? 'مشرف' : 'مالك'} بنجاح` });
    } catch (error) {
      console.error("خطأ في ترقية المستخدم:", error);
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // إضافة endpoint للإجراءات النشطة
  app.get("/api/moderation/active-actions", async (req, res) => {
    try {
      const { userId } = req.query;
      const user = await storage.getUser(Number(userId));
      
      if (!user || (user.userType !== 'admin' && user.userType !== 'owner')) {
        return res.status(403).json({ error: "غير مسموح - للمشرفين فقط" });
      }

      const allActions = moderationSystem.getModerationLog();
      const activeActions = allActions
        .filter(action => (action.type === 'mute' || action.type === 'block'))
        .map(action => ({
          ...action,
          moderatorName: '',
          targetName: ''
        }));
      
      // إضافة أسماء المستخدمين
      for (const action of activeActions) {
        const moderator = await storage.getUser(action.moderatorId);
        const target = await storage.getUser(action.targetUserId);
        action.moderatorName = moderator?.username || 'مجهول';
        action.targetName = target?.username || 'مجهول';
      }

      console.log(`📋 ${user.username} طلب الإجراءات النشطة - ${activeActions.length} إجراء`);
      res.json(activeActions);
    } catch (error) {
      console.error("خطأ في الحصول على الإجراءات النشطة:", error);
      res.status(500).json({ error: "خطأ في الخادم" });
    }
  });

  // Security API routes
  app.use('/api/security', securityApiRoutes);
  
  // Performance ping endpoint
  app.get('/api/ping', (req, res) => {
    res.json({ timestamp: Date.now(), status: 'ok' });
  });



  // API routes للإخفاء والتجاهل
  app.post('/api/users/:userId/stealth', async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const { isHidden } = req.body;
      
      await storage.setUserHiddenStatus(userId, isHidden);
      
      res.json({ success: true, message: isHidden ? 'تم إخفاؤك' : 'تم إظهارك' });
    } catch (error) {
      console.error('خطأ في تحديث وضع الإخفاء:', error);
      res.status(500).json({ error: 'فشل في تحديث وضع الإخفاء' });
    }
  });

  app.post('/api/users/:userId/ignore/:targetId', async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const targetId = parseInt(req.params.targetId);
      
      await storage.addIgnoredUser(userId, targetId);
      
      res.json({ success: true, message: 'تم تجاهل المستخدم' });
    } catch (error) {
      console.error('خطأ في تجاهل المستخدم:', error);
      res.status(500).json({ error: 'فشل في تجاهل المستخدم' });
    }
  });

  app.delete('/api/users/:userId/ignore/:targetId', async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const targetId = parseInt(req.params.targetId);
      
      await storage.removeIgnoredUser(userId, targetId);
      
      res.json({ success: true, message: 'تم إلغاء تجاهل المستخدم' });
    } catch (error) {
      console.error('خطأ في إلغاء تجاهل المستخدم:', error);
      res.status(500).json({ error: 'فشل في إلغاء تجاهل المستخدم' });
    }
  });

  app.get('/api/users/:userId/ignored', async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const ignoredUsers = await storage.getIgnoredUsers(userId);
      
      res.json({ ignoredUsers });
    } catch (error) {
      console.error('خطأ في جلب المستخدمين المتجاهلين:', error);
      res.status(500).json({ error: 'فشل في جلب المستخدمين المتجاهلين' });
    }
  });

  // User Update Route with Theme Support
  app.put('/api/users/:id', async (req, res) => {
    try {
      const { id } = req.params;
      const updates = req.body;
      
      console.log('Updating user:', id, 'with updates:', updates);
      
      const user = await storage.updateUser(parseInt(id), updates);
      if (!user) {
        console.log('User not found:', id);
        return res.status(404).json({ error: 'User not found' });
      }
      
      console.log('User updated successfully:', user);
      
      // إرسال تحديث الثيم عبر WebSocket
      if (updates.userTheme) {
        const updateMessage = {
          type: 'theme_update',
          userId: parseInt(id),
          userTheme: updates.userTheme,
          timestamp: new Date().toISOString()
        };
        broadcast(updateMessage);
        console.log('Broadcasting theme update:', updateMessage);
      }
      
      res.json(user);
    } catch (error) {
      console.error('Error updating user:', error);
      res.status(500).json({ error: 'Failed to update user', details: error.message });
    }
  });

  // Notifications API
  app.get("/api/notifications/:userId", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const notifications = await storage.getUserNotifications(userId);
      res.json({ notifications });
    } catch (error) {
      res.status(500).json({ error: "خطأ في جلب الإشعارات" });
    }
  });

  app.post("/api/notifications", async (req, res) => {
    try {
      const { userId, type, title, message, data } = req.body;
      
      const notification = await storage.createNotification({
        userId,
        type,
        title,
        message,
        data
      });
      
      // إرسال إشعار فوري عبر WebSocket
      if (wss) {
        wss.clients.forEach((client: WebSocketClient) => {
          if (client.readyState === WebSocket.OPEN && client.userId === userId) {
            client.send(JSON.stringify({
              type: 'newNotification',
              notification
            }));
          }
        });
      }
      
      res.json({ notification });
    } catch (error) {
      res.status(500).json({ error: "خطأ في إنشاء الإشعار" });
    }
  });

  app.put("/api/notifications/:id/read", async (req, res) => {
    try {
      const notificationId = parseInt(req.params.id);
      const success = await storage.markNotificationAsRead(notificationId);
      res.json({ success });
    } catch (error) {
      res.status(500).json({ error: "خطأ في تحديث الإشعار" });
    }
  });

  app.put("/api/notifications/user/:userId/read-all", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const success = await storage.markAllNotificationsAsRead(userId);
      res.json({ success });
    } catch (error) {
      res.status(500).json({ error: "خطأ في تحديث الإشعارات" });
    }
  });

  app.delete("/api/notifications/:id", async (req, res) => {
    try {
      const notificationId = parseInt(req.params.id);
      const success = await storage.deleteNotification(notificationId);
      res.json({ success });
    } catch (error) {
      res.status(500).json({ error: "خطأ في حذف الإشعار" });
    }
  });

  app.get("/api/notifications/:userId/unread-count", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const count = await storage.getUnreadNotificationCount(userId);
      res.json({ count });
    } catch (error) {
      res.status(500).json({ error: "خطأ في جلب عدد الإشعارات" });
    }
  });

  return httpServer;
}
import type { IStorage } from '../storage';
import type { InsertMessage, Message, User } from '@shared/schema';
import { NotificationService } from './NotificationService';
import { SecurityManager } from '../auth/security';

/**
 * خدمة الرسائل المحسنة مع التحقق والأمان
 */
export class MessageService {
  constructor(private storage: IStorage) {}

  /**
   * إرسال رسالة مع التحقق الأمني
   */
  async sendMessage(senderId: number, messageData: Omit<InsertMessage, 'senderId'>): Promise<{success: boolean, message?: Message, error?: string}> {
    try {
      // التحقق من وجود المرسل
      const sender = await this.storage.getUser(senderId);
      if (!sender) {
        return { success: false, error: 'المرسل غير موجود' };
      }

      // فحص الصلاحيات
      if (!SecurityManager.hasPermission(sender.userType, 'send_message')) {
        return { success: false, error: 'غير مسموح لك بإرسال الرسائل' };
      }

      // التحقق من حالة الحظر/الكتم
      if (sender.isMuted && !messageData.isPrivate) {
        return { success: false, error: 'أنت مكتوم ولا يمكنك إرسال رسائل عامة' };
      }

      if (sender.isBanned) {
        return { success: false, error: 'أنت محظور من المنصة' };
      }

      // التحقق من محتوى الرسالة
      if (!messageData.content || messageData.content.trim().length === 0) {
        return { success: false, error: 'محتوى الرسالة فارغ' };
      }

      if (messageData.content.length > 1000) {
        return { success: false, error: 'الرسالة طويلة جداً (الحد الأقصى 1000 حرف)' };
      }

      // للرسائل الخاصة - التحقق من وجود المستقبل
      if (messageData.isPrivate && messageData.receiverId) {
        const receiver = await this.storage.getUser(messageData.receiverId);
        if (!receiver) {
          return { success: false, error: 'المستقبل غير موجود' };
        }

        // التحقق من التجاهل
        const ignoredUsers = await this.storage.getIgnoredUsers(messageData.receiverId);
        if (ignoredUsers.includes(senderId)) {
          // لا نخبر المرسل أنه مُتجاهل
          return { success: true, message: undefined };
        }
      }

      // إنشاء الرسالة
      const fullMessageData: InsertMessage = {
        ...messageData,
        senderId,
        content: messageData.content.trim(),
        timestamp: new Date()
      };

      const message = await this.storage.createMessage(fullMessageData);

      // إرسال إشعار للرسائل الخاصة
      if (messageData.isPrivate && messageData.receiverId) {
        const notification = await this.storage.createNotification({
          userId: messageData.receiverId,
          type: 'private_message',
          title: 'رسالة خاصة جديدة 💬',
          message: `أرسل ${sender.username} رسالة إليك`,
          data: { 
            messageId: message.id, 
            senderId, 
            senderName: sender.username,
            messagePreview: messageData.content.substring(0, 50) + (messageData.content.length > 50 ? '...' : '')
          }
        });

        // إرسال إشعار فوري
        NotificationService.getInstance().sendNotification(messageData.receiverId, notification);
      }

      return { success: true, message };

    } catch (error) {
      console.error('خطأ في إرسال الرسالة:', error);
      return { success: false, error: 'حدث خطأ في إرسال الرسالة' };
    }
  }

  /**
   * الحصول على الرسائل العامة مع التحقق
   */
  async getPublicMessages(userId: number, limit: number = 50): Promise<{success: boolean, messages?: Message[], error?: string}> {
    try {
      const user = await this.storage.getUser(userId);
      if (!user) {
        return { success: false, error: 'المستخدم غير موجود' };
      }

      if (!SecurityManager.hasPermission(user.userType, 'view_public')) {
        return { success: false, error: 'غير مسموح لك بمشاهدة الرسائل العامة' };
      }

      const messages = await this.storage.getPublicMessages(limit);
      
      // تصفية الرسائل من المستخدمين المُتجاهلين
      const ignoredUsers = await this.storage.getIgnoredUsers(userId);
      const filteredMessages = messages.filter(msg => !ignoredUsers.includes(msg.senderId));

      return { success: true, messages: filteredMessages };

    } catch (error) {
      console.error('خطأ في جلب الرسائل العامة:', error);
      return { success: false, error: 'حدث خطأ في جلب الرسائل' };
    }
  }

  /**
   * الحصول على الرسائل الخاصة مع التحقق
   */
  async getPrivateMessages(userId: number, otherUserId: number, limit: number = 50): Promise<{success: boolean, messages?: Message[], error?: string}> {
    try {
      const user = await this.storage.getUser(userId);
      const otherUser = await this.storage.getUser(otherUserId);
      
      if (!user || !otherUser) {
        return { success: false, error: 'أحد المستخدمين غير موجود' };
      }

      // التحقق من التجاهل
      const ignoredByOther = await this.storage.getIgnoredUsers(otherUserId);
      if (ignoredByOther.includes(userId)) {
        return { success: false, error: 'لا يمكنك مراسلة هذا المستخدم' };
      }

      const messages = await this.storage.getPrivateMessages(userId, otherUserId, limit);
      return { success: true, messages };

    } catch (error) {
      console.error('خطأ في جلب الرسائل الخاصة:', error);
      return { success: false, error: 'حدث خطأ في جلب الرسائل' };
    }
  }

  /**
   * حذف رسالة (للمرسل أو الإدمن)
   */
  async deleteMessage(messageId: number, userId: number): Promise<{success: boolean, error?: string}> {
    try {
      const user = await this.storage.getUser(userId);
      if (!user) {
        return { success: false, error: 'المستخدم غير موجود' };
      }

      // التحقق من الصلاحيات (المرسل الأصلي أو إدمن)
      // هذا سيحتاج إلى تطبيق في storage.ts
      // const message = await this.storage.getMessage(messageId);
      // if (message.senderId !== userId && !SecurityManager.hasPermission(user.userType, 'delete_messages')) {
      //   return { success: false, error: 'غير مسموح لك بحذف هذه الرسالة' };
      // }

      // await this.storage.deleteMessage(messageId);
      return { success: true };

    } catch (error) {
      console.error('خطأ في حذف الرسالة:', error);
      return { success: false, error: 'حدث خطأ في حذف الرسالة' };
    }
  }
}
import { SecurityManager } from '../auth/security';
import type { IStorage } from '../storage';
import type { InsertUser, User } from '@shared/schema';

/**
 * خدمة المصادقة المحسنة مع الأمان
 */
export class AuthService {
  constructor(private storage: IStorage) {}

  /**
   * تسجيل دخول محسن مع التحقق الأمني
   */
  async login(username: string, password: string): Promise<{success: boolean, user?: User, error?: string}> {
    try {
      // التحقق من صحة البيانات
      const usernameValidation = SecurityManager.validateUsername(username);
      if (!usernameValidation.valid) {
        return { success: false, error: usernameValidation.error };
      }

      if (!password || password.trim().length === 0) {
        return { success: false, error: 'كلمة المرور مطلوبة' };
      }

      // البحث عن المستخدم
      const user = await this.storage.getUserByUsername(username.trim());
      if (!user) {
        return { success: false, error: 'اسم المستخدم غير صحيح' };
      }

      // التحقق من كلمة المرور
      let passwordValid = false;
      if (user.userType === 'guest') {
        // الضيوف يستخدمون مقارنة مباشرة
        passwordValid = user.password === password.trim();
      } else {
        // الأعضاء يستخدمون التشفير
        if (user.password) {
          passwordValid = await SecurityManager.verifyPassword(password.trim(), user.password);
        }
      }

      if (!passwordValid) {
        return { success: false, error: 'كلمة المرور غير صحيحة' };
      }

      // تحديث حالة الاتصال
      await this.storage.setUserOnlineStatus(user.id, true);

      // إنشاء إشعار ترحيب
      if (user.userType !== 'guest') {
        await this.storage.createNotification({
          userId: user.id,
          type: 'welcome_back',
          title: '🎉 أهلاً بعودتك',
          message: `مرحباً بك مرة أخرى ${user.username}! نسعد بعودتك إلى المنصة.`,
          data: { loginTime: new Date().toISOString() }
        });
      }

      return { success: true, user };

    } catch (error) {
      console.error('خطأ في تسجيل الدخول:', error);
      return { success: false, error: 'حدث خطأ في الخادم' };
    }
  }

  /**
   * تسجيل مستخدم جديد مع التحقق الأمني
   */
  async register(userData: InsertUser): Promise<{success: boolean, user?: User, error?: string}> {
    try {
      // التحقق من صحة اسم المستخدم
      const usernameValidation = SecurityManager.validateUsername(userData.username);
      if (!usernameValidation.valid) {
        return { success: false, error: usernameValidation.error };
      }

      // التحقق من كلمة المرور للأعضاء
      if (userData.userType !== 'guest' && userData.password) {
        const passwordValidation = SecurityManager.validatePassword(userData.password);
        if (!passwordValidation.valid) {
          return { success: false, error: passwordValidation.error };
        }
      }

      // التحقق من عدم وجود المستخدم مسبقاً
      const existingUser = await this.storage.getUserByUsername(userData.username);
      if (existingUser) {
        return { success: false, error: 'اسم المستخدم موجود مسبقاً' };
      }

      // إنشاء المستخدم
      const newUser = await this.storage.createUser(userData);

      // إنشاء إشعار ترحيب
      await this.storage.createNotification({
        userId: newUser.id,
        type: 'welcome',
        title: '🌟 مرحباً بك في منصة الدردشة العربية',
        message: `أهلاً وسهلاً ${newUser.username}! نتمنى لك تجربة رائعة معنا.`,
        data: { registrationTime: new Date().toISOString() }
      });

      return { success: true, user: newUser };

    } catch (error) {
      console.error('خطأ في التسجيل:', error);
      return { success: false, error: 'حدث خطأ في التسجيل' };
    }
  }

  /**
   * تسجيل خروج آمن
   */
  async logout(userId: number): Promise<{success: boolean, error?: string}> {
    try {
      await this.storage.setUserOnlineStatus(userId, false);
      return { success: true };
    } catch (error) {
      console.error('خطأ في تسجيل الخروج:', error);
      return { success: false, error: 'حدث خطأ في تسجيل الخروج' };
    }
  }

  /**
   * التحقق من الصلاحيات
   */
  hasPermission(user: User, action: string): boolean {
    return SecurityManager.hasPermission(user.userType, action);
  }

  /**
   * التحقق من صحة الجلسة
   */
  isSessionValid(user: User): boolean {
    if (!user.lastSeen) return false;
    return SecurityManager.isSessionValid(user.lastSeen);
  }
}
import type { IStorage } from '../storage';
import { NotificationService } from './NotificationService';

/**
 * خدمة إدارة الأصدقاء - منظمة ومحسنة
 */
export class FriendService {
  constructor(private storage: IStorage) {}
  
  /**
   * إرسال طلب صداقة مع التحقق والإشعارات
   */
  async sendFriendRequest(senderId: number, receiverId: number): Promise<{success: boolean, error?: string, request?: any}> {
    try {
      // التحقق من صحة المعطيات
      if (senderId === receiverId) {
        return { success: false, error: 'لا يمكنك إرسال طلب صداقة لنفسك' };
      }
      
      // التحقق من وجود المستخدمين
      const sender = await this.storage.getUser(senderId);
      const receiver = await this.storage.getUser(receiverId);
      
      if (!sender || !receiver) {
        return { success: false, error: 'المستخدم غير موجود' };
      }
      
      // التحقق من عدم وجود صداقة مسبقة
      const existingFriendship = await this.storage.getFriendship(senderId, receiverId);
      if (existingFriendship) {
        return { success: false, error: 'أنتما أصدقاء بالفعل' };
      }
      
      // التحقق من عدم وجود طلب مسبق
      const existingRequest = await this.storage.getFriendRequest(senderId, receiverId);
      if (existingRequest) {
        return { success: false, error: 'طلب الصداقة مرسل مسبقاً' };
      }
      
      // إنشاء طلب الصداقة
      const request = await this.storage.createFriendRequest(senderId, receiverId);
      
      // إرسال إشعار فوري للمستقبل
      const notification = await this.storage.createNotification({
        userId: receiverId,
        type: 'friend_request',
        title: 'طلب صداقة جديد 👫',
        message: `أرسل ${sender.username} طلب صداقة إليك`,
        data: { requestId: request.id, senderId, senderName: sender.username }
      });
      
      NotificationService.getInstance().sendNotification(receiverId, notification);
      
      return { success: true, request };
      
    } catch (error) {
      console.error('خطأ في إرسال طلب الصداقة:', error);
      return { success: false, error: 'حدث خطأ في إرسال طلب الصداقة' };
    }
  }
  
  /**
   * قبول طلب صداقة مع إشعارات
   */
  async acceptFriendRequest(requestId: number, userId: number): Promise<{success: boolean, error?: string}> {
    try {
      const request = await this.storage.getFriendRequestById(requestId);
      if (!request) {
        return { success: false, error: 'طلب الصداقة غير موجود' };
      }
      
      // التحقق من الصلاحية
      if (request.receiverId !== userId) {
        return { success: false, error: 'غير مسموح لك بقبول هذا الطلب' };
      }
      
      if (request.status !== 'pending') {
        return { success: false, error: 'تم التعامل مع هذا الطلب مسبقاً' };
      }
      
      // قبول الطلب
      await this.storage.acceptFriendRequest(requestId);
      
      // إضافة صداقة متبادلة
      await this.storage.addFriend(request.senderId, request.receiverId);
      await this.storage.addFriend(request.receiverId, request.senderId);
      
      // إشعار للمرسل بالقبول
      const notification = await this.storage.createNotification({
        userId: request.senderId,
        type: 'friend_accepted',
        title: 'تم قبول طلب الصداقة ✅',
        message: `قبل ${request.receiver?.username} طلب صداقتك`,
        data: { friendId: request.receiverId, friendName: request.receiver?.username }
      });
      
      NotificationService.getInstance().sendNotification(request.senderId, notification);
      
      return { success: true };
      
    } catch (error) {
      console.error('خطأ في قبول طلب الصداقة:', error);
      return { success: false, error: 'حدث خطأ في قبول طلب الصداقة' };
    }
  }
  
  /**
   * رفض طلب صداقة
   */
  async declineFriendRequest(requestId: number, userId: number): Promise<{success: boolean, error?: string}> {
    try {
      const request = await this.storage.getFriendRequestById(requestId);
      if (!request) {
        return { success: false, error: 'طلب الصداقة غير موجود' };
      }
      
      if (request.receiverId !== userId) {
        return { success: false, error: 'غير مسموح لك برفض هذا الطلب' };
      }
      
      await this.storage.declineFriendRequest(requestId);
      return { success: true };
      
    } catch (error) {
      console.error('خطأ في رفض طلب الصداقة:', error);
      return { success: false, error: 'حدث خطأ في رفض طلب الصداقة' };
    }
  }
  
  /**
   * إلغاء طلب صداقة مرسل
   */
  async cancelFriendRequest(requestId: number, userId: number): Promise<{success: boolean, error?: string}> {
    try {
      const request = await this.storage.getFriendRequestById(requestId);
      if (!request) {
        return { success: false, error: 'طلب الصداقة غير موجود' };
      }
      
      if (request.senderId !== userId) {
        return { success: false, error: 'غير مسموح لك بإلغاء هذا الطلب' };
      }
      
      await this.storage.deleteFriendRequest(requestId);
      return { success: true };
      
    } catch (error) {
      console.error('خطأ في إلغاء طلب الصداقة:', error);
      return { success: false, error: 'حدث خطأ في إلغاء طلب الصداقة' };
    }
  }
  
  /**
   * حذف صديق مع تأكيد
   */
  async removeFriend(userId: number, friendId: number): Promise<{success: boolean, error?: string}> {
    try {
      const friendship = await this.storage.getFriendship(userId, friendId);
      if (!friendship) {
        return { success: false, error: 'الصداقة غير موجودة' };
      }
      
      const success = await this.storage.removeFriend(userId, friendId);
      if (success) {
        // إشعار للطرف الآخر (اختياري)
        const friend = await this.storage.getUser(friendId);
        const user = await this.storage.getUser(userId);
        
        if (friend && user) {
          const notification = await this.storage.createNotification({
            userId: friendId,
            type: 'friend_removed',
            title: 'تم حذف صديق',
            message: `قام ${user.username} بحذفك من قائمة الأصدقاء`,
            data: { removedBy: userId }
          });
          
          NotificationService.getInstance().sendNotification(friendId, notification);
        }
        
        return { success: true };
      }
      
      return { success: false, error: 'فشل في حذف الصديق' };
      
    } catch (error) {
      console.error('خطأ في حذف الصديق:', error);
      return { success: false, error: 'حدث خطأ في حذف الصديق' };
    }
  }
}
import { Switch, Route } from "wouter";
import { queryClient } from "./lib/queryClient";
import { QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import { TooltipProvider } from "@/components/ui/tooltip";
import { ThemeProvider } from "@/components/ui/theme-provider";
import ChatPage from "@/pages/chat";
import { useEffect, Suspense, lazy } from "react";

// تحسين الأداء العام - تسريع الدخول
function PerformanceOptimizer() {
  useEffect(() => {
    // تحسين التمرير
    const smoothScroll = () => {
      document.documentElement.style.scrollBehavior = 'smooth';
    };
    
    // تحسين الخطوط - تحميل مسبق
    const preloadFonts = () => {
      const link = document.createElement('link');
      link.rel = 'preload';
      link.href = 'https://fonts.googleapis.com/css2?family=Cairo:wght@300;400;500;600;700&display=swap';
      link.as = 'style';
      document.head.appendChild(link);
    };

    // تحسين الصور - تحميل مسبق
    const preloadImages = () => {
      const images = [
        '/default_avatar.svg',
        '/notification.mp3'
      ];
      
      images.forEach(src => {
        const link = document.createElement('link');
        link.rel = 'preload';
        link.href = src;
        link.as = src.endsWith('.mp3') ? 'audio' : 'image';
        document.head.appendChild(link);
      });
    };

    // تحسين الذاكرة
    const optimizeMemory = () => {
      // تنظيف الذاكرة كل 5 دقائق
      setInterval(() => {
        if ('memory' in performance) {
          const memory = (performance as any).memory;
          if (memory.usedJSHeapSize > memory.jsHeapSizeLimit * 0.8) {
            console.log('🧹 تنظيف الذاكرة...');
            // إجبار تنظيف الذاكرة
            if (window.gc) window.gc();
          }
        }
      }, 300000);
    };

    // تحسين الشبكة
    const optimizeNetwork = () => {
      // إعدادات تحسين الشبكة
      if ('connection' in navigator) {
        const connection = (navigator as any).connection;
        if (connection.effectiveType === 'slow-2g' || connection.effectiveType === '2g') {
          // تقليل جودة الصور للاتصالات البطيئة
          document.documentElement.classList.add('slow-connection');
        }
      }
    };

    // تحسين التخزين المؤقت
    const optimizeCache = () => {
      if ('caches' in window) {
        caches.open('arabic-chat-v1').then(cache => {
          // تخزين الملفات المهمة
          cache.addAll([
            '/',
            '/index.html',
            '/default_avatar.svg',
            '/notification.mp3'
          ]);
        });
      }
    };

    // تحسين الأداء العام
    const optimizePerformance = () => {
      // تقليل استخدام CPU
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          // إيقاف العمليات غير الضرورية عند عدم التركيز
          document.body.classList.add('page-hidden');
        } else {
          document.body.classList.remove('page-hidden');
        }
      });

      // تحسين الرسوم المتحركة
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if (prefersReducedMotion) {
        document.documentElement.classList.add('reduce-motion');
      }
    };

    smoothScroll();
    preloadFonts();
    preloadImages();
    optimizeMemory();
    optimizeNetwork();
    optimizeCache();
    optimizePerformance();

    console.log('🚀 تم تحسين الأداء بنجاح');
  }, []);

  return null;
}

// تحسين التحميل - Lazy Loading
const LazyChatPage = lazy(() => import("@/pages/chat"));

// شاشة التحميل المحسنة
function LoadingScreen() {
  return (
    <div className="h-screen flex flex-col justify-center items-center bg-gradient-to-br from-background via-background to-muted animate-pulse">
      <div className="text-center">
        <div className="text-6xl mb-4 animate-bounce">💬</div>
        <h2 className="text-2xl font-bold mb-2 bg-gradient-to-r from-primary to-blue-400 bg-clip-text text-transparent">
          جاري تحميل الدردشة...
        </h2>
        <div className="flex justify-center mt-4">
          <div className="w-8 h-8 border-4 border-primary border-t-transparent rounded-full animate-spin"></div>
        </div>
        <p className="text-sm text-muted-foreground mt-4">يتم تحميل البيانات بسرعة...</p>
      </div>
    </div>
  );
}

function Router() {
  return (
    <Switch>
      <Route path="/" component={LazyChatPage} />
      <Route component={LazyChatPage} />
    </Switch>
  );
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider defaultTheme="dark" storageKey="arabic-chat-theme">
        <TooltipProvider>
          <PerformanceOptimizer />
          <Toaster />
          <Suspense fallback={<LoadingScreen />}>
            <Router />
          </Suspense>
        </TooltipProvider>
      </ThemeProvider>
    </QueryClientProvider>
  );
}

export default App;
import { useState, useEffect } from 'react';
import UserSidebar from './UserSidebar';
import MessageArea from './MessageArea';
import ProfileModal from './ProfileModal';
import PrivateMessageBox from './PrivateMessageBox';
import UserPopup from './UserPopup';
import SettingsMenu from './SettingsMenu';
import ReportModal from './ReportModal';
import AdminReportsPanel from './AdminReportsPanel';
import NotificationPanel from './NotificationPanel';
import FriendsPanel from './FriendsPanelSimple';
import FriendRequestBadge from './FriendRequestBadge';
import MessagesPanel from './MessagesPanel';
import MessageAlert from './MessageAlert';
import ModerationPanel from './ModerationPanel';
import ReportsLog from '../moderation/ReportsLog';
import ActiveModerationLog from '../moderation/ActiveModerationLog';
import KickNotification from '../moderation/KickNotification';
import BlockNotification from '../moderation/BlockNotification';
import PromoteUserPanel from '../moderation/PromoteUserPanel';
import OwnerAdminPanel from './OwnerAdminPanel';
import ProfileImage from './ProfileImage';
import StealthModeToggle from './StealthModeToggle';
import WelcomeNotification from './WelcomeNotification';

import { Button } from '@/components/ui/button';
import { useToast } from '@/hooks/use-toast';
import { apiRequest } from '@/lib/queryClient';
import type { useChat } from '@/hooks/useChat';
import type { ChatUser } from '@/types/chat';

interface ChatInterfaceProps {
  chat: ReturnType<typeof useChat>;
  onLogout: () => void;
}

export default function ChatInterface({ chat, onLogout }: ChatInterfaceProps) {
  const [showProfile, setShowProfile] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  const [selectedPrivateUser, setSelectedPrivateUser] = useState<ChatUser | null>(null);
  const [showReportModal, setShowReportModal] = useState(false);
  const [showAdminReports, setShowAdminReports] = useState(false);

  const [showNotifications, setShowNotifications] = useState(false);
  const [showFriends, setShowFriends] = useState(false);
  const [showMessages, setShowMessages] = useState(false);
  const [showModerationPanel, setShowModerationPanel] = useState(false);
  const [showOwnerPanel, setShowOwnerPanel] = useState(false);
  const [showReportsLog, setShowReportsLog] = useState(false);
  const [showActiveActions, setShowActiveActions] = useState(false);
  const [showPromotePanel, setShowPromotePanel] = useState(false);

  const [newMessageAlert, setNewMessageAlert] = useState<{
    show: boolean;
    sender: ChatUser | null;
  }>({
    show: false,
    sender: null,
  });

  // تفعيل التنبيه عند وصول رسالة جديدة
  useEffect(() => {
    if (chat.newMessageSender) {
      setNewMessageAlert({
        show: true,
        sender: chat.newMessageSender,
      });
    }
  }, [chat.newMessageSender]);
  const [reportedUser, setReportedUser] = useState<ChatUser | null>(null);
  const [reportedMessage, setReportedMessage] = useState<{ content: string; id: number } | null>(null);
  const [userPopup, setUserPopup] = useState<{
    show: boolean;
    user: ChatUser | null;
    x: number;
    y: number;
  }>({
    show: false,
    user: null,
    x: 0,
    y: 0,
  });
  const { toast } = useToast();

  const handleUserClick = (event: React.MouseEvent, user: ChatUser) => {
    event.stopPropagation();
    setUserPopup({
      show: true,
      user,
      x: event.clientX,
      y: event.clientY,
    });
  };

  const closeUserPopup = () => {
    setUserPopup(prev => ({ ...prev, show: false }));
  };

  const handlePrivateMessage = (user: ChatUser) => {
    setSelectedPrivateUser(user);
    closeUserPopup();
  };

  const closePrivateMessage = () => {
    setSelectedPrivateUser(null);
  };

  const handleAddFriend = async (user: ChatUser) => {
    if (!chat.currentUser) return;
    
    try {
      console.log('Sending friend request:', { senderId: chat.currentUser.id, receiverId: user.id });
      
      const response = await apiRequest('/api/friend-requests', {
        method: 'POST',
        body: {
          senderId: chat.currentUser.id,
          receiverId: user.id,
        }
      });
      
      console.log('Friend request response:', response);
      
      toast({
        title: "تمت الإضافة",
        description: `تم إرسال طلب صداقة إلى ${user.username}`,
      });
    } catch (error) {
      console.error('Friend request error:', error);
      toast({
        title: "خطأ",
        description: error instanceof Error ? error.message : "لم نتمكن من إرسال طلب الصداقة",
        variant: "destructive",
      });
    }
    closeUserPopup();
  };

  const handleIgnoreUser = (user: ChatUser) => {
    chat.ignoreUser(user.id);
    toast({
      title: "تم التجاهل",
      description: `تم تجاهل المستخدم ${user.username} - لن ترى رسائله بعد الآن`,
    });
    closeUserPopup();
  };



  const handleViewProfile = (user: ChatUser) => {
    setShowProfile(true);
    setSelectedPrivateUser(user);
    closeUserPopup();
  };

  const handleReportUser = (user: ChatUser, messageContent?: string, messageId?: number) => {
    setReportedUser(user);
    setReportedMessage(messageContent && messageId ? { content: messageContent, id: messageId } : null);
    setShowReportModal(true);
    closeUserPopup();
  };

  const closeReportModal = () => {
    setShowReportModal(false);
    setReportedUser(null);
    setReportedMessage(null);
  };

  return (
    <div className="h-screen flex flex-col bg-gradient-to-br from-slate-900 via-blue-900 to-slate-900" onClick={closeUserPopup}>
      {/* Header - محسن */}
      <header className="bg-gradient-to-r from-slate-800/90 to-blue-800/90 backdrop-blur-xl py-4 px-6 flex justify-between items-center shadow-2xl border-b border-blue-500/30 relative overflow-hidden">
        {/* تأثير خلفية متحرك */}
        <div className="absolute inset-0 bg-gradient-to-r from-blue-500/10 via-purple-500/10 to-pink-500/10 animate-pulse"></div>
        
        <div className="flex items-center gap-3 relative z-10">
          <div className="text-3xl animate-bounce">💬</div>
          <div className="text-2xl font-bold text-white">
            <span className="bg-gradient-to-r from-blue-400 to-purple-400 bg-clip-text text-transparent">
              Arabic
            </span>
            <span className="text-primary ml-2">Chat</span>
          </div>
        </div>
        
        <div className="flex gap-3 relative z-10">
          <Button 
            className="bg-gradient-to-r from-blue-500/20 to-purple-500/20 backdrop-blur-md px-4 py-2 rounded-xl hover:from-blue-500/30 hover:to-purple-500/30 transition-all duration-300 flex items-center gap-2 relative border border-blue-400/30 hover:border-blue-400/50 hover:scale-105"
            onClick={() => setShowNotifications(true)}
          >
            <span className="text-lg">🔔</span>
            <span className="font-semibold">إشعارات</span>
          </Button>
          
          <Button 
            className="bg-gradient-to-r from-green-500/20 to-emerald-500/20 backdrop-blur-md px-4 py-2 rounded-xl hover:from-green-500/30 hover:to-emerald-500/30 transition-all duration-300 flex items-center gap-2 relative border border-green-400/30 hover:border-green-400/50 hover:scale-105"
            onClick={() => setShowFriends(true)}
          >
            <span className="text-lg">👥</span>
            <span className="font-semibold">الأصدقاء</span>
            {/* تنبيه طلبات الصداقة */}
            <FriendRequestBadge currentUser={chat.currentUser} />
          </Button>

          <Button 
            className="bg-gradient-to-r from-purple-500/20 to-pink-500/20 backdrop-blur-md px-4 py-2 rounded-xl hover:from-purple-500/30 hover:to-pink-500/30 transition-all duration-300 flex items-center gap-2 border border-purple-400/30 hover:border-purple-400/50 hover:scale-105"
            onClick={() => setShowMessages(true)}
            title="الرسائل"
          >
            <span>✉️</span>
            الرسائل
          </Button>
          
          {/* زر لوحة الإدارة للمشرفين */}
          {chat.currentUser && (chat.currentUser.userType === 'owner' || chat.currentUser.userType === 'admin') && (
            <>
              <Button 
                className="glass-effect px-4 py-2 rounded-lg hover:bg-accent transition-all duration-200 flex items-center gap-2"
                onClick={() => setShowModerationPanel(true)}
              >
                <span>🛡️</span>
                إدارة
              </Button>
              
              <StealthModeToggle currentUser={chat.currentUser} />
              
              <Button 
                className="glass-effect px-4 py-2 rounded-lg hover:bg-red-600 transition-all duration-200 flex items-center gap-2 border border-red-400 relative"
                onClick={() => setShowReportsLog(true)}
              >
                <span>⚠️</span>
                سجل البلاغات
              </Button>
              
              <Button 
                className="glass-effect px-4 py-2 rounded-lg hover:bg-yellow-600 transition-all duration-200 flex items-center gap-2 border border-yellow-400"
                onClick={() => setShowActiveActions(true)}
              >
                <span>🔒</span>
                سجل الإجراءات النشطة
              </Button>

              {/* زر ترقية المستخدمين - للمالك فقط */}
              {chat.currentUser?.userType === 'owner' && (
                <Button 
                  className="glass-effect px-4 py-2 rounded-lg hover:bg-blue-600 transition-all duration-200 flex items-center gap-2"
                  onClick={() => setShowPromotePanel(true)}
                >
                  <span>👑</span>
                  ترقية المستخدمين
                </Button>
              )}
            </>
          )}

          {/* زر خاص بالمالك فقط */}
          {chat.currentUser && chat.currentUser.userType === 'owner' && (
            <Button 
              className="glass-effect px-4 py-2 rounded-lg hover:bg-purple-600 transition-all duration-200 flex items-center gap-2 border border-purple-400"
              onClick={() => setShowOwnerPanel(true)}
            >
              <span>👑</span>
              إدارة المالك
            </Button>
          )}
          
          <Button 
            className="glass-effect px-4 py-2 rounded-lg hover:bg-accent transition-all duration-200 flex items-center gap-2"
            onClick={() => setShowSettings(!showSettings)}
          >
            <span>⚙️</span>
            إعدادات
          </Button>


        </div>
      </header>
      
      {/* Main Content */}
      <main className="flex flex-1 overflow-hidden">
        <UserSidebar 
          users={chat.onlineUsers}
          onUserClick={handleUserClick}
          currentUser={chat.currentUser}
        />
        <MessageArea 
          messages={chat.publicMessages}
          currentUser={chat.currentUser}
          onSendMessage={chat.sendPublicMessage}
          onTyping={chat.handleTyping}
          typingUsers={chat.typingUsers}
          onReportMessage={handleReportUser}
          onUserClick={handleUserClick}
        />
      </main>

      {/* Modals and Popups */}
      {showProfile && (
        <ProfileModal 
          user={selectedPrivateUser || chat.currentUser}
          currentUser={chat.currentUser}
          onClose={() => {
            setShowProfile(false);
            if (selectedPrivateUser) setSelectedPrivateUser(null);
          }}
          onIgnoreUser={(userId) => {
            chat.ignoreUser(userId);
          }}
        />
      )}

      {selectedPrivateUser && (
        <PrivateMessageBox
          isOpen={!!selectedPrivateUser}
          user={selectedPrivateUser}
          currentUser={chat.currentUser}
          messages={chat.privateConversations[selectedPrivateUser.id] || []}
          onSendMessage={(content) => chat.sendPrivateMessage(selectedPrivateUser.id, content)}
          onClose={closePrivateMessage}
        />
      )}

      {userPopup.show && userPopup.user && (
        <UserPopup
          user={userPopup.user}
          x={userPopup.x}
          y={userPopup.y}
          onPrivateMessage={() => handlePrivateMessage(userPopup.user!)}
          onAddFriend={() => handleAddFriend(userPopup.user!)}
          onIgnore={() => {
            // إزالة زر التجاهل من UserPopup - الآن في الملف الشخصي فقط
          }}
          onViewProfile={() => handleViewProfile(userPopup.user!)}
          currentUser={chat.currentUser}
          onClose={closeUserPopup}
        />
      )}

      {showSettings && (
        <SettingsMenu
          onOpenProfile={() => {
            setShowProfile(true);
            setShowSettings(false);
          }}
          onLogout={onLogout}
          onClose={() => setShowSettings(false)}
          onOpenReports={() => {
            setShowAdminReports(true);
            setShowSettings(false);
          }}
          currentUser={chat.currentUser}
        />
      )}

      {showReportModal && (
        <ReportModal
          isOpen={showReportModal}
          onClose={closeReportModal}
          reportedUser={reportedUser}
          currentUser={chat.currentUser}
          messageContent={reportedMessage?.content}
          messageId={reportedMessage?.id}
        />
      )}

      {showNotifications && (
        <NotificationPanel
          isOpen={showNotifications}
          onClose={() => setShowNotifications(false)}
          currentUser={chat.currentUser}
        />
      )}

      {/* Admin Reports Panel */}
      {showAdminReports && chat.currentUser && chat.currentUser.userType === 'owner' && (
        <AdminReportsPanel
          isOpen={showAdminReports}
          onClose={() => setShowAdminReports(false)}
          currentUser={chat.currentUser}
        />
      )}

      {showFriends && (
        <FriendsPanel
          isOpen={showFriends}
          onClose={() => setShowFriends(false)}
          currentUser={chat.currentUser}
          onlineUsers={chat.onlineUsers}
          onStartPrivateChat={(friend) => {
            setSelectedPrivateUser(friend);
            setShowFriends(false);
          }}
        />
      )}

      {showMessages && (
        <MessagesPanel
          isOpen={showMessages}
          onClose={() => setShowMessages(false)}
          currentUser={chat.currentUser}
          privateConversations={chat.privateConversations}
          onlineUsers={chat.onlineUsers}
          onStartPrivateChat={(user) => {
            setSelectedPrivateUser(user);
            setShowMessages(false);
          }}
        />
      )}

      {showModerationPanel && (
        <ModerationPanel
          isOpen={showModerationPanel}
          onClose={() => setShowModerationPanel(false)}
          currentUser={chat.currentUser}
          onlineUsers={chat.onlineUsers}
        />
      )}

      {showOwnerPanel && (
        <OwnerAdminPanel 
          isOpen={showOwnerPanel}
          onClose={() => setShowOwnerPanel(false)}
          currentUser={chat.currentUser}
          onlineUsers={chat.onlineUsers}
        />
      )}

      {showModerationPanel && (
        <ModerationPanel 
          isOpen={showModerationPanel}
          onClose={() => setShowModerationPanel(false)}
          currentUser={chat.currentUser}
          onlineUsers={chat.onlineUsers}
        />
      )}

      {showReportsLog && (
        <ReportsLog 
          isVisible={showReportsLog}
          onClose={() => setShowReportsLog(false)}
          currentUser={chat.currentUser}
        />
      )}

      {showActiveActions && (
        <ActiveModerationLog 
          isVisible={showActiveActions}
          onClose={() => setShowActiveActions(false)}
          currentUser={chat.currentUser}
        />
      )}

      {showPromotePanel && (
        <PromoteUserPanel 
          isVisible={showPromotePanel}
          onClose={() => setShowPromotePanel(false)}
          currentUser={chat.currentUser}
          onlineUsers={chat.onlineUsers}
        />
      )}

      {/* إشعارات الطرد والحجب */}
      <KickNotification
        isVisible={chat.kickNotification?.show || false}
        durationMinutes={chat.kickNotification?.duration || 15}
        onClose={() => {}}
      />
      
      <BlockNotification
        isVisible={chat.blockNotification?.show || false}
        reason={chat.blockNotification?.reason || ''}
        onClose={() => {}}
      />

      {/* تنبيه الرسائل الجديدة */}
      <MessageAlert
        isOpen={newMessageAlert.show}
        sender={newMessageAlert.sender}
        onClose={() => setNewMessageAlert({ show: false, sender: null })}
        onOpenMessages={() => setShowMessages(true)}
      />

      {/* إشعار الترحيب */}
      {chat.currentUser && <WelcomeNotification user={chat.currentUser} />}

    </div>
  );
}

import { useState, useCallback, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { UserPlus, Loader2, Zap, Shield, Users } from 'lucide-react';
import { apiRequest } from '@/lib/queryClient';
import { useToast } from '@/hooks/use-toast';
import UserRegistration from './UserRegistration';
import type { ChatUser } from '@/types/chat';

interface WelcomeScreenProps {
  onUserLogin: (user: ChatUser) => void;
}

export default function WelcomeScreen({ onUserLogin }: WelcomeScreenProps) {
  const [showGuestModal, setShowGuestModal] = useState(false);
  const [showMemberModal, setShowMemberModal] = useState(false);
  const [showRegisterModal, setShowRegisterModal] = useState(false);
  const [guestName, setGuestName] = useState('');
  const [guestGender, setGuestGender] = useState('male');
  const [memberName, setMemberName] = useState('');
  const [memberPassword, setMemberPassword] = useState('');
  const [registerName, setRegisterName] = useState('');
  const [registerPassword, setRegisterPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [registerGender, setRegisterGender] = useState('male');
  const [loading, setLoading] = useState(false);
  const [isPreloading, setIsPreloading] = useState(true);
  const { toast } = useToast();

  // تحسين التحميل المسبق
  useEffect(() => {
    const preloadResources = async () => {
      try {
        // تحميل الملفات المهمة مسبقاً
        const resources = [
          '/default_avatar.svg',
          '/notification.mp3'
        ];

        await Promise.allSettled(
          resources.map(resource => {
            if (resource.endsWith('.mp3')) {
              return new Promise((resolve) => {
                const audio = new Audio(resource);
                audio.preload = 'metadata';
                audio.onloadedmetadata = resolve;
                audio.onerror = resolve;
              });
            } else {
              return new Promise((resolve) => {
                const img = new Image();
                img.onload = resolve;
                img.onerror = resolve;
                img.src = resource;
              });
            }
          })
        );

        // تحميل البيانات الأساسية مسبقاً
        await Promise.allSettled([
          fetch('/api/users').catch(() => {}),
          fetch('/api/messages/public').catch(() => {})
        ]);

        console.log('🚀 تم التحميل المسبق بنجاح');
      } catch (error) {
        console.log('⚠️ خطأ في التحميل المسبق:', error);
      } finally {
        setIsPreloading(false);
      }
    };

    preloadResources();
  }, []);

  // تحسين تسجيل دخول الزائر
  const handleGuestLogin = useCallback(async () => {
    if (!guestName.trim()) {
      toast({
        title: "خطأ",
        description: "يرجى إدخال اسم الزائر",
        variant: "destructive",
      });
      return;
    }

    setLoading(true);
    try {
      const data = await apiRequest('/api/auth/guest', {
        method: 'POST',
        body: {
          username: guestName.trim(),
          gender: guestGender,
        }
      });
      
      toast({
        title: "مرحباً! 👋",
        description: `تم تسجيل دخولك كزائر بنجاح`,
      });
      
      onUserLogin(data.user);
      setShowGuestModal(false);
    } catch (error: any) {
      toast({
        title: "خطأ",
        description: error.message || "حدث خطأ في تسجيل الدخول",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  }, [guestName, guestGender, onUserLogin, toast]);

  // تحسين تسجيل دخول العضو
  const handleMemberLogin = useCallback(async () => {
    if (!memberName.trim() || !memberPassword.trim()) {
      toast({
        title: "خطأ",
        description: "يرجى إدخال اسم المستخدم وكلمة المرور",
        variant: "destructive",
      });
      return;
    }

    setLoading(true);
    try {
      const data = await apiRequest('/api/auth/member', {
        method: 'POST',
        body: {
          username: memberName.trim(),
          password: memberPassword.trim(),
        }
      });
      
      toast({
        title: "مرحباً بعودتك! 🎉",
        description: `تم تسجيل دخولك بنجاح`,
      });
      
      onUserLogin(data.user);
      setShowMemberModal(false);
    } catch (error: any) {
      toast({
        title: "خطأ",
        description: error.message || "حدث خطأ في تسجيل الدخول",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  }, [memberName, memberPassword, onUserLogin, toast]);

  // تحسين التسجيل
  const handleRegister = useCallback(async () => {
    if (!registerName.trim() || !registerPassword.trim() || !confirmPassword.trim()) {
      toast({
        title: "خطأ",
        description: "يرجى ملء جميع الحقول",
        variant: "destructive",
      });
      return;
    }

    if (registerPassword !== confirmPassword) {
      toast({
        title: "خطأ",
        description: "كلمات المرور غير متطابقة",
        variant: "destructive",
      });
      return;
    }

    if (registerPassword.length < 6) {
      toast({
        title: "خطأ",
        description: "كلمة المرور يجب أن تكون 6 أحرف على الأقل",
        variant: "destructive",
      });
      return;
    }

    setLoading(true);
    try {
      const data = await apiRequest('/api/auth/register', {
        method: 'POST',
        body: {
          username: registerName.trim(),
          password: registerPassword.trim(),
          confirmPassword: confirmPassword.trim(),
          gender: registerGender,
        }
      });
      
      toast({
        title: "أهلاً وسهلاً! 🎊",
        description: "تم إنشاء حسابك بنجاح",
      });
      
      onUserLogin(data.user);
      setShowRegisterModal(false);
    } catch (error: any) {
      toast({
        title: "خطأ",
        description: error.message || "حدث خطأ في التسجيل",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  }, [registerName, registerPassword, confirmPassword, registerGender, onUserLogin, toast]);

  const handleGoogleLogin = useCallback(() => {
    toast({
      title: "قريباً",
      description: "🔄 جاري تطوير خدمة تسجيل الدخول بـ Google",
    });
  }, [toast]);

  // تحسين الأداء - حفظ البيانات في localStorage
  const saveToLocalStorage = useCallback((key: string, data: any) => {
    try {
      localStorage.setItem(key, JSON.stringify(data));
    } catch (error) {
      console.log('خطأ في حفظ البيانات المحلية:', error);
    }
  }, []);

  const loadFromLocalStorage = useCallback((key: string) => {
    try {
      const data = localStorage.getItem(key);
      return data ? JSON.parse(data) : null;
    } catch (error) {
      console.log('خطأ في تحميل البيانات المحلية:', error);
      return null;
    }
  }, []);

  // تحميل البيانات المحفوظة
  useEffect(() => {
    const savedGuestName = loadFromLocalStorage('guestName');
    const savedMemberName = loadFromLocalStorage('memberName');
    
    if (savedGuestName) setGuestName(savedGuestName);
    if (savedMemberName) setMemberName(savedMemberName);
  }, [loadFromLocalStorage]);

  // حفظ البيانات عند التغيير
  useEffect(() => {
    if (guestName) saveToLocalStorage('guestName', guestName);
  }, [guestName, saveToLocalStorage]);

  useEffect(() => {
    if (memberName) saveToLocalStorage('memberName', memberName);
  }, [memberName, saveToLocalStorage]);

  if (isPreloading) {
    return (
      <div className="h-screen flex flex-col justify-center items-center welcome-gradient">
        <div className="text-center animate-pulse">
          <div className="text-6xl mb-4 animate-bounce">💬</div>
          <h2 className="text-2xl font-bold mb-2 bg-gradient-to-r from-primary to-blue-400 bg-clip-text text-transparent">
            جاري تحضير الدردشة...
          </h2>
          <div className="flex justify-center mt-4">
            <Loader2 className="w-8 h-8 animate-spin text-primary" />
          </div>
          <p className="text-sm text-muted-foreground mt-4">يتم تحميل الموارد بسرعة...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="h-screen flex flex-col justify-center items-center welcome-gradient">
      <div className="text-center animate-slide-up">
        <div className="mb-8">
          <div className="text-6xl mb-4 animate-pulse-slow">💬</div>
          <h1 className="text-5xl font-bold mb-4 bg-gradient-to-r from-primary to-blue-400 bg-clip-text text-transparent">
            مرحبًا بك في دردشة العرب
          </h1>
          <p className="text-xl text-muted-foreground mb-8">منصة التواصل العربية الأولى</p>
          
          {/* إضافة معلومات الأداء */}
          <div className="flex justify-center gap-4 mb-6 text-sm text-muted-foreground">
            <div className="flex items-center gap-1">
              <Zap className="w-4 h-4 text-green-500" />
              <span>سريع</span>
            </div>
            <div className="flex items-center gap-1">
              <Shield className="w-4 h-4 text-blue-500" />
              <span>آمن</span>
            </div>
            <div className="flex items-center gap-1">
              <Users className="w-4 h-4 text-purple-500" />
              <span>مجتمعي</span>
            </div>
          </div>
        </div>
        
        <div className="flex flex-col sm:flex-row gap-4 justify-center items-center">
          <Button 
            className="btn-success text-white font-semibold py-3 px-8 rounded-xl shadow-lg flex items-center gap-3 hover:scale-105 transition-all duration-200"
            onClick={() => setShowGuestModal(true)}
            disabled={loading}
          >
            <span>👤</span>
            دخول كزائر
          </Button>
          
          <Button 
            className="btn-primary text-white font-semibold py-3 px-8 rounded-xl shadow-lg flex items-center gap-3 hover:scale-105 transition-all duration-200"
            onClick={() => setShowMemberModal(true)}
            disabled={loading}
          >
            <span>✅</span>
            دخول كعضو
          </Button>
          
          <Button 
            className="bg-gradient-to-r from-purple-600 to-purple-700 hover:from-purple-700 hover:to-purple-800 text-white font-semibold py-3 px-8 rounded-xl shadow-lg flex items-center gap-3 transition-all duration-300 hover:scale-105"
            onClick={() => setShowRegisterModal(true)}
            disabled={loading}
          >
            <span>📝</span>
            تسجيل عضوية جديدة
          </Button>
          
          <Button 
            className="btn-danger text-white font-semibold py-3 px-8 rounded-xl shadow-lg flex items-center gap-3 hover:scale-105 transition-all duration-200"
            onClick={handleGoogleLogin}
            disabled={loading}
          >
            <span>🔐</span>
            دخول بـ Google
          </Button>
        </div>
      </div>

      {/* Guest Name Modal */}
      <Dialog open={showGuestModal} onOpenChange={setShowGuestModal}>
        <DialogContent className="glass-effect border border-border animate-fade-in">
          <DialogHeader>
            <DialogTitle className="text-center text-2xl font-bold text-white flex items-center justify-center gap-2">
              <span>📝</span>
              أدخل اسم الزائر
            </DialogTitle>
          </DialogHeader>
          
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-white mb-2">اسم الزائر</label>
              <Input
                type="text"
                placeholder="أدخل اسمك"
                value={guestName}
                onChange={(e) => setGuestName(e.target.value)}
                className="glass-input"
                disabled={loading}
                onKeyPress={(e) => e.key === 'Enter' && handleGuestLogin()}
              />
            </div>
            
            <div>
              <label className="block text-sm font-medium text-white mb-2">الجنس</label>
              <select
                value={guestGender}
                onChange={(e) => setGuestGender(e.target.value)}
                className="w-full p-3 rounded-lg bg-white/10 border border-white/20 text-white"
                disabled={loading}
              >
                <option value="male">ذكر</option>
                <option value="female">أنثى</option>
              </select>
            </div>
            
            <Button
              onClick={handleGuestLogin}
              disabled={loading || !guestName.trim()}
              className="w-full btn-success text-white font-semibold py-3 rounded-xl"
            >
              {loading ? (
                <>
                  <Loader2 className="w-4 h-4 animate-spin mr-2" />
                  جاري الدخول...
                </>
              ) : (
                <>
                  <span>🚀</span>
                  دخول سريع
                </>
              )}
            </Button>
          </div>
        </DialogContent>
      </Dialog>

      {/* Member Login Modal */}
      <Dialog open={showMemberModal} onOpenChange={setShowMemberModal}>
        <DialogContent className="glass-effect border border-border animate-fade-in">
          <DialogHeader>
            <DialogTitle className="text-center text-2xl font-bold text-white flex items-center justify-center gap-2">
              <span>✅</span>
              دخول العضو
            </DialogTitle>
          </DialogHeader>
          
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-white mb-2">اسم المستخدم</label>
              <Input
                type="text"
                placeholder="أدخل اسم المستخدم"
                value={memberName}
                onChange={(e) => setMemberName(e.target.value)}
                className="glass-input"
                disabled={loading}
                onKeyPress={(e) => e.key === 'Enter' && handleMemberLogin()}
              />
            </div>
            
            <div>
              <label className="block text-sm font-medium text-white mb-2">كلمة المرور</label>
              <Input
                type="password"
                placeholder="أدخل كلمة المرور"
                value={memberPassword}
                onChange={(e) => setMemberPassword(e.target.value)}
                className="glass-input"
                disabled={loading}
                onKeyPress={(e) => e.key === 'Enter' && handleMemberLogin()}
              />
            </div>
            
            <Button
              onClick={handleMemberLogin}
              disabled={loading || !memberName.trim() || !memberPassword.trim()}
              className="w-full btn-primary text-white font-semibold py-3 rounded-xl"
            >
              {loading ? (
                <>
                  <Loader2 className="w-4 h-4 animate-spin mr-2" />
                  جاري التحقق...
                </>
              ) : (
                <>
                  <span>🔐</span>
                  تسجيل الدخول
                </>
              )}
            </Button>
          </div>
        </DialogContent>
      </Dialog>

      {/* Register Modal */}
      <Dialog open={showRegisterModal} onOpenChange={setShowRegisterModal}>
        <DialogContent className="glass-effect border border-border animate-fade-in max-w-md">
          <DialogHeader>
            <DialogTitle className="text-center text-2xl font-bold text-white flex items-center justify-center gap-2">
              <UserPlus className="w-6 h-6" />
              تسجيل عضوية جديدة
            </DialogTitle>
          </DialogHeader>
          
          <UserRegistration
            onRegister={handleRegister}
            loading={loading}
            name={registerName}
            setName={setRegisterName}
            password={registerPassword}
            setPassword={setRegisterPassword}
            confirmPassword={confirmPassword}
            setConfirmPassword={setConfirmPassword}
            gender={registerGender}
            setGender={setRegisterGender}
          />
        </DialogContent>
      </Dialog>
    </div>
  );
}

import { useState, useEffect, useRef, useCallback } from 'react';
import type { ChatUser, ChatMessage } from '@/types/chat';

interface CleanChatHook {
  // State
  user: ChatUser | null;
  users: ChatUser[];
  messages: ChatMessage[];
  friends: ChatUser[];
  friendRequests: any[];
  notifications: any[];
  isConnected: boolean;
  
  // Actions
  connect: (user: ChatUser) => void;
  disconnect: () => void;
  sendMessage: (content: string, recipientId?: number) => void;
  sendFriendRequest: (targetUserId: number) => void;
  acceptFriendRequest: (senderId: number) => void;
  declineFriendRequest: (senderId: number) => void;
  removeFriend: (friendId: number) => void;
  
  // UI State
  isTyping: boolean;
  setIsTyping: (typing: boolean) => void;
  
  // Performance State
  isLoading: boolean;
  connectionStatus: 'connecting' | 'connected' | 'disconnected' | 'error';
}

export function useCleanChat(): CleanChatHook {
  const [user, setUser] = useState<ChatUser | null>(null);
  const [users, setUsers] = useState<ChatUser[]>([]);
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [friends, setFriends] = useState<ChatUser[]>([]);
  const [friendRequests, setFriendRequests] = useState<any[]>([]);
  const [notifications, setNotifications] = useState<any[]>([]);
  const [isConnected, setIsConnected] = useState(false);
  const [isTyping, setIsTyping] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState<'connecting' | 'connected' | 'disconnected' | 'error'>('disconnected');
  
  const wsRef = useRef<WebSocket | null>(null);
  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const dataCacheRef = useRef<Map<string, any>>(new Map());

  // تحسين API calls مع التخزين المؤقت
  const apiRequest = useCallback(async (url: string, options: RequestInit = {}, useCache = false) => {
    const cacheKey = `${url}-${JSON.stringify(options)}`;
    
    // التحقق من التخزين المؤقت
    if (useCache && dataCacheRef.current.has(cacheKey)) {
      const cachedData = dataCacheRef.current.get(cacheKey);
      const cacheAge = Date.now() - cachedData.timestamp;
      
      // استخدام التخزين المؤقت إذا كان عمره أقل من 30 ثانية
      if (cacheAge < 30000) {
        return cachedData.data;
      }
    }

    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000); // timeout 10 ثواني

      const response = await fetch(url, {
        headers: {
          'Content-Type': 'application/json',
          ...options.headers
        },
        signal: controller.signal,
        ...options
      });
      
      clearTimeout(timeoutId);
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'خطأ في الخادم' }));
        throw new Error(errorData.error || 'خطأ في الخادم');
      }
      
      const data = await response.json();
      
      // حفظ في التخزين المؤقت
      if (useCache) {
        dataCacheRef.current.set(cacheKey, {
          data,
          timestamp: Date.now()
        });
      }
      
      return data;
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        throw new Error('انتهت مهلة الاتصال');
      }
      throw error;
    }
  }, []);

  // تحسين WebSocket connection مع إعادة الاتصال التلقائي
  const connectWebSocket = useCallback((userData: ChatUser) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.close();
    }

    setConnectionStatus('connecting');
    const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
    const wsUrl = `${protocol}//${window.location.host}/ws`;
    
    wsRef.current = new WebSocket(wsUrl);
    
    // تحسين إعدادات WebSocket
    wsRef.current.binaryType = 'arraybuffer';
    
    wsRef.current.onopen = () => {
      console.log('🔗 WebSocket connected');
      setIsConnected(true);
      setConnectionStatus('connected');
      
      // إرسال بيانات المصادقة فوراً
      wsRef.current?.send(JSON.stringify({
        type: 'authenticate',
        userId: userData.id,
        username: userData.username,
        timestamp: Date.now()
      }));
    };
    
    wsRef.current.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        handleWebSocketMessage(data);
      } catch (error) {
        console.error('WebSocket message error:', error);
      }
    };
    
    wsRef.current.onclose = (event) => {
      console.log('🔌 WebSocket disconnected:', event.code, event.reason);
      setIsConnected(false);
      setConnectionStatus('disconnected');
      
      // إعادة الاتصال التلقائي إذا لم يكن الإغلاق مقصوداً
      if (event.code !== 1000 && user) {
        console.log('🔄 محاولة إعادة الاتصال...');
        setConnectionStatus('connecting');
        
        if (reconnectTimeoutRef.current) {
          clearTimeout(reconnectTimeoutRef.current);
        }
        
        reconnectTimeoutRef.current = setTimeout(() => {
          if (user) {
            connectWebSocket(user);
          }
        }, 3000);
      }
    };
    
    wsRef.current.onerror = (error) => {
      console.error('WebSocket error:', error);
      setIsConnected(false);
      setConnectionStatus('error');
    };
  }, [user]);

  const handleWebSocketMessage = useCallback((data: any) => {
    switch (data.type) {
      case 'newMessage':
        setMessages(prev => {
          // تجنب تكرار الرسائل
          if (prev.some(msg => msg.id === data.message.id)) {
            return prev;
          }
          return [...prev, data.message];
        });
        break;
        
      case 'userOnline':
        setUsers(prev => prev.map(u => 
          u.id === data.userId ? { ...u, isOnline: true, lastSeen: new Date().toISOString() } : u
        ));
        break;
        
      case 'userOffline':
        setUsers(prev => prev.map(u => 
          u.id === data.userId ? { ...u, isOnline: false, lastSeen: data.lastSeen || new Date().toISOString() } : u
        ));
        break;
        
      case 'friendRequest':
        loadFriendRequests();
        loadNotifications();
        break;
        
      case 'friendshipAccepted':
        loadFriends();
        break;
        
      case 'friendRemoved':
        loadFriends();
        break;
        
      case 'userUpdated':
        setUsers(prev => prev.map(u => 
          u.id === data.user.id ? { ...u, ...data.user } : u
        ));
        break;
        
      case 'typing':
        // تحسين مؤشر الكتابة
        if (data.userId !== user?.id) {
          setUsers(prev => prev.map(u => 
            u.id === data.userId ? { ...u, isTyping: data.isTyping } : u
          ));
        }
        break;
    }
  }, [user]);

  // تحسين تحميل البيانات مع التحميل المتوازي
  const loadUsers = useCallback(async () => {
    try {
      const data = await apiRequest('/api/users', {}, true);
      setUsers(data.users || []);
    } catch (error) {
      console.error('Error loading users:', error);
    }
  }, [apiRequest]);

  const loadMessages = useCallback(async () => {
    try {
      const data = await apiRequest('/api/messages/public', {}, true);
      setMessages(data.messages || []);
    } catch (error) {
      console.error('Error loading messages:', error);
    }
  }, [apiRequest]);

  const loadFriends = useCallback(async () => {
    if (!user) return;
    try {
      const data = await apiRequest(`/api/friends/${user.id}`, {}, true);
      setFriends(data.friends || []);
    } catch (error) {
      console.error('Error loading friends:', error);
    }
  }, [apiRequest, user]);

  const loadFriendRequests = useCallback(async () => {
    if (!user) return;
    try {
      const data = await apiRequest(`/api/friend-requests/${user.id}`, {}, true);
      setFriendRequests(data.requests || []);
    } catch (error) {
      console.error('Error loading friend requests:', error);
    }
  }, [apiRequest, user]);

  const loadNotifications = useCallback(async () => {
    if (!user) return;
    try {
      const data = await apiRequest(`/api/notifications/${user.id}`, {}, true);
      setNotifications(data.notifications || []);
    } catch (error) {
      console.error('Error loading notifications:', error);
    }
  }, [apiRequest, user]);

  // تحسين الاتصال مع التحميل المتوازي
  const connect = useCallback(async (userData: ChatUser) => {
    setIsLoading(true);
    setUser(userData);
    
    try {
      // بدء الاتصال بـ WebSocket فوراً
      connectWebSocket(userData);
      
      // تحميل البيانات بالتوازي
      await Promise.allSettled([
        loadUsers(),
        loadMessages(),
        loadFriends(),
        loadFriendRequests(),
        loadNotifications()
      ]);
      
      console.log('✅ تم الاتصال بنجاح');
    } catch (error) {
      console.error('❌ خطأ في الاتصال:', error);
    } finally {
      setIsLoading(false);
    }
  }, [connectWebSocket, loadUsers, loadMessages, loadFriends, loadFriendRequests, loadNotifications]);

  const disconnect = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
    }
    
    if (wsRef.current) {
      wsRef.current.close(1000, 'User disconnected');
    }
    
    setUser(null);
    setUsers([]);
    setMessages([]);
    setFriends([]);
    setFriendRequests([]);
    setNotifications([]);
    setIsConnected(false);
    setConnectionStatus('disconnected');
    
    // تنظيف التخزين المؤقت
    dataCacheRef.current.clear();
    
    console.log('👋 تم قطع الاتصال');
  }, []);

  // تحسين إرسال الرسائل
  const sendMessage = useCallback((content: string, recipientId?: number) => {
    if (!user || !content.trim()) return;

    const message = {
      type: 'sendMessage',
      content: content.trim(),
      recipientId,
      timestamp: Date.now()
    };

    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify(message));
    } else {
      console.error('WebSocket غير متصل');
    }
  }, [user]);

  // تحسين إرسال طلبات الصداقة
  const sendFriendRequest = useCallback(async (targetUserId: number) => {
    if (!user) return;
    
    try {
      await apiRequest('/api/friend-requests', {
        method: 'POST',
        body: JSON.stringify({
          senderId: user.id,
          receiverId: targetUserId
        })
      });
      
      // تحديث التخزين المؤقت
      dataCacheRef.current.delete(`/api/friend-requests/${user.id}`);
      
      console.log('✅ تم إرسال طلب الصداقة');
    } catch (error) {
      console.error('❌ خطأ في إرسال طلب الصداقة:', error);
      throw error;
    }
  }, [apiRequest, user]);

  const acceptFriendRequest = useCallback(async (senderId: number) => {
    if (!user) return;
    
    try {
      await apiRequest('/api/friend-requests/accept', {
        method: 'POST',
        body: JSON.stringify({
          senderId,
          receiverId: user.id
        })
      });
      
      // تحديث البيانات
      await Promise.all([
        loadFriends(),
        loadFriendRequests()
      ]);
      
      console.log('✅ تم قبول طلب الصداقة');
    } catch (error) {
      console.error('❌ خطأ في قبول طلب الصداقة:', error);
      throw error;
    }
  }, [apiRequest, user, loadFriends, loadFriendRequests]);

  const declineFriendRequest = useCallback(async (senderId: number) => {
    if (!user) return;
    
    try {
      await apiRequest('/api/friend-requests/decline', {
        method: 'POST',
        body: JSON.stringify({
          senderId,
          receiverId: user.id
        })
      });
      
      await loadFriendRequests();
      console.log('❌ تم رفض طلب الصداقة');
    } catch (error) {
      console.error('❌ خطأ في رفض طلب الصداقة:', error);
      throw error;
    }
  }, [apiRequest, user, loadFriendRequests]);

  const removeFriend = useCallback(async (friendId: number) => {
    if (!user) return;
    
    try {
      await apiRequest('/api/friends/remove', {
        method: 'POST',
        body: JSON.stringify({
          userId: user.id,
          friendId
        })
      });
      
      await loadFriends();
      console.log('👋 تم إزالة الصديق');
    } catch (error) {
      console.error('❌ خطأ في إزالة الصديق:', error);
      throw error;
    }
  }, [apiRequest, user, loadFriends]);

  // تحسين مؤشر الكتابة
  const sendTyping = useCallback((typing: boolean) => {
    if (!user || !wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) return;

    wsRef.current.send(JSON.stringify({
      type: 'typing',
      userId: user.id,
      isTyping: typing,
      timestamp: Date.now()
    }));
  }, [user]);

  const handleSetTyping = useCallback((typing: boolean) => {
    setIsTyping(typing);
    sendTyping(typing);

    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }

    if (typing) {
      typingTimeoutRef.current = setTimeout(() => {
        setIsTyping(false);
        sendTyping(false);
      }, 3000);
    }
  }, [sendTyping]);

  // تنظيف عند إلغاء التحميل
  useEffect(() => {
    return () => {
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current);
      }
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }
      if (wsRef.current) {
        wsRef.current.close();
      }
    };
  }, []);

  return {
    user,
    users,
    messages,
    friends,
    friendRequests,
    notifications,
    isConnected,
    isLoading,
    connectionStatus,
    connect,
    disconnect,
    sendMessage,
    sendFriendRequest,
    acceptFriendRequest,
    declineFriendRequest,
    removeFriend,
    isTyping,
    setIsTyping: handleSetTyping
  };
}
// تحسين الأداء العام - تسريع الدخول والتحميل
export class PerformanceOptimizer {
  private static instance: PerformanceOptimizer;
  private cache = new Map<string, any>();
  private preloadQueue: Promise<any>[] = [];

  static getInstance(): PerformanceOptimizer {
    if (!PerformanceOptimizer.instance) {
      PerformanceOptimizer.instance = new PerformanceOptimizer();
    }
    return PerformanceOptimizer.instance;
  }

  // تحسين التحميل المسبق
  async preloadResources(resources: string[]): Promise<void> {
    const promises = resources.map(resource => this.preloadResource(resource));
    this.preloadQueue.push(...promises);
    
    try {
      await Promise.allSettled(promises);
      console.log('🚀 تم التحميل المسبق بنجاح');
    } catch (error) {
      console.log('⚠️ خطأ في التحميل المسبق:', error);
    }
  }

  private async preloadResource(resource: string): Promise<void> {
    return new Promise((resolve) => {
      if (resource.endsWith('.mp3')) {
        const audio = new Audio(resource);
        audio.preload = 'metadata';
        audio.onloadedmetadata = () => resolve();
        audio.onerror = () => resolve();
      } else if (resource.endsWith('.css')) {
        const link = document.createElement('link');
        link.rel = 'preload';
        link.href = resource;
        link.as = 'style';
        link.onload = () => resolve();
        link.onerror = () => resolve();
        document.head.appendChild(link);
      } else {
        const img = new Image();
        img.onload = () => resolve();
        img.onerror = () => resolve();
        img.src = resource;
      }
    });
  }

  // تحسين التخزين المؤقت
  setCache(key: string, data: any, ttl: number = 30000): void {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl
    });
  }

  getCache(key: string): any | null {
    const cached = this.cache.get(key);
    if (!cached) return null;

    const age = Date.now() - cached.timestamp;
    if (age > cached.ttl) {
      this.cache.delete(key);
      return null;
    }

    return cached.data;
  }

  clearCache(): void {
    this.cache.clear();
  }

  // تحسين الذاكرة
  optimizeMemory(): void {
    if ('memory' in performance) {
      const memory = (performance as any).memory;
      const usagePercent = memory.usedJSHeapSize / memory.jsHeapSizeLimit;
      
      if (usagePercent > 0.8) {
        console.log('🧹 تنظيف الذاكرة...');
        this.clearCache();
        
        // إجبار تنظيف الذاكرة
        if (window.gc) {
          (window as any).gc();
        }
      }
    }
  }

  // تحسين الشبكة
  optimizeNetwork(): void {
    if ('connection' in navigator) {
      const connection = (navigator as any).connection;
      
      if (connection.effectiveType === 'slow-2g' || connection.effectiveType === '2g') {
        document.documentElement.classList.add('slow-connection');
        console.log('🌐 تم تفعيل وضع الاتصال البطيء');
      }
    }
  }

  // تحسين التخزين المؤقت في المتصفح
  async setupServiceWorker(): Promise<void> {
    if ('serviceWorker' in navigator) {
      try {
        await navigator.serviceWorker.register('/sw.js');
        console.log('🔧 تم تسجيل Service Worker');
      } catch (error) {
        console.log('⚠️ خطأ في تسجيل Service Worker:', error);
      }
    }
  }

  // تحسين الخطوط
  preloadFonts(): void {
    const fonts = [
      'https://fonts.googleapis.com/css2?family=Cairo:wght@300;400;500;600;700&display=swap'
    ];

    fonts.forEach(font => {
      const link = document.createElement('link');
      link.rel = 'preload';
      link.href = font;
      link.as = 'style';
      document.head.appendChild(link);
    });
  }

  // تحسين الصور
  optimizeImages(): void {
    const images = document.querySelectorAll('img');
    images.forEach(img => {
      if (!img.loading) {
        img.loading = 'lazy';
      }
    });
  }

  // تحسين التمرير
  optimizeScroll(): void {
    document.documentElement.style.scrollBehavior = 'smooth';
    
    // تحسين التمرير للعناصر
    const scrollElements = document.querySelectorAll('[data-smooth-scroll]');
    scrollElements.forEach(element => {
      element.addEventListener('click', (e) => {
        e.preventDefault();
        const target = document.querySelector((e.target as HTMLElement).getAttribute('href') || '');
        if (target) {
          target.scrollIntoView({ behavior: 'smooth' });
        }
      });
    });
  }

  // تحسين الأداء العام
  optimizePerformance(): void {
    // تقليل استخدام CPU عند عدم التركيز
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        document.body.classList.add('page-hidden');
      } else {
        document.body.classList.remove('page-hidden');
      }
    });

    // تحسين الرسوم المتحركة
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (prefersReducedMotion) {
      document.documentElement.classList.add('reduce-motion');
    }

    // تحسين الأحداث
    this.debounceEvents();
  }

  // تحسين الأحداث
  private debounceEvents(): void {
    let resizeTimeout: NodeJS.Timeout;
    let scrollTimeout: NodeJS.Timeout;

    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        // إعادة حساب الأحجام
        this.optimizeImages();
      }, 250);
    });

    window.addEventListener('scroll', () => {
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        // تحسين العناصر المرئية
        this.optimizeVisibleElements();
      }, 100);
    });
  }

  // تحسين العناصر المرئية
  private optimizeVisibleElements(): void {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
        }
      });
    });

    document.querySelectorAll('[data-lazy]').forEach(element => {
      observer.observe(element);
    });
  }

  // تحسين الاتصال
  optimizeConnection(): void {
    // إعدادات WebSocket محسنة
    const wsConfig = {
      binaryType: 'arraybuffer',
      maxReconnectAttempts: 5,
      reconnectInterval: 3000,
      heartbeatInterval: 30000
    };

    // حفظ الإعدادات
    this.setCache('ws-config', wsConfig);
  }

  // تحسين التحميل
  optimizeLoading(): void {
    // إضافة مؤشرات التحميل
    const loadingElements = document.querySelectorAll('[data-loading]');
    loadingElements.forEach(element => {
      element.classList.add('loading');
      
      // إزالة مؤشر التحميل عند اكتمال التحميل
      setTimeout(() => {
        element.classList.remove('loading');
        element.classList.add('loaded');
      }, 1000);
    });
  }

  // تحسين الأمان
  optimizeSecurity(): void {
    // إضافة headers الأمان
    const meta = document.createElement('meta');
    meta.httpEquiv = 'Content-Security-Policy';
    meta.content = "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com;";
    document.head.appendChild(meta);
  }

  // بدء جميع التحسينات
  async startOptimization(): Promise<void> {
    console.log('🚀 بدء تحسين الأداء...');
    
    try {
      // تحسينات فورية
      this.optimizeScroll();
      this.optimizePerformance();
      this.optimizeConnection();
      this.optimizeSecurity();
      this.preloadFonts();
      
      // تحسينات متأخرة
      setTimeout(() => {
        this.optimizeImages();
        this.optimizeLoading();
        this.optimizeNetwork();
      }, 100);

      // تحسينات دورية
      setInterval(() => {
        this.optimizeMemory();
      }, 300000); // كل 5 دقائق

      console.log('✅ تم تحسين الأداء بنجاح');
    } catch (error) {
      console.error('❌ خطأ في تحسين الأداء:', error);
    }
  }
}

// تصدير المثيل الوحيد
export const performanceOptimizer = PerformanceOptimizer.getInstance();

// وظائف مساعدة
export const debounce = <T extends (...args: any[]) => any>(
  func: T,
  wait: number
): ((...args: Parameters<T>) => void) => {
  let timeout: NodeJS.Timeout;
  return (...args: Parameters<T>) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => func(...args), wait);
  };
};

export const throttle = <T extends (...args: any[]) => any>(
  func: T,
  limit: number
): ((...args: Parameters<T>) => void) => {
  let inThrottle: boolean;
  return (...args: Parameters<T>) => {
    if (!inThrottle) {
      func(...args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
};

// تحسين التحميل السريع
export const fastLoad = {
  // تحميل سريع للبيانات
  async loadData<T>(url: string, options?: RequestInit): Promise<T> {
    const cached = performanceOptimizer.getCache(url);
    if (cached) return cached;

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 10000);

    try {
      const response = await fetch(url, {
        ...options,
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      performanceOptimizer.setCache(url, data);
      return data;
    } catch (error) {
      clearTimeout(timeoutId);
      throw error;
    }
  },

  // تحميل متوازي للبيانات
  async loadParallel<T>(urls: string[]): Promise<T[]> {
    const promises = urls.map(url => this.loadData<T>(url));
    return Promise.allSettled(promises).then(results => 
      results.map(result => 
        result.status === 'fulfilled' ? result.value : null
      ).filter(Boolean) as T[]
    );
  }
};
import { pgTable, text, serial, integer, boolean, timestamp, varchar, jsonb } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  password: text("password"),
  userType: text("user_type").notNull().default("guest"), // 'guest', 'member', 'owner'
  profileImage: text("profile_image"),
  profileBanner: text("profile_banner"),
  status: text("status"),
  gender: text("gender"),
  age: integer("age"),
  country: text("country"),
  relation: text("relation"),
  isOnline: boolean("is_online").default(false),
  isHidden: boolean("is_hidden").default(false), // خاصية الإخفاء للمراقبة
  lastSeen: timestamp("last_seen"),
  joinDate: timestamp("join_date").defaultNow(),
  isMuted: boolean("is_muted").default(false),
  muteExpiry: timestamp("mute_expiry"),
  isBanned: boolean("is_banned").default(false),
  banExpiry: timestamp("ban_expiry"),
  isBlocked: boolean("is_blocked").default(false),
  ipAddress: varchar("ip_address", { length: 45 }),
  deviceId: varchar("device_id", { length: 100 }),
  ignoredUsers: text("ignored_users").array().default([]), // قائمة المستخدمين المتجاهلين
  usernameColor: text("username_color").default('#FFFFFF'), // لون اسم المستخدم
  userTheme: text("user_theme").default('default'), // ثيم المستخدم
});

export const messages = pgTable("messages", {
  id: serial("id").primaryKey(),
  senderId: integer("sender_id").references(() => users.id),
  receiverId: integer("receiver_id").references(() => users.id), // null for public messages
  content: text("content").notNull(),
  messageType: text("message_type").notNull().default("text"), // 'text', 'image'
  isPrivate: boolean("is_private").default(false),
  timestamp: timestamp("timestamp").defaultNow(),
});

export const friends = pgTable("friends", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id),
  friendId: integer("friend_id").references(() => users.id),
  status: text("status").notNull().default("pending"), // 'pending', 'accepted', 'blocked'
  createdAt: timestamp("created_at").defaultNow(),
});

export const notifications = pgTable("notifications", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  type: text("type").notNull(), // 'system', 'friend_request', 'message', 'promotion', etc.
  title: text("title").notNull(),
  message: text("message").notNull(),
  isRead: boolean("is_read").default(false),
  data: jsonb("data"), // معلومات إضافية 
  createdAt: timestamp("created_at").defaultNow(),
});

export const insertUserSchema = createInsertSchema(users).pick({
  username: true,
  password: true,
  userType: true,
  profileImage: true,
  profileBanner: true,
  status: true,
  gender: true,
  age: true,
  country: true,
  relation: true,
}).extend({
  // إضافة حقول الإدارة كاختيارية
  isMuted: z.boolean().optional(),
  muteExpiry: z.date().optional(),
  isBanned: z.boolean().optional(),
  banExpiry: z.date().optional(),
  isBlocked: z.boolean().optional(),
  ipAddress: z.string().optional(),
  deviceId: z.string().optional(),
});

export const insertMessageSchema = createInsertSchema(messages).pick({
  senderId: true,
  receiverId: true,
  content: true,
  messageType: true,
  isPrivate: true,
});

export const insertFriendSchema = createInsertSchema(friends).pick({
  userId: true,
  friendId: true,
  status: true,
});

export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = typeof users.$inferSelect;
export type InsertMessage = z.infer<typeof insertMessageSchema>;
export type Message = typeof messages.$inferSelect;
export type InsertFriend = z.infer<typeof insertFriendSchema>;
export type Friend = typeof friends.$inferSelect;

export const insertNotificationSchema = createInsertSchema(notifications).pick({
  userId: true,
  type: true,
  title: true,
  message: true,
  data: true,
});

export type InsertNotification = z.infer<typeof insertNotificationSchema>;
export type Notification = typeof notifications.$inferSelect;
// Extended types for the chat application
export interface ExtendedUser {
  id: number;
  username: string;
  profileImage?: string;
  profileBanner?: string;
  userType: 'guest' | 'member' | 'admin' | 'owner';
  isOnline: boolean;
  usernameColor?: string;
  userTheme?: string;
  status?: string;
  gender?: string;
  age?: number;
  country?: string;
  relation?: string;
  lastSeen?: Date;
  joinDate?: Date;
  isHidden?: boolean;
  isMuted?: boolean;
  isBanned?: boolean;
  isBlocked?: boolean;
  ignoredUsers?: string[];
}

export interface ExtendedMessage {
  id: number;
  senderId: number | null;
  receiverId?: number | null;
  content: string;
  messageType: 'text' | 'image' | 'file';
  isPrivate: boolean;
  timestamp: Date;
  sender?: ExtendedUser;
  senderName?: string;
}
