import {
  users,
  messages,
  friends,
  notifications,
  type User,
  type InsertUser,
  type Message,
  type InsertMessage,
  type Friend,
  type InsertFriend,
  type Notification,
  type InsertNotification,
} from "../shared/schema";
import { db } from "./db";
import { eq, desc } from "drizzle-orm";

export interface IStorage {
  // User operations
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  updateUser(id: number, updates: Partial<User>): Promise<User | undefined>;
  setUserOnlineStatus(id: number, isOnline: boolean): Promise<void>;
  setUserHiddenStatus(id: number, isHidden: boolean): Promise<void>;
  addIgnoredUser(userId: number, ignoredUserId: number): Promise<void>;
  removeIgnoredUser(userId: number, ignoredUserId: number): Promise<void>;
  getIgnoredUsers(userId: number): Promise<number[]>;
  getOnlineUsers(): Promise<User[]>;
  getAllUsers(): Promise<User[]>;

  // Message operations
  createMessage(message: InsertMessage): Promise<Message>;
  getPublicMessages(limit?: number): Promise<Message[]>;
  getPrivateMessages(userId1: number, userId2: number, limit?: number): Promise<Message[]>;

  // Friend operations
  addFriend(userId: number, friendId: number): Promise<Friend>;
  getFriends(userId: number): Promise<User[]>;
  updateFriendStatus(userId: number, friendId: number, status: string): Promise<void>;
  getBlockedUsers(userId: number): Promise<User[]>;
  removeFriend(userId: number, friendId: number): Promise<boolean>;
  getFriendship(userId1: number, userId2: number): Promise<Friend | undefined>;
  
  // Friend request operations - Ù…Ø­Ø³Ù† ÙˆÙ…Ù†Ø¸Ù…
  createFriendRequest(senderId: number, receiverId: number): Promise<any>;
  getFriendRequest(senderId: number, receiverId: number): Promise<any>;
  getFriendRequestById(requestId: number): Promise<any>;
  getIncomingFriendRequests(userId: number): Promise<any[]>;
  getOutgoingFriendRequests(userId: number): Promise<any[]>;
  acceptFriendRequest(requestId: number): Promise<boolean>;
  declineFriendRequest(requestId: number): Promise<boolean>;
  ignoreFriendRequest(requestId: number): Promise<boolean>;
  deleteFriendRequest(requestId: number): Promise<boolean>;
  
  // User verification and security
  verifyUserCredentials(username: string, password: string): Promise<User | null>;

  // Notification operations
  createNotification(notification: InsertNotification): Promise<Notification>;
  getUserNotifications(userId: number, limit?: number): Promise<Notification[]>;
  markNotificationAsRead(notificationId: number): Promise<boolean>;
  markAllNotificationsAsRead(userId: number): Promise<boolean>;
  deleteNotification(notificationId: number): Promise<boolean>;
  getUnreadNotificationCount(userId: number): Promise<number>;
}

// Mixed storage: Database for members, Memory for guests
export class MixedStorage implements IStorage {
  private users: Map<number, User>;
  private messages: Map<number, Message>;
  private friends: Map<number, Friend>;
  private friendRequests: Map<number, any>;
  private currentUserId: number;
  private currentMessageId: number;
  private currentFriendId: number;
  private currentRequestId: number;

  constructor() {
    this.users = new Map();
    this.messages = new Map();
    this.friends = new Map();
    this.friendRequests = new Map();
    this.currentUserId = 1000; // Start guest IDs from 1000 to avoid conflicts
    this.currentMessageId = 1;
    this.currentFriendId = 1;
    this.currentRequestId = 1;

    // Initialize owner user in database
    this.initializeOwner();
  }

  private async initializeOwner() {
    try {
      // Check if owner already exists
      const existing = await db.select().from(users).where(eq(users.username, "Ø¹Ø¨Ø¯Ø§Ù„ÙƒØ±ÙŠÙ…"));
      if (existing.length === 0) {
        // Create owner user in database
        await db.insert(users).values({
          username: "Ø¹Ø¨Ø¯Ø§Ù„ÙƒØ±ÙŠÙ…",
          password: "Ø¹Ø¨Ø¯Ø§Ù„ÙƒØ±ÙŠÙ…22333",
          userType: "owner",
          profileImage: "/default_avatar.svg",
          status: "Ù…Ø§Ù„Ùƒ Ø§Ù„Ù…ÙˆÙ‚Ø¹",
          gender: "Ø°ÙƒØ±",
          age: 30,
          country: "Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©",
          relation: "Ù…Ø±ØªØ¨Ø·",
          isOnline: true,
          lastSeen: new Date(),
          joinDate: new Date(),
        });
      }

      // Check if admin already exists
      const existingAdmin = await db.select().from(users).where(eq(users.username, "Ø¹Ø¨ÙˆØ¯"));
      if (existingAdmin.length === 0) {
        // Create admin user in database
        await db.insert(users).values({
          username: "Ø¹Ø¨ÙˆØ¯",
          password: "22333",
          userType: "owner",
          profileImage: "/default_avatar.svg",
          status: "Ù…Ø´Ø±Ù Ù…Ø¤Ù‚Øª",
          gender: "Ø°ÙƒØ±",
          age: 25,
          country: "Ø§Ù„Ø¹Ø±Ø§Ù‚",
          relation: "Ø£Ø¹Ø²Ø¨",
          isOnline: false,
          lastSeen: new Date(),
          joinDate: new Date(),
        });
      }
    } catch (error) {
      console.error('Error initializing owner:', error);
    }
  }

  async getUser(id: number): Promise<User | undefined> {
    // Check memory first (for guests)
    const memUser = this.users.get(id);
    if (memUser) return memUser;
    
    // Check database (for members)
    try {
      const [dbUser] = await db.select().from(users).where(eq(users.id, id));
      return dbUser || undefined;
    } catch (error) {
      return undefined;
    }
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    // Check memory first (for guests)
    const memUser = Array.from(this.users.values()).find(
      (user) => user.username === username,
    );
    if (memUser) return memUser;
    
    // Check database (for members)
    const [dbUser] = await db.select().from(users).where(eq(users.username, username));
    return dbUser || undefined;
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    if (insertUser.userType === 'member' || insertUser.userType === 'owner') {
      // Store members in database with profile picture support
      const [dbUser] = await db
        .insert(users)
        .values({
          username: insertUser.username,
          password: insertUser.password,
          userType: insertUser.userType,
          profileImage: insertUser.profileImage || "/default_avatar.svg",
          profileBanner: insertUser.profileBanner || null,
          status: insertUser.status,
          gender: insertUser.gender,
          age: insertUser.age,
          country: insertUser.country,
          relation: insertUser.relation,
          isOnline: true,
          lastSeen: new Date(),
          joinDate: new Date(),
          usernameColor: '#FFFFFF',
          userTheme: 'default'
        })
        .returning();
      return dbUser;
    } else {
      // Store guests in memory (temporary, no profile picture upload)
      const id = this.currentUserId++;
      const user: User = {
        id,
        username: insertUser.username,
        password: insertUser.password || null,
        userType: insertUser.userType || "guest",
        profileImage: "/default_avatar.svg", // Guests always use default
        profileBanner: null, // Guests cannot have banners
        status: insertUser.status || null,
        gender: insertUser.gender || null,
        age: insertUser.age || null,
        country: insertUser.country || null,
        relation: insertUser.relation || null,
        isOnline: true,
        lastSeen: new Date(),
        joinDate: new Date(),
        isMuted: false,
        muteExpiry: null,
        isBanned: false,
        banExpiry: null,
        isBlocked: false,
        ipAddress: null,
        deviceId: null,
        ignoredUsers: [],
        usernameColor: '#FFFFFF',
        userTheme: 'default',
        isHidden: false
      };
      
      this.users.set(id, user);
      return user;
    }
  }

  async updateUser(id: number, updates: Partial<User>): Promise<User | undefined> {
    // Check if user is in memory (guest)
    const memUser = this.users.get(id);
    if (memUser) {
      // Guests cannot upload profile pictures or banners
      if (updates.profileImage && memUser.userType === 'guest') {
        delete updates.profileImage;
      }
      if (updates.profileBanner && memUser.userType === 'guest') {
        delete updates.profileBanner;
      }
      const updatedUser = { ...memUser, ...updates };
      this.users.set(id, updatedUser);
      return updatedUser;
    }
    
    // Check if user is in database (member)
    try {
      const [existing] = await db.select().from(users).where(eq(users.id, id));
      if (existing && (existing.userType === 'member' || existing.userType === 'owner')) {
        // Members can upload profile pictures and change themes
        const updateData: any = { ...updates };
        
        // ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù…ÙˆØ¬ÙˆØ¯Ø©
        if (updates.userTheme !== undefined) {
          updateData.userTheme = updates.userTheme;
        }
        if (updates.usernameColor !== undefined) {
          updateData.usernameColor = updates.usernameColor;
        }
        
        const [updatedUser] = await db
          .update(users)
          .set(updateData)
          .where(eq(users.id, id))
          .returning();
        
        console.log('Updated user in database:', updatedUser);
        return updatedUser;
      }
    } catch (error) {
      console.error('Error updating user:', error);
    }
    
    return undefined;
  }

  async setUserOnlineStatus(id: number, isOnline: boolean): Promise<void> {
    // Check memory first (guests)
    const memUser = this.users.get(id);
    if (memUser) {
      memUser.isOnline = isOnline;
      memUser.lastSeen = new Date();
      this.users.set(id, memUser);
      return;
    }

    // Check database (members)
    try {
      await db
        .update(users)
        .set({ 
          isOnline: isOnline,
          lastSeen: new Date()
        })
        .where(eq(users.id, id));
    } catch (error) {
      console.error('Error updating user online status:', error);
    }
  }

  async getOnlineUsers(): Promise<User[]> {
    const memUsers = Array.from(this.users.values()).filter(user => user.isOnline && !user.isHidden);
    
    // Get online members from database (excluding hidden)
    try {
      const dbUsers = await db.select().from(users).where(eq(users.isOnline, true));
      
      // ØªÙ†Ø¸ÙŠÙ Ø­Ø§Ù„Ø© Ø§Ù„ÙƒØªÙ… ÙˆØ§Ù„Ø·Ø±Ø¯ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ© Ø§Ù„Ù…Ø¯Ø©
      const now = new Date();
      const cleanedDbUsers = dbUsers.map(user => {
        let cleaned = { ...user };
        
        // Ø¥Ø°Ø§ Ø§Ù†ØªÙ‡Øª Ù…Ø¯Ø© Ø§Ù„ÙƒØªÙ…ØŒ Ù†Ù„ØºÙŠÙ‡Ø§
        if (user.isMuted && user.muteExpiry && new Date(user.muteExpiry) <= now) {
          console.log(`ğŸ”„ Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ÙƒØªÙ… Ø§Ù„Ù…Ù†ØªÙ‡ÙŠ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…: ${user.username}`);
          cleaned.isMuted = false;
          cleaned.muteExpiry = null;
          // ØªØ­Ø¯ÙŠØ« ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø´ÙƒÙ„ ØºÙŠØ± Ù…ØªØ²Ø§Ù…Ù†
          this.updateUser(user.id, { 
            isMuted: false, 
            muteExpiry: null 
          }).catch(console.error);
        }
        
        // Ø¥Ø°Ø§ Ø§Ù†ØªÙ‡Øª Ù…Ø¯Ø© Ø§Ù„Ø·Ø±Ø¯ØŒ Ù†Ù„ØºÙŠÙ‡Ø§
        if (user.isBanned && user.banExpiry && new Date(user.banExpiry) <= now) {
          console.log(`ğŸ”„ Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø·Ø±Ø¯ Ø§Ù„Ù…Ù†ØªÙ‡ÙŠ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…: ${user.username}`);
          cleaned.isBanned = false;
          cleaned.banExpiry = null;
          // ØªØ­Ø¯ÙŠØ« ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø´ÙƒÙ„ ØºÙŠØ± Ù…ØªØ²Ø§Ù…Ù†
          this.updateUser(user.id, { 
            isBanned: false, 
            banExpiry: null 
          }).catch(console.error);
        }
        
        return cleaned;
      });
      
      const visibleDbUsers = cleanedDbUsers.filter(user => !user.isHidden);
      return [...memUsers, ...visibleDbUsers];
    } catch (error) {
      return memUsers;
    }
  }

  async setUserHiddenStatus(id: number, isHidden: boolean): Promise<void> {
    // Check memory first (guests)
    const memUser = this.users.get(id);
    if (memUser) {
      memUser.isHidden = isHidden;
      this.users.set(id, memUser);
      return;
    }

    // Check database (members)
    try {
      await db.update(users).set({ isHidden }).where(eq(users.id, id));
    } catch (error) {
      console.error('Error updating user hidden status:', error);
    }
  }

  async addIgnoredUser(userId: number, ignoredUserId: number): Promise<void> {
    // Check memory first (guests)
    const memUser = this.users.get(userId);
    if (memUser) {
      if (!memUser.ignoredUsers) memUser.ignoredUsers = [];
      if (!memUser.ignoredUsers.includes(ignoredUserId.toString())) {
        memUser.ignoredUsers.push(ignoredUserId.toString());
        this.users.set(userId, memUser);
      }
      return;
    }

    // Check database (members)
    try {
      const [dbUser] = await db.select().from(users).where(eq(users.id, userId));
      if (dbUser) {
        const currentIgnored = dbUser.ignoredUsers || [];
        if (!currentIgnored.includes(ignoredUserId.toString())) {
          currentIgnored.push(ignoredUserId.toString());
          await db.update(users).set({ ignoredUsers: currentIgnored }).where(eq(users.id, userId));
        }
      }
    } catch (error) {
      console.error('Error adding ignored user:', error);
    }
  }

  async removeIgnoredUser(userId: number, ignoredUserId: number): Promise<void> {
    // Check memory first (guests)
    const memUser = this.users.get(userId);
    if (memUser && memUser.ignoredUsers) {
      memUser.ignoredUsers = memUser.ignoredUsers.filter(id => id !== ignoredUserId.toString());
      this.users.set(userId, memUser);
      return;
    }

    // Check database (members)
    try {
      const [dbUser] = await db.select().from(users).where(eq(users.id, userId));
      if (dbUser && dbUser.ignoredUsers) {
        const filteredIgnored = dbUser.ignoredUsers.filter(id => id !== ignoredUserId.toString());
        await db.update(users).set({ ignoredUsers: filteredIgnored }).where(eq(users.id, userId));
      }
    } catch (error) {
      console.error('Error removing ignored user:', error);
    }
  }

  async getIgnoredUsers(userId: number): Promise<number[]> {
    // Check memory first (guests)
    const memUser = this.users.get(userId);
    if (memUser && memUser.ignoredUsers) {
      return memUser.ignoredUsers.map(id => parseInt(id));
    }
    
    // Check database (members)
    try {
      const [dbUser] = await db.select().from(users).where(eq(users.id, userId));
      if (dbUser && dbUser.ignoredUsers) {
        return dbUser.ignoredUsers.map(id => parseInt(id));
      }
    } catch (error) {
      console.error('Error getting ignored users:', error);
    }
    
    return [];
  }

  async createMessage(insertMessage: InsertMessage): Promise<Message> {
    try {
      // Always try database first for persistence
      const [dbMessage] = await db
        .insert(messages)
        .values({
          senderId: insertMessage.senderId,
          receiverId: insertMessage.receiverId,
          content: insertMessage.content,
          messageType: insertMessage.messageType || 'text',
          isPrivate: insertMessage.isPrivate || false,
          timestamp: new Date(),
        })
        .returning();
      
      return dbMessage;
    } catch (error) {
      console.error('Database insert failed, using memory:', error);
      // Fallback to memory for guests or if database fails
      const message: Message = {
        id: this.currentMessageId++,
        senderId: insertMessage.senderId,
        receiverId: insertMessage.receiverId,
        content: insertMessage.content,
        messageType: insertMessage.messageType || 'text',
        isPrivate: insertMessage.isPrivate || false,
        timestamp: new Date(),
      };
      
      this.messages.set(message.id, message);
      return message;
    }
  }

  async getPublicMessages(limit: number = 50): Promise<Message[]> {
    // Get from memory first
    const memMessages = Array.from(this.messages.values())
      .filter(msg => !msg.isPrivate)
      .sort((a, b) => (a.timestamp || new Date()).getTime() - (b.timestamp || new Date()).getTime());
    
    // Try to get from database as well
    try {
      const dbMessages = await db.select().from(messages)
        .where(eq(messages.isPrivate, false))
        .orderBy(desc(messages.timestamp))
        .limit(limit);
      
      // Combine both sources and remove duplicates
      const allMessages = [...memMessages, ...dbMessages];
      const uniqueMessages = allMessages.filter((msg, index, arr) => 
        index === arr.findIndex(m => m.id === msg.id)
      );
      
      return uniqueMessages
        .sort((a, b) => (a.timestamp || new Date()).getTime() - (b.timestamp || new Date()).getTime())
        .slice(-limit);
    } catch (error) {
      console.error('Error getting database messages:', error);
      return memMessages.slice(-limit);
    }
  }

  async getPrivateMessages(userId1: number, userId2: number, limit: number = 50): Promise<Message[]> {
    return Array.from(this.messages.values())
      .filter(msg => 
        msg.isPrivate && 
        ((msg.senderId === userId1 && msg.receiverId === userId2) ||
         (msg.senderId === userId2 && msg.receiverId === userId1))
      )
      .sort((a, b) => (a.timestamp || new Date()).getTime() - (b.timestamp || new Date()).getTime())
      .slice(-limit);
  }

  async addFriend(userId: number, friendId: number): Promise<Friend> {
    // Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØµØ¯Ø§Ù‚Ø© ÙÙŠ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø£ÙˆÙ„
    const id1 = this.currentFriendId++;
    const friend1: Friend = {
      id: id1,
      userId,
      friendId,
      status: "accepted",
      createdAt: new Date(),
    };
    this.friends.set(id1, friend1);

    // Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØµØ¯Ø§Ù‚Ø© ÙÙŠ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù…Ø¹Ø§ÙƒØ³
    const id2 = this.currentFriendId++;
    const friend2: Friend = {
      id: id2,
      userId: friendId,
      friendId: userId,
      status: "accepted",
      createdAt: new Date(),
    };
    this.friends.set(id2, friend2);

    return friend1;
  }

  async getFriends(userId: number): Promise<User[]> {
    const friendships = Array.from(this.friends.values())
      .filter(f => (f.userId === userId || f.friendId === userId) && f.status === "accepted");
    
    const friendIds = [...new Set(friendships.map(f => 
      f.userId === userId ? f.friendId : f.userId
    ))]; // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙƒØ±Ø§Ø±
    
    const friends: User[] = [];
    
    for (const friendId of friendIds) {
      if (friendId) {
        // Check memory first
        const memFriend = this.users.get(friendId);
        if (memFriend) {
          friends.push(memFriend);
        } else {
          // Check database
          try {
            const [dbFriend] = await db.select().from(users).where(eq(users.id, friendId));
            if (dbFriend) friends.push(dbFriend);
          } catch (error) {
            console.error('Error fetching friend from database:', error);
          }
        }
      }
    }
    
    return friends;
  }

  async updateFriendStatus(userId: number, friendId: number, status: string): Promise<void> {
    const friendship = Array.from(this.friends.values())
      .find(f => (f.userId === userId && f.friendId === friendId) || 
                  (f.userId === friendId && f.friendId === userId));
    
    if (friendship) {
      friendship.status = status;
      this.friends.set(friendship.id, friendship);
    }
  }

  async getBlockedUsers(userId: number): Promise<User[]> {
    const blockedFriendships = Array.from(this.friends.values())
      .filter(f => f.userId === userId && f.status === "blocked");
    
    const blockedIds = blockedFriendships.map(f => f.friendId);
    return blockedIds.map(id => this.users.get(id!)).filter(Boolean) as User[];
  }

  // Enhanced friend request operations
  async getIncomingFriendRequests(userId: number): Promise<any[]> {
    const incomingRequests = Array.from(this.friends.values())
      .filter(f => f.friendId === userId && f.status === 'pending');
    
    return await Promise.all(incomingRequests.map(async (request) => {
      const user = await this.getUser(request.userId!);
      return {
        ...request,
        user
      };
    }));
  }

  async getOutgoingFriendRequests(userId: number): Promise<any[]> {
    const outgoingRequests = Array.from(this.friends.values())
      .filter(f => f.userId === userId && f.status === 'pending');
    
    return await Promise.all(outgoingRequests.map(async (request) => {
      const user = await this.getUser(request.friendId!);
      return {
        ...request,
        user
      };
    }));
  }

  async acceptFriendRequest(requestId: number): Promise<boolean> {
    const request = this.friends.get(requestId);
    if (!request || request.status !== 'pending') return false;
    
    request.status = 'accepted';
    this.friends.set(requestId, request);
    return true;
  }

  async declineFriendRequest(requestId: number): Promise<boolean> {
    const request = this.friendRequests.get(requestId);
    if (!request || request.status !== 'pending') return false;
    
    request.status = 'declined';
    this.friendRequests.set(requestId, request);
    return true;
  }

  async ignoreFriendRequest(requestId: number): Promise<boolean> {
    const request = this.friendRequests.get(requestId);
    if (!request || request.status !== 'pending') return false;
    
    request.status = 'ignored';
    this.friendRequests.set(requestId, request);
    return true;
  }

  async deleteFriendRequest(requestId: number): Promise<boolean> {
    const request = this.friendRequests.get(requestId);
    if (!request) return false;
    
    this.friendRequests.delete(requestId);
    return true;
  }

  async removeFriend(userId: number, friendId: number): Promise<boolean> {
    const friendship = Array.from(this.friends.values())
      .find(f => (f.userId === userId && f.friendId === friendId) || 
                 (f.userId === friendId && f.friendId === userId));
    
    if (!friendship) return false;
    
    this.friends.delete(friendship.id);
    return true;
  }

  // Friend Request Operations
  async getAllUsers(): Promise<User[]> {
    try {
      const dbUsers = await db.select().from(users);
      const memoryUsers = Array.from(this.users.values());
      return [...dbUsers, ...memoryUsers];
    } catch (error) {
      console.error("Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†:", error);
      return Array.from(this.users.values());
    }
  }

  async getFriendship(userId1: number, userId2: number): Promise<Friend | undefined> {
    return Array.from(this.friends.values()).find(
      f => ((f.userId === userId1 && f.friendId === userId2) ||
           (f.userId === userId2 && f.friendId === userId1)) &&
           f.status === "accepted"
    );
  }

  async createFriendRequest(senderId: number, receiverId: number): Promise<any> {
    const request = {
      id: this.currentRequestId++,
      senderId,
      receiverId,
      status: 'pending',
      createdAt: new Date().toISOString(),
      sender: await this.getUser(senderId),
      receiver: await this.getUser(receiverId)
    };

    this.friendRequests.set(request.id, request);
    return request;
  }

  async getFriendRequest(senderId: number, receiverId: number): Promise<any> {
    return Array.from(this.friendRequests.values()).find(
      r => r.senderId === senderId && r.receiverId === receiverId && r.status === 'pending'
    );
  }

  async getFriendRequestById(requestId: number): Promise<any> {
    return this.friendRequests.get(requestId);
  }

  async getIncomingFriendRequests(userId: number): Promise<any[]> {
    const requests = Array.from(this.friendRequests.values()).filter(
      r => r.receiverId === userId && r.status === 'pending'
    );

    for (const request of requests) {
      request.sender = await this.getUser(request.senderId);
    }

    return requests;
  }

  async getOutgoingFriendRequests(userId: number): Promise<any[]> {
    const requests = Array.from(this.friendRequests.values()).filter(
      r => r.senderId === userId && r.status === 'pending'
    );

    for (const request of requests) {
      request.receiver = await this.getUser(request.receiverId);
    }

    return requests;
  }

  async acceptFriendRequest(requestId: number): Promise<boolean> {
    const request = this.friendRequests.get(requestId);
    if (!request) return false;

    request.status = 'accepted';
    this.friendRequests.set(requestId, request);
    return true;
  }

  async declineFriendRequest(requestId: number): Promise<boolean> {
    const request = this.friendRequests.get(requestId);
    if (!request) return false;

    request.status = 'declined';
    this.friendRequests.set(requestId, request);
    return true;
  }

  async deleteFriendRequest(requestId: number): Promise<boolean> {
    return this.friendRequests.delete(requestId);
  }

  // Notification operations
  async createNotification(notification: InsertNotification): Promise<Notification> {
    try {
      const [newNotification] = await db
        .insert(notifications)
        .values(notification)
        .returning();
      return newNotification;
    } catch (error) {
      console.error('Error creating notification:', error);
      throw error;
    }
  }

  async getUserNotifications(userId: number, limit: number = 50): Promise<Notification[]> {
    try {
      const userNotifications = await db
        .select()
        .from(notifications)
        .where(eq(notifications.userId, userId))
        .orderBy(desc(notifications.createdAt))
        .limit(limit);
      return userNotifications;
    } catch (error) {
      console.error('Error getting user notifications:', error);
      return [];
    }
  }

  async markNotificationAsRead(notificationId: number): Promise<boolean> {
    try {
      await db
        .update(notifications)
        .set({ isRead: true })
        .where(eq(notifications.id, notificationId));
      return true;
    } catch (error) {
      console.error('Error marking notification as read:', error);
      return false;
    }
  }

  async markAllNotificationsAsRead(userId: number): Promise<boolean> {
    try {
      await db
        .update(notifications)
        .set({ isRead: true })
        .where(eq(notifications.userId, userId));
      return true;
    } catch (error) {
      console.error('Error marking all notifications as read:', error);
      return false;
    }
  }

  async deleteNotification(notificationId: number): Promise<boolean> {
    try {
      await db.delete(notifications).where(eq(notifications.id, notificationId));
      return true;
    } catch (error) {
      console.error('Error deleting notification:', error);
      return false;
    }
  }

  async getUnreadNotificationCount(userId: number): Promise<number> {
    try {
      const result = await db
        .select()
        .from(notifications)
        .where(eq(notifications.userId, userId))
        .where(eq(notifications.isRead, false));
      return result.length;
    } catch (error) {
      console.error('Error getting unread notification count:', error);
      return 0;
    }
  }
}

export const storage = new MixedStorage();
import type { Express } from "express";
import { createServer, type Server } from "http";
import { WebSocketServer, WebSocket } from "ws";
import { storage } from "./storage";
import { setupDownloadRoute } from "./download-route";
import { insertUserSchema, insertMessageSchema } from "@shared/schema";
import { spamProtection } from "./spam-protection";
import { moderationSystem } from "./moderation";
import { sanitizeInput, validateMessageContent, checkIPSecurity, authLimiter, messageLimiter } from "./security";

import { advancedSecurity, advancedSecurityMiddleware } from "./advanced-security";
import securityApiRoutes from "./api-security";
import { z } from "zod";
import multer from "multer";
import path from "path";
import fs from "fs";

interface WebSocketClient extends WebSocket {
  userId?: number;
  username?: string;
}

// Ø¥Ø¹Ø¯Ø§Ø¯ multer Ù„Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±
const storage_multer = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadDir = path.join(process.cwd(), 'client', 'public', 'uploads', 'profiles');
    
    // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù…Ø¬Ù„Ø¯
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    const ext = path.extname(file.originalname);
    cb(null, `profile-${uniqueSuffix}${ext}`);
  }
});

const upload = multer({
  storage: storage_multer,
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB
  },
  fileFilter: (req, file, cb) => {
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù†ÙˆØ¹ Ø§Ù„Ù…Ù„Ù
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('ÙŠØ±Ø¬Ù‰ Ø±ÙØ¹ Ù…Ù„Ù ØµÙˆØ±Ø© ØµØ­ÙŠØ­'));
    }
  }
});

let wss: WebSocketServer;

// Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø¯Ù…Ø§Øª Ù…Ø­Ø³Ù†Ø© ÙˆÙ…Ù†Ø¸Ù…Ø©
const authService = new (class AuthService {
  async login(username: string, password: string) {
    const user = await storage.getUserByUsername(username.trim());
    if (!user || user.password !== password.trim()) {
      throw new Error('Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯Ø®ÙˆÙ„ ØºÙŠØ± ØµØ­ÙŠØ­Ø©');
    }
    await storage.setUserOnlineStatus(user.id, true);
    return user;
  }
  
  async register(userData: any) {
    const existingUser = await storage.getUserByUsername(userData.username);
    if (existingUser) {
      throw new Error('Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø¨Ù‚Ø§Ù‹');
    }
    return await storage.createUser(userData);
  }
})();

const messageService = new (class MessageService {
  async sendMessage(senderId: number, messageData: any) {
    const sender = await storage.getUser(senderId);
    if (!sender) throw new Error('Ø§Ù„Ù…Ø±Ø³Ù„ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯');
    
    if (sender.isMuted && !messageData.isPrivate) {
      throw new Error('Ø£Ù†Øª Ù…ÙƒØªÙˆÙ… ÙˆÙ„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ø¦Ù„ Ø¹Ø§Ù…Ø©');
    }
    
    return await storage.createMessage({ ...messageData, senderId });
  }
})();

const friendService = new (class FriendService {
  async sendFriendRequest(senderId: number, receiverId: number) {
    if (senderId === receiverId) {
      throw new Error('Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ ØµØ¯Ø§Ù‚Ø© Ù„Ù†ÙØ³Ùƒ');
    }
    
    const existingRequest = await storage.getFriendRequest(senderId, receiverId);
    if (existingRequest) {
      throw new Error('Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø© Ù…Ø±Ø³Ù„ Ù…Ø³Ø¨Ù‚Ø§Ù‹');
    }
    
    return await storage.createFriendRequest(senderId, receiverId);
  }
})();

export async function registerRoutes(app: Express): Promise<Server> {
  // Ø±ÙØ¹ ØµÙˆØ± Ø§Ù„Ø¨Ø±ÙˆÙØ§ÙŠÙ„ (Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø´Ø®ØµÙŠØ©) - Ù…Ø¹ ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­ÙØ¸
  app.post('/api/upload/profile-image', upload.single('profileImage'), async (req, res) => {
    try {
      console.log('ğŸ–¼ï¸ Ø·Ù„Ø¨ Ø±ÙØ¹ ØµÙˆØ±Ø© Ø§Ù„Ø¨Ø±ÙˆÙØ§ÙŠÙ„ - Ø§Ù„Ù…Ù„Ù:', req.file?.filename);
      console.log('Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø±Ø³Ù„Ø©:', req.body);

      if (!req.file) {
        return res.status(400).json({ error: 'Ù„Ù… ÙŠØªÙ… Ø±ÙØ¹ Ø£ÙŠ Ù…Ù„Ù' });
      }

      const userId = req.body.userId;
      const confirmSave = req.body.confirmSave; // ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­ÙØ¸ Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…

      if (!userId) {
        return res.status(400).json({ error: 'Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø·Ù„ÙˆØ¨' });
      }

      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ ØªØ£ÙƒÙŠØ¯ Ø­ÙØ¸ØŒ Ù†Ø±Ø¬Ø¹ Ù…Ø³Ø§Ø± Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…Ø¤Ù‚Øª ÙÙ‚Ø· Ù„Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©
      const tempImageUrl = `/uploads/profiles/${req.file.filename}`;
      
      if (!confirmSave || confirmSave === 'false') {
        console.log('ğŸ“‹ Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„ØµÙˆØ±Ø© ÙÙ‚Ø· - Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø­ÙØ¸ Ø¨Ø¹Ø¯');
        return res.json({
          success: true,
          preview: true,
          message: 'ØªÙ… Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© Ù„Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© - Ø§Ø¶ØºØ· Ø­ÙØ¸ Ù„Ù„ØªØ£ÙƒÙŠØ¯',
          tempImageUrl: tempImageUrl,
          filename: req.file.filename
        });
      }

      // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ ØªØ£ÙƒÙŠØ¯ Ø­ÙØ¸ØŒ Ù†Ø­ÙØ¸ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      const user = await storage.getUser(parseInt(userId));
      if (!user) {
        return res.status(404).json({ error: 'Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯' });
      }

      // Ø­Ø°Ù Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…ÙˆØ¬ÙˆØ¯Ø© (ÙˆÙ„ÙŠØ³Øª Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©)
      if (user.profileImage && user.profileImage !== '/default_avatar.svg') {
        const oldImagePath = path.join(process.cwd(), 'client', 'public', user.profileImage);
        if (fs.existsSync(oldImagePath)) {
          fs.unlinkSync(oldImagePath);
          console.log('ğŸ—‘ï¸ ØªÙ… Ø­Ø°Ù Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©:', user.profileImage);
        }
      }

      // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
      const updatedUser = await storage.updateUser(parseInt(userId), { profileImage: tempImageUrl });
      
      console.log('âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« ØµÙˆØ±Ø© Ø§Ù„Ø¨Ø±ÙˆÙØ§ÙŠÙ„ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…:', updatedUser?.username);

      // Ø¥Ø±Ø³Ø§Ù„ ØªØ­Ø¯ÙŠØ« WebSocket Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
      if (wss && updatedUser) {
        wss.clients.forEach((client: WebSocketClient) => {
          if (client.readyState === WebSocket.OPEN) {
            client.send(JSON.stringify({
              type: 'userUpdated',
              user: updatedUser
            }));
          }
        });
      }

      res.json({
        success: true,
        message: 'ØªÙ… Ø­ÙØ¸ ØµÙˆØ±Ø© Ø§Ù„Ø¨Ø±ÙˆÙØ§ÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­',
        imageUrl: tempImageUrl,
        user: updatedUser
      });

    } catch (error) {
      console.error('âŒ Ø®Ø·Ø£ ÙÙŠ Ø±ÙØ¹ ØµÙˆØ±Ø© Ø§Ù„Ø¨Ø±ÙˆÙØ§ÙŠÙ„:', error);
      res.status(500).json({ 
        error: error instanceof Error ? error.message : 'Ø®Ø·Ø£ ÙÙŠ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©' 
      });
    }
  });

  // Ø±ÙØ¹ ØµÙˆØ± Ø§Ù„Ø¨Ø§Ù†Ø± (Ø§Ù„Ø®Ù„ÙÙŠØ©) - Ù…Ø¹ ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­ÙØ¸
  app.post('/api/upload/profile-banner', upload.single('profileBanner'), async (req, res) => {
    try {
      console.log('ğŸ¨ Ø·Ù„Ø¨ Ø±ÙØ¹ ØµÙˆØ±Ø© Ø§Ù„Ø¨Ø§Ù†Ø± - Ø§Ù„Ù…Ù„Ù:', req.file?.filename);
      console.log('Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø±Ø³Ù„Ø©:', req.body);

      if (!req.file) {
        return res.status(400).json({ error: 'Ù„Ù… ÙŠØªÙ… Ø±ÙØ¹ Ø£ÙŠ Ù…Ù„Ù' });
      }

      const userId = req.body.userId;
      const confirmSave = req.body.confirmSave; // ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­ÙØ¸ Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…

      if (!userId) {
        return res.status(400).json({ error: 'Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø·Ù„ÙˆØ¨' });
      }

      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ ØªØ£ÙƒÙŠØ¯ Ø­ÙØ¸ØŒ Ù†Ø±Ø¬Ø¹ Ù…Ø³Ø§Ø± Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…Ø¤Ù‚Øª ÙÙ‚Ø· Ù„Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©
      const tempBannerUrl = `/uploads/profiles/${req.file.filename}`;
      
      if (!confirmSave || confirmSave === 'false') {
        console.log('ğŸ“‹ Ù…Ø¹Ø§ÙŠÙ†Ø© ØµÙˆØ±Ø© Ø§Ù„Ø¨Ø§Ù†Ø± ÙÙ‚Ø· - Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø­ÙØ¸ Ø¨Ø¹Ø¯');
        return res.json({
          success: true,
          preview: true,
          message: 'ØªÙ… Ø±ÙØ¹ ØµÙˆØ±Ø© Ø§Ù„Ø¨Ø§Ù†Ø± Ù„Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© - Ø§Ø¶ØºØ· Ø­ÙØ¸ Ù„Ù„ØªØ£ÙƒÙŠØ¯',
          tempBannerUrl: tempBannerUrl,
          filename: req.file.filename
        });
      }

      // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ ØªØ£ÙƒÙŠØ¯ Ø­ÙØ¸ØŒ Ù†Ø­ÙØ¸ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      const user = await storage.getUser(parseInt(userId));
      if (!user) {
        return res.status(404).json({ error: 'Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯' });
      }

      // Ø­Ø°Ù ØµÙˆØ±Ø© Ø§Ù„Ø¨Ø§Ù†Ø± Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…ÙˆØ¬ÙˆØ¯Ø©
      if (user.profileBanner && user.profileBanner !== '') {
        const oldBannerPath = path.join(process.cwd(), 'client', 'public', user.profileBanner);
        if (fs.existsSync(oldBannerPath)) {
          fs.unlinkSync(oldBannerPath);
          console.log('ğŸ—‘ï¸ ØªÙ… Ø­Ø°Ù ØµÙˆØ±Ø© Ø§Ù„Ø¨Ø§Ù†Ø± Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©:', user.profileBanner);
        }
      }

      // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨ØµÙˆØ±Ø© Ø§Ù„Ø¨Ø§Ù†Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
      const updatedUser = await storage.updateUser(parseInt(userId), { profileBanner: tempBannerUrl });
      
      console.log('âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« ØµÙˆØ±Ø© Ø§Ù„Ø¨Ø§Ù†Ø± Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…:', updatedUser?.username);

      // Ø¥Ø±Ø³Ø§Ù„ ØªØ­Ø¯ÙŠØ« WebSocket Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
      if (wss && updatedUser) {
        wss.clients.forEach((client: WebSocketClient) => {
          if (client.readyState === WebSocket.OPEN) {
            client.send(JSON.stringify({
              type: 'userUpdated',
              user: updatedUser
            }));
          }
        });
      }

      res.json({
        success: true,
        message: 'ØªÙ… Ø­ÙØ¸ ØµÙˆØ±Ø© Ø§Ù„Ø¨Ø§Ù†Ø± Ø¨Ù†Ø¬Ø§Ø­',
        bannerUrl: tempBannerUrl,
        user: updatedUser
      });

    } catch (error) {
      console.error('Error uploading profile banner:', error);
      res.status(500).json({ 
        error: error instanceof Error ? error.message : 'Ø®Ø·Ø£ ÙÙŠ Ø±ÙØ¹ ØµÙˆØ±Ø© Ø§Ù„Ø¨Ø±ÙˆÙØ§ÙŠÙ„' 
      });
    }
  });

  // Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¥Ø®ÙØ§Ø¡ Ù„Ù„Ø¥Ø¯Ù…Ù† ÙˆØ§Ù„Ù…Ø§Ù„Ùƒ
  app.post("/api/users/:userId/toggle-hidden", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const { isHidden } = req.body;
      
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ error: "Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯" });
      }
      
      // ÙÙ‚Ø· Ø§Ù„Ø¥Ø¯Ù…Ù† ÙˆØ§Ù„Ù…Ø§Ù„Ùƒ ÙŠÙ…ÙƒÙ†Ù‡Ù… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¥Ø®ÙØ§Ø¡
      if (user.userType !== 'admin' && user.userType !== 'owner') {
        return res.status(403).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ù„Ùƒ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡" });
      }
      
      await storage.setUserHiddenStatus(userId, isHidden);
      
      res.json({ 
        message: isHidden ? "ØªÙ… ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ù…Ø®ÙÙŠØ©" : "ØªÙ… Ø¥Ù„ØºØ§Ø¡ ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ù…Ø®ÙÙŠØ©",
        isHidden 
      });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø¥Ø®ÙØ§Ø¡" });
    }
  });

  // Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ØªØ¬Ø§Ù‡Ù„
  app.post("/api/users/:userId/ignore/:targetId", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const targetId = parseInt(req.params.targetId);
      
      await storage.addIgnoredUser(userId, targetId);
      
      res.json({ message: "ØªÙ… ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…" });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…" });
    }
  });

  app.delete("/api/users/:userId/ignore/:targetId", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const targetId = parseInt(req.params.targetId);
      
      await storage.removeIgnoredUser(userId, targetId);
      
      res.json({ message: "ØªÙ… Ø¥Ù„ØºØ§Ø¡ ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…" });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø¥Ù„ØºØ§Ø¡ ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…" });
    }
  });

  app.get("/api/users/:userId/ignored", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const ignoredUsers = await storage.getIgnoredUsers(userId);
      
      res.json({ ignoredUsers });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ØªØ¬Ø§Ù‡Ù„ÙŠÙ†" });
    }
  });

  // API endpoints Ù„Ù„Ø¥Ø¯Ø§Ø±Ø©
  app.get("/api/moderation/actions", async (req, res) => {
    try {
      // ÙØ­Øµ ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ø¥Ø¯Ù…Ù†
      const { userId } = req.query;
      if (!userId) {
        return res.status(401).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ - Ù„Ù„Ø¥Ø¯Ù…Ù† ÙˆØ§Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·" });
      }
      
      const user = await storage.getUser(parseInt(userId as string));
      if (!user || (user.userType !== 'admin' && user.userType !== 'owner')) {
        return res.status(403).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ - Ù„Ù„Ø¥Ø¯Ù…Ù† ÙˆØ§Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·" });
      }
      
      const actions = moderationSystem.getModerationLog();
      res.json({ actions });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø³Ø¬Ù„ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©" });
    }
  });

  app.get("/api/moderation/reports", async (req, res) => {
    try {
      const { userId } = req.query;
      if (!userId) {
        return res.status(401).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ - Ù„Ù„Ø¥Ø¯Ù…Ù† ÙˆØ§Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·" });
      }
      
      const user = await storage.getUser(parseInt(userId as string));
      if (!user || (user.userType !== 'admin' && user.userType !== 'owner')) {
        return res.status(403).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ - Ù„Ù„Ø¥Ø¯Ù…Ù† ÙˆØ§Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·" });
      }
      
      const reports = spamProtection.getPendingReports();
      res.json({ reports });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ±" });
    }
  });

  app.post("/api/moderation/report", async (req, res) => {
    try {
      const { reporterId, reportedUserId, reason, content, messageId } = req.body;
      
      const report = spamProtection.addReport(reporterId, reportedUserId, reason, content, messageId);
      res.json({ message: "ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø¨Ù†Ø¬Ø§Ø­", report });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙ‚Ø±ÙŠØ±" });
    }
  });

  app.post("/api/moderation/mute", async (req, res) => {
    try {
      const { moderatorId, targetUserId, reason, duration } = req.body;
      
      const success = await moderationSystem.muteUser(moderatorId, targetUserId, reason, duration);
      if (success) {
        res.json({ message: "ØªÙ… ÙƒØªÙ… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­" });
      } else {
        res.status(400).json({ error: "ÙØ´Ù„ ÙÙŠ ÙƒØªÙ… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…" });
      }
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ ÙƒØªÙ… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…" });
    }
  });

  app.post("/api/moderation/ban", async (req, res) => {
    try {
      const { moderatorId, targetUserId, reason, duration } = req.body;
      
      const success = await moderationSystem.banUser(moderatorId, targetUserId, reason, duration);
      if (success) {
        res.json({ message: "ØªÙ… Ø·Ø±Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­" });
      } else {
        res.status(400).json({ error: "ÙØ´Ù„ ÙÙŠ Ø·Ø±Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…" });
      }
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø·Ø±Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…" });
    }
  });

  app.post("/api/moderation/block", async (req, res) => {
    try {
      const { moderatorId, targetUserId, reason } = req.body;
      
      const success = await moderationSystem.blockUser(moderatorId, targetUserId, reason);
      if (success) {
        res.json({ message: "ØªÙ… Ø­Ø¬Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­" });
      } else {
        res.status(400).json({ error: "ÙØ´Ù„ ÙÙŠ Ø­Ø¬Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…" });
      }
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø­Ø¬Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…" });
    }
  });

  app.post("/api/moderation/promote", async (req, res) => {
    try {
      const { moderatorId, targetUserId, newRole } = req.body;
      
      const success = await moderationSystem.promoteUser(moderatorId, targetUserId, newRole);
      if (success) {
        res.json({ message: "ØªÙ… ØªØ±Ù‚ÙŠØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­" });
      } else {
        res.status(400).json({ error: "ÙØ´Ù„ ÙÙŠ ØªØ±Ù‚ÙŠØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…" });
      }
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ ØªØ±Ù‚ÙŠØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…" });
    }
  });

  app.post("/api/moderation/unmute", async (req, res) => {
    try {
      const { moderatorId, targetUserId } = req.body;
      
      const success = await moderationSystem.unmuteUser(moderatorId, targetUserId);
      if (success) {
        res.json({ message: "ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ÙƒØªÙ… Ø¨Ù†Ø¬Ø§Ø­" });
      } else {
        res.status(400).json({ error: "ÙØ´Ù„ ÙÙŠ Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ÙƒØªÙ…" });
      }
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ÙƒØªÙ…" });
    }
  });

  app.post("/api/moderation/unblock", async (req, res) => {
    try {
      const { moderatorId, targetUserId } = req.body;
      
      const success = await moderationSystem.unblockUser(moderatorId, targetUserId);
      if (success) {
        res.json({ message: "ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø­Ø¬Ø¨ Ø¨Ù†Ø¬Ø§Ø­" });
      } else {
        res.status(400).json({ error: "ÙØ´Ù„ ÙÙŠ Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø­Ø¬Ø¨" });
      }
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø­Ø¬Ø¨" });
    }
  });

  // API Ù„ØªØ¨Ø¯ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ø¥Ø®ÙØ§Ø¡ Ù„Ù„Ø¥Ø¯Ù…Ù† ÙˆØ§Ù„Ù…Ø§Ù„Ùƒ
  app.post("/api/users/:userId/toggle-hidden", async (req, res) => {
    try {
      const { userId } = req.params;
      const { isHidden } = req.body;
      const userIdNum = parseInt(userId);
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
      const user = await storage.getUser(userIdNum);
      if (!user) {
        return res.status(404).json({ error: "Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯" });
      }
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª - ÙÙ‚Ø· Ù„Ù„Ø¥Ø¯Ù…Ù† ÙˆØ§Ù„Ù…Ø§Ù„Ùƒ
      if (user.userType !== 'admin' && user.userType !== 'owner') {
        return res.status(403).json({ error: "Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø§ØµÙŠØ© Ù„Ù„Ø¥Ø¯Ù…Ù† ÙˆØ§Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·" });
      }
      
      // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø¥Ø®ÙØ§Ø¡
      await storage.setUserHiddenStatus(userIdNum, isHidden);
      
      // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± WebSocket Ù„ØªØ­Ø¯ÙŠØ« Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ØªØµÙ„ÙŠÙ†
      wss.clients.forEach((client: WebSocketClient) => {
        if (client.readyState === WebSocket.OPEN) {
          client.send(JSON.stringify({
            type: 'userVisibilityChanged',
            userId: userIdNum,
            isHidden: isHidden
          }));
        }
      });
      
      res.json({ 
        message: isHidden ? "ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø®ÙÙŠ" : "ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø®ÙÙŠ",
        isHidden: isHidden
      });
      
    } catch (error) {
      console.error('Ø®Ø·Ø£ ÙÙŠ ØªØ¨Ø¯ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ø¥Ø®ÙØ§Ø¡:', error);
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ ØªØ¨Ø¯ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ø¥Ø®ÙØ§Ø¡" });
    }
  });

  // API Ù„ØªØ­Ø¯ÙŠØ« Ù„ÙˆÙ† Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
  app.post("/api/users/:userId/username-color", async (req, res) => {
    try {
      const { userId } = req.params;
      const { color } = req.body;
      const userIdNum = parseInt(userId);
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ù„ÙˆÙ† (hex color)
      if (!color || !/^#[0-9A-F]{6}$/i.test(color)) {
        return res.status(400).json({ error: "Ù„ÙˆÙ† ØºÙŠØ± ØµØ­ÙŠØ­" });
      }
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
      const user = await storage.getUser(userIdNum);
      if (!user) {
        return res.status(404).json({ error: "Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯" });
      }
      
      // ØªØ­Ø¯ÙŠØ« Ù„ÙˆÙ† Ø§Ù„Ø§Ø³Ù…
      await storage.updateUser(userIdNum, { usernameColor: color });
      
      // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± WebSocket Ù„ØªØ­Ø¯ÙŠØ« Ù„ÙˆÙ† Ø§Ù„Ø§Ø³Ù…
      wss.clients.forEach((client: WebSocketClient) => {
        if (client.readyState === WebSocket.OPEN) {
          client.send(JSON.stringify({
            type: 'usernameColorChanged',
            userId: userIdNum,
            color: color
          }));
        }
      });
      
      res.json({ 
        message: "ØªÙ… ØªØ­Ø¯ÙŠØ« Ù„ÙˆÙ† Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­",
        color: color
      });
      
    } catch (error) {
      console.error('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ù„ÙˆÙ† Ø§Ù„Ø§Ø³Ù…:', error);
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ù„ÙˆÙ† Ø§Ù„Ø§Ø³Ù…" });
    }
  });

  const httpServer = createServer(app);
  wss = new WebSocketServer({ server: httpServer, path: '/ws' });
  
  // ØªØ·Ø¨ÙŠÙ‚ ÙØ­Øµ Ø§Ù„Ø£Ù…Ø§Ù† Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø·Ù„Ø¨Ø§Øª
  app.use(checkIPSecurity);
  app.use(advancedSecurityMiddleware);

  // Store connected clients
  const clients = new Set<WebSocketClient>();

  // Member registration route - Ù…Ø¹ Ø£Ù…Ø§Ù† Ù…Ø­Ø³Ù†
  app.post("/api/auth/register", async (req, res) => {
    try {
      const { username, password, confirmPassword, gender } = req.body;
      
      // ÙØ­Øµ Ø§Ù„Ø£Ù…Ø§Ù† Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
      if (!username?.trim() || !password?.trim() || !confirmPassword?.trim()) {
        return res.status(400).json({ error: "Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ù…Ø·Ù„ÙˆØ¨Ø©" });
      }

      // ÙØ­Øµ Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… - Ù…Ù†Ø¹ Ø§Ù„Ø£Ø­Ø±Ù Ø§Ù„Ø®Ø§ØµØ©
      if (!/^[\u0600-\u06FFa-zA-Z0-9_]{3,20}$/.test(username.trim())) {
        return res.status(400).json({ error: "Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¨ÙŠÙ† 3-20 Ø­Ø±Ù ÙˆÙ„Ø§ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø±Ù…ÙˆØ² Ø®Ø§ØµØ©" });
      }

      if (password !== confirmPassword) {
        return res.status(400).json({ error: "ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± Ù…ØªØ·Ø§Ø¨Ù‚Ø©" });
      }

      // ÙØ­Øµ Ù‚ÙˆØ© ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
      if (password.length < 6) {
        return res.status(400).json({ error: "ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† 6 Ø£Ø­Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„" });
      }
      
      if (!/(?=.*[0-9])/.test(password)) {
        return res.status(400).json({ error: "ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ÙŠØ¬Ø¨ Ø£Ù† ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø±Ù‚Ù… ÙˆØ§Ø­Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„" });
      }

      // Check if username already exists
      const existing = await storage.getUserByUsername(username);
      if (existing) {
        return res.status(400).json({ error: "Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„" });
      }

      const user = await storage.createUser({
        username,
        password,
        userType: "member",
        gender: gender || "male",
        profileImage: "/default_avatar.svg",
      });

      res.json({ user, message: "ØªÙ… Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­" });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Authentication routes
  app.post("/api/auth/guest", authLimiter, async (req, res) => {
    try {
      const { username, gender } = req.body;
      
      if (!username?.trim()) {
        return res.status(400).json({ error: "Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø·Ù„ÙˆØ¨" });
      }

      // Check if username already exists
      const existing = await storage.getUserByUsername(username);
      if (existing) {
        return res.status(400).json({ error: "Ø§Ù„Ø§Ø³Ù… Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„" });
      }

      const user = await storage.createUser({
        username,
        userType: "guest",
        gender: gender || "male",
        profileImage: "/default_avatar.svg",
      });

      res.json({ user });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  app.post("/api/auth/member", authLimiter, async (req, res) => {
    try {
      const { username, password } = req.body;
      
      if (!username?.trim() || !password?.trim()) {
        return res.status(400).json({ error: "Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙˆÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù…Ø·Ù„ÙˆØ¨Ø§Ù†" });
      }

      const user = await storage.getUserByUsername(username);
      if (!user) {
        return res.status(401).json({ error: "Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯" });
      }

      if (user.password !== password) {
        return res.status(401).json({ error: "ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©" });
      }

      await storage.setUserOnlineStatus(user.id, true);
      res.json({ user });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // User routes - Ø¥Ø¶Ø§ÙØ© Ù…Ø³Ø§Ø± Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
  app.get("/api/users", async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      res.json({ users });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  app.get("/api/all-users", async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      res.json({ users });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  app.get("/api/users/online", async (req, res) => {
    try {
      const users = await storage.getOnlineUsers();
      res.json({ users });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  app.put("/api/users/:id", async (req, res) => {
    try {
      const userId = parseInt(req.params.id);
      const updates = req.body;
      
      const user = await storage.updateUser(userId, updates);
      if (!user) {
        return res.status(404).json({ error: "Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯" });
      }

      // Broadcast user update to all connected clients
      const connectedClients = Array.from(clients);
      connectedClients.forEach(client => {
        if (client.readyState === WebSocket.OPEN) {
          client.send(JSON.stringify({
            type: 'userUpdated',
            user: user,
          }));
        }
      });

      res.json({ user });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Message routes
  // Ø¥Ø¶Ø§ÙØ© Ù…Ø³Ø§Ø± Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
  app.post("/api/messages", async (req, res) => {
    try {
      const { senderId, receiverId, content, messageType, isPrivate = false } = req.body;
      
      if (!senderId || !content || !messageType) {
        return res.status(400).json({ error: "Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù…ÙÙ‚ÙˆØ¯Ø©" });
      }

      const message = await storage.createMessage({
        senderId,
        receiverId: isPrivate ? receiverId : null,
        content,
        messageType,
        isPrivate,
        timestamp: new Date()
      });

      // Broadcast message to connected clients
      if (wss) {
        wss.clients.forEach((client: WebSocketClient) => {
          if (client.readyState === WebSocket.OPEN) {
            client.send(JSON.stringify({
              type: 'newMessage',
              message: {
                ...message,
                sender: {
                  id: senderId,
                  username: '',
                  userType: ''
                }
              }
            }));
          }
        });
      }

      res.json({ message, success: true });
    } catch (error) {
      console.error("Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø±Ø³Ø§Ù„Ø©:", error);
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø±Ø³Ø§Ù„Ø©" });
    }
  });

  app.get("/api/messages/public", async (req, res) => {
    try {
      const limit = parseInt(req.query.limit as string) || 50;
      const messages = await storage.getPublicMessages(limit);
      
      // Get user details for each message
      const messagesWithUsers = await Promise.all(
        messages.map(async (msg) => {
          const sender = msg.senderId ? await storage.getUser(msg.senderId) : null;
          return { ...msg, sender };
        })
      );

      res.json({ messages: messagesWithUsers });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  app.get("/api/messages/private/:userId1/:userId2", async (req, res) => {
    try {
      const userId1 = parseInt(req.params.userId1);
      const userId2 = parseInt(req.params.userId2);
      const limit = parseInt(req.query.limit as string) || 50;
      
      const messages = await storage.getPrivateMessages(userId1, userId2, limit);
      
      const messagesWithUsers = await Promise.all(
        messages.map(async (msg) => {
          const sender = msg.senderId ? await storage.getUser(msg.senderId) : null;
          return { ...msg, sender };
        })
      );

      res.json({ messages: messagesWithUsers });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Profile picture upload (members only)
  app.post('/api/users/:id/profile-image', async (req, res) => {
    try {
      const userId = parseInt(req.params.id);
      const { imageData } = req.body;
      
      if (!imageData) {
        return res.status(400).json({ error: "ØµÙˆØ±Ø© Ù…Ø·Ù„ÙˆØ¨Ø©" });
      }

      // Check if user is a member
      const existingUser = await storage.getUser(userId);
      if (!existingUser) {
        return res.status(404).json({ error: "Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯" });
      }

      // Allow members and owners to upload profile pictures (not guests)
      if (existingUser.userType === 'guest') {
        return res.status(403).json({ 
          error: "Ø±ÙØ¹ Ø§Ù„ØµÙˆØ± Ø§Ù„Ø´Ø®ØµÙŠØ© Ù…ØªØ§Ø­ Ù„Ù„Ø£Ø¹Ø¶Ø§Ø¡ ÙÙ‚Ø·",
          userType: existingUser.userType,
          userId: userId
        });
      }

      const user = await storage.updateUser(userId, { profileImage: imageData });
      if (!user) {
        return res.status(500).json({ error: "ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙˆØ±Ø©" });
      }

      // Broadcast user update to all connected clients
      broadcast({
        type: 'userUpdated',
        user
      });

      res.json({ user, message: "ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø´Ø®ØµÙŠØ© Ø¨Ù†Ø¬Ø§Ø­" });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Friend routes
  app.get("/api/friends/:userId", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const friends = await storage.getFriends(userId);
      res.json({ friends });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  app.post("/api/friends", async (req, res) => {
    try {
      const { userId, friendId } = req.body;
      const friendship = await storage.addFriend(userId, friendId);
      res.json({ friendship });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });



  // Update username color
  app.post('/api/users/:userId/color', async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const { color } = req.body;
      
      if (!userId || !color) {
        return res.status(400).json({ message: 'Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙˆØ§Ù„Ù„ÙˆÙ† Ù…Ø·Ù„ÙˆØ¨Ø§Ù†' });
      }

      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: 'Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯' });
      }

      // Update username color
      await storage.updateUser(userId, { usernameColor: color });
      
      // Broadcast the color change to all connected clients
      broadcast({
        type: 'usernameColorChanged',
        userId: userId,
        color: color,
        username: user.username
      });
      
      res.json({ 
        success: true, 
        message: 'ØªÙ… ØªØ­Ø¯ÙŠØ« Ù„ÙˆÙ† Ø§Ù„Ø§Ø³Ù… Ø¨Ù†Ø¬Ø§Ø­',
        color 
      });
    } catch (error) {
      console.error('Error updating username color:', error);
      res.status(500).json({ message: 'Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ù„ÙˆÙ† Ø§Ù„Ø§Ø³Ù…' });
    }
  });

  // WebSocket handling
  wss.on('connection', (ws: WebSocketClient) => {
    console.log('Ø§ØªØµØ§Ù„ WebSocket Ø¬Ø¯ÙŠØ¯');
    clients.add(ws);
    
    // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© ØªØ±Ø­ÙŠØ¨ ÙÙˆØ±ÙŠØ©
    ws.send(JSON.stringify({
      type: 'connected',
      message: 'Ù…ØªØµÙ„ Ø¨Ù†Ø¬Ø§Ø­'
    }));
    
    // heartbeat Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ø§ØªØµØ§Ù„
    const heartbeat = setInterval(() => {
      if (ws.readyState === WebSocket.OPEN) {
        ws.ping();
      } else {
        clearInterval(heartbeat);
      }
    }, 30000);

    ws.on('message', async (data) => {
      try {
        const message = JSON.parse(data.toString());
        console.log(`Ø±Ø³Ø§Ù„Ø© WebSocket Ù…Ù† ${ws.username || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'}: ${message.type}`);
        
        switch (message.type) {
          case 'auth':
            ws.userId = message.userId;
            ws.username = message.username;
            
            // ÙØ­Øµ Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù‚Ø¨Ù„ Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ø§ØªØµØ§Ù„
            const authUserStatus = await moderationSystem.checkUserStatus(message.userId);
            if (authUserStatus.isBlocked) {
              ws.send(JSON.stringify({
                type: 'error',
                message: 'Ø£Ù†Øª Ù…Ø­Ø¬ÙˆØ¨ Ù†Ù‡Ø§Ø¦ÙŠØ§Ù‹ Ù…Ù† Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©',
                action: 'blocked'
              }));
              ws.close();
              return;
            }
            
            if (authUserStatus.isBanned) {
              ws.send(JSON.stringify({
                type: 'error',
                message: `Ø£Ù†Øª Ù…Ø·Ø±ÙˆØ¯ Ù…Ù† Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ù„Ù…Ø¯Ø© ${authUserStatus.timeLeft} Ø¯Ù‚ÙŠÙ‚Ø©`,
                action: 'banned'
              }));
              ws.close();
              return;
            }
            
            await storage.setUserOnlineStatus(message.userId, true);
            
            // Broadcast user joined
            broadcast({
              type: 'userJoined',
              user: await storage.getUser(message.userId),
            }, ws);
            
            // Send online users list with moderation status
            const onlineUsers = await storage.getOnlineUsers();
            const usersWithStatus = await Promise.all(
              onlineUsers.map(async (user) => {
                const status = await moderationSystem.checkUserStatus(user.id);
                return {
                  ...user,
                  isMuted: status.isMuted,
                  isBlocked: status.isBlocked,
                  isBanned: status.isBanned
                };
              })
            );
            
            ws.send(JSON.stringify({
              type: 'onlineUsers',
              users: usersWithStatus,
            }));
            break;

          case 'publicMessage':
            if (ws.userId) {
              // ÙØ­Øµ Ø­Ø§Ù„Ø© Ø§Ù„ÙƒØªÙ… ÙˆØ§Ù„Ø­Ø¸Ø±
              const userStatus = await moderationSystem.checkUserStatus(ws.userId);
              if (userStatus.isMuted) {
                ws.send(JSON.stringify({
                  type: 'error',
                  message: 'Ø£Ù†Øª Ù…ÙƒØªÙˆÙ… ÙˆÙ„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ø¦Ù„ ÙÙŠ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ø¹Ø§Ù…Ø©. ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„ØªØ­Ø¯Ø« ÙÙŠ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø®Ø§ØµØ©.',
                  action: 'muted'
                }));
                console.log(`ğŸ”‡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ${ws.username} Ù…Ø­Ø§ÙˆÙ„ Ø§Ù„ÙƒØªØ§Ø¨Ø© ÙˆÙ‡Ùˆ Ù…ÙƒØªÙˆÙ…`);
                break;
              }
              
              if (userStatus.isBanned) {
                ws.send(JSON.stringify({
                  type: 'error',
                  message: 'Ø£Ù†Øª Ù…Ø·Ø±ÙˆØ¯ Ù…Ù† Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©',
                  action: 'banned'
                }));
                break;
              }
              
              if (userStatus.isBlocked) {
                ws.send(JSON.stringify({
                  type: 'error',
                  message: 'Ø£Ù†Øª Ù…Ø­Ø¬ÙˆØ¨ Ù†Ù‡Ø§Ø¦ÙŠØ§Ù‹ Ù…Ù† Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©',
                  action: 'blocked'
                }));
                // Ù‚Ø·Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„ Ù„Ù„Ù…Ø­Ø¬ÙˆØ¨ÙŠÙ†
                ws.close();
                break;
              }

              // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù…Ø­ØªÙˆÙ‰
              const sanitizedContent = sanitizeInput(message.content);
              
              // ÙØ­Øµ ØµØ­Ø© Ø§Ù„Ù…Ø­ØªÙˆÙ‰
              const contentCheck = validateMessageContent(sanitizedContent);
              if (!contentCheck.isValid) {
                ws.send(JSON.stringify({
                  type: 'error',
                  message: contentCheck.reason
                }));
                break;
              }
              
              // ÙØ­Øµ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¶Ø¯ Ø§Ù„Ø³Ø¨Ø§Ù…
              const spamCheck = spamProtection.checkMessage(ws.userId, sanitizedContent);
              if (!spamCheck.isAllowed) {
                ws.send(JSON.stringify({
                  type: 'error',
                  message: spamCheck.reason,
                  action: spamCheck.action
                }));
                
                // Ø¥Ø±Ø³Ø§Ù„ ØªØ­Ø°ÙŠØ± Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
                if (spamCheck.action === 'warn') {
                  ws.send(JSON.stringify({
                    type: 'warning',
                    message: 'ØªÙ… Ø¥Ø¹Ø·Ø§Ø¤Ùƒ ØªØ­Ø°ÙŠØ± Ø¨Ø³Ø¨Ø¨ Ù…Ø®Ø§Ù„ÙØ© Ù‚ÙˆØ§Ù†ÙŠÙ† Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©'
                  }));
                }
                break;
              }

              const newMessage = await storage.createMessage({
                senderId: ws.userId,
                content: sanitizedContent,
                messageType: message.messageType || 'text',
                isPrivate: false,
              });
              
              const sender = await storage.getUser(ws.userId);
              broadcast({
                type: 'newMessage',
                message: { ...newMessage, sender },
              });
            }
            break;

          case 'privateMessage':
            if (ws.userId) {
              // Ù…Ù†Ø¹ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ù„Ù„Ù†ÙØ³
              if (ws.userId === message.receiverId) {
                ws.send(JSON.stringify({
                  type: 'error',
                  message: 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ù„Ù†ÙØ³Ùƒ',
                  action: 'blocked'
                }));
                break;
              }

              // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù…Ø­ØªÙˆÙ‰
              const sanitizedContent = sanitizeInput(message.content);
              
              // ÙØ­Øµ ØµØ­Ø© Ø§Ù„Ù…Ø­ØªÙˆÙ‰
              const contentCheck = validateMessageContent(sanitizedContent);
              if (!contentCheck.isValid) {
                ws.send(JSON.stringify({
                  type: 'error',
                  message: contentCheck.reason
                }));
                break;
              }
              
              // ÙØ­Øµ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø®Ø§ØµØ© Ø¶Ø¯ Ø§Ù„Ø³Ø¨Ø§Ù…
              const spamCheck = spamProtection.checkMessage(ws.userId, sanitizedContent);
              if (!spamCheck.isAllowed) {
                ws.send(JSON.stringify({
                  type: 'error',
                  message: spamCheck.reason,
                  action: spamCheck.action
                }));
                break;
              }

              const newMessage = await storage.createMessage({
                senderId: ws.userId,
                receiverId: message.receiverId,
                content: sanitizedContent,
                messageType: message.messageType || 'text',
                isPrivate: true,
              });
              
              const sender = await storage.getUser(ws.userId);
              const messageWithSender = { ...newMessage, sender };
              
              // Send to receiver only (don't send to sender)
              const receiverClient = Array.from(clients).find(
                client => client.userId === message.receiverId
              );
              if (receiverClient && receiverClient.readyState === WebSocket.OPEN) {
                receiverClient.send(JSON.stringify({
                  type: 'privateMessage',
                  message: messageWithSender,
                }));
              }
              
              // Send back to sender with confirmation
              ws.send(JSON.stringify({
                type: 'privateMessage',
                message: messageWithSender,
              }));
            }
            break;

          case 'typing':
            if (ws.userId) {
              broadcast({
                type: 'userTyping',
                userId: ws.userId,
                username: ws.username,
                isTyping: message.isTyping,
              }, ws);
            }
            break;
        }
      } catch (error) {
        console.error('WebSocket message error:', error);
      }
    });

    ws.on('close', async () => {
      clients.delete(ws);
      if (ws.userId) {
        await storage.setUserOnlineStatus(ws.userId, false);
        broadcast({
          type: 'userLeft',
          userId: ws.userId,
          username: ws.username,
        }, ws);
      }
    });
  });

  function broadcast(message: any, sender?: WebSocketClient) {
    const messageStr = JSON.stringify(message);
    clients.forEach(client => {
      if (client !== sender && client.readyState === WebSocket.OPEN) {
        client.send(messageStr);
      }
    });
  }

  // Friend system APIs
  
  // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
  app.get("/api/users/search", async (req, res) => {
    try {
      const { q, userId } = req.query;
      
      if (!q || !userId) {
        return res.status(400).json({ error: "Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„Ø¨Ø­Ø« Ù…Ø·Ù„ÙˆØ¨Ø©" });
      }

      const allUsers = await storage.getAllUsers();
      const searchTerm = (q as string).toLowerCase();
      
      const filteredUsers = allUsers.filter(user => 
        user.id !== parseInt(userId as string) && // Ø§Ø³ØªØ¨Ø¹Ø§Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ
        user.username.toLowerCase().includes(searchTerm)
      ).slice(0, 10); // Ø­Ø¯ Ø£Ù‚ØµÙ‰ 10 Ù†ØªØ§Ø¦Ø¬

      res.json({ users: filteredUsers });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ ØµØ¯Ø§Ù‚Ø©
  app.post("/api/friend-requests", async (req, res) => {
    try {
      const { senderId, receiverId } = req.body;
      
      if (!senderId || !receiverId) {
        return res.status(400).json({ error: "Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø±Ø³Ù„ ÙˆØ§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ Ù…Ø·Ù„ÙˆØ¨Ø©" });
      }

      if (senderId === receiverId) {
        return res.status(400).json({ error: "Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ ØµØ¯Ø§Ù‚Ø© Ù„Ù†ÙØ³Ùƒ" });
      }

      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø·Ù„Ø¨ Ø³Ø§Ø¨Ù‚
      const existingRequest = await storage.getFriendRequest(senderId, receiverId);
      if (existingRequest) {
        return res.status(400).json({ error: "Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø© Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„" });
      }

      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØµØ¯Ø§Ù‚Ø© Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©
      const friendship = await storage.getFriendship(senderId, receiverId);
      if (friendship) {
        return res.status(400).json({ error: "Ø£Ù†ØªÙ…Ø§ Ø£ØµØ¯Ù‚Ø§Ø¡ Ø¨Ø§Ù„ÙØ¹Ù„" });
      }

      const request = await storage.createFriendRequest(senderId, receiverId);
      
      // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ø¹Ø¨Ø± WebSocket
      const sender = await storage.getUser(senderId);
      broadcast({
        type: 'friendRequestReceived',
        targetUserId: receiverId,
        senderName: sender?.username,
        senderId: senderId
      });

      // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø± Ø­Ù‚ÙŠÙ‚ÙŠ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      await storage.createNotification({
        userId: receiverId,
        type: 'friendRequest',
        title: 'ğŸ‘« Ø·Ù„Ø¨ ØµØ¯Ø§Ù‚Ø© Ø¬Ø¯ÙŠØ¯',
        message: `Ø£Ø±Ø³Ù„ ${sender?.username} Ø·Ù„Ø¨ ØµØ¯Ø§Ù‚Ø© Ø¥Ù„ÙŠÙƒ`,
        data: { requestId: request.id, senderId: senderId, senderName: sender?.username }
      });

      res.json({ message: "ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø©", request });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø·Ù„Ø¨Ø§Øª Ø§Ù„ØµØ¯Ø§Ù‚Ø© Ø§Ù„ÙˆØ§Ø±Ø¯Ø©
  app.get("/api/friend-requests/incoming/:userId", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const requests = await storage.getIncomingFriendRequests(userId);
      res.json({ requests });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø·Ù„Ø¨Ø§Øª Ø§Ù„ØµØ¯Ø§Ù‚Ø© Ø§Ù„ØµØ§Ø¯Ø±Ø©
  app.get("/api/friend-requests/outgoing/:userId", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const requests = await storage.getOutgoingFriendRequests(userId);
      res.json({ requests });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Ù‚Ø¨ÙˆÙ„ Ø·Ù„Ø¨ ØµØ¯Ø§Ù‚Ø©
  app.post("/api/friend-requests/:requestId/accept", async (req, res) => {
    try {
      const requestId = parseInt(req.params.requestId);
      const { userId } = req.body;
      
      const request = await storage.getFriendRequestById(requestId);
      if (!request || request.receiverId !== userId) {
        return res.status(403).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­" });
      }

      // Ù‚Ø¨ÙˆÙ„ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø© ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„ØµØ¯Ø§Ù‚Ø©
      await storage.acceptFriendRequest(requestId);
      await storage.addFriend(request.senderId, request.receiverId);
      
      // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
      const receiver = await storage.getUser(userId);
      const sender = await storage.getUser(request.senderId);
      
      // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± WebSocket Ù„ØªØ­Ø¯ÙŠØ« Ù‚ÙˆØ§Ø¦Ù… Ø§Ù„Ø£ØµØ¯Ù‚Ø§Ø¡
      broadcast({
        type: 'friendAdded',
        targetUserId: request.senderId,
        friendId: request.receiverId,
        friendName: receiver?.username
      });
      
      broadcast({
        type: 'friendAdded', 
        targetUserId: request.receiverId,
        friendId: request.senderId,
        friendName: sender?.username
      });
      broadcast({
        type: 'friendRequestAccepted',
        targetUserId: request.senderId,
        senderName: receiver?.username
      });

      // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø± Ø­Ù‚ÙŠÙ‚ÙŠ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      await storage.createNotification({
        userId: request.senderId,
        type: 'friendAccepted',
        title: 'âœ… ØªÙ… Ù‚Ø¨ÙˆÙ„ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø©',
        message: `Ù‚Ø¨Ù„ ${receiver?.username} Ø·Ù„Ø¨ ØµØ¯Ø§Ù‚ØªÙƒ`,
        data: { friendId: userId, friendName: receiver?.username }
      });

      res.json({ message: "ØªÙ… Ù‚Ø¨ÙˆÙ„ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø©" });
    } catch (error) {
      console.error("Ø®Ø·Ø£ ÙÙŠ Ù‚Ø¨ÙˆÙ„ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø©:", error);
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Ø±ÙØ¶ Ø·Ù„Ø¨ ØµØ¯Ø§Ù‚Ø©
  app.post("/api/friend-requests/:requestId/decline", async (req, res) => {
    try {
      const requestId = parseInt(req.params.requestId);
      const { userId } = req.body;
      
      const request = await storage.getFriendRequestById(requestId);
      if (!request || request.receiverId !== userId) {
        return res.status(403).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­" });
      }

      await storage.declineFriendRequest(requestId);
      res.json({ message: "ØªÙ… Ø±ÙØ¶ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø©" });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Ø¥Ù„ØºØ§Ø¡ Ø·Ù„Ø¨ ØµØ¯Ø§Ù‚Ø©
  app.post("/api/friend-requests/:requestId/cancel", async (req, res) => {
    try {
      const requestId = parseInt(req.params.requestId);
      const { userId } = req.body;
      
      const request = await storage.getFriendRequestById(requestId);
      if (!request || request.senderId !== userId) {
        return res.status(403).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­" });
      }

      await storage.deleteFriendRequest(requestId);
      res.json({ message: "ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø©" });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // ØªØ¬Ø§Ù‡Ù„ Ø·Ù„Ø¨ ØµØ¯Ø§Ù‚Ø©
  app.post("/api/friend-requests/:requestId/ignore", async (req, res) => {
    try {
      const requestId = parseInt(req.params.requestId);
      const { userId } = req.body;
      
      const request = await storage.getFriendRequestById(requestId);
      if (!request || request.receiverId !== userId) {
        return res.status(403).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­" });
      }

      await storage.ignoreFriendRequest(requestId);
      res.json({ message: "ØªÙ… ØªØ¬Ø§Ù‡Ù„ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø©" });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£ØµØ¯Ù‚Ø§Ø¡
  app.get("/api/friends/:userId", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const friends = await storage.getFriends(userId);
      res.json({ friends });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Ø¥Ø²Ø§Ù„Ø© ØµØ¯ÙŠÙ‚
  app.delete("/api/friends/:userId/:friendId", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const friendId = parseInt(req.params.friendId);
      
      await storage.removeFriend(userId, friendId);
      res.json({ message: "ØªÙ… Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØµØ¯ÙŠÙ‚" });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // API routes for spam protection and reporting
  
  // Ø¥Ø¶Ø§ÙØ© ØªØ¨Ù„ÙŠØº
  app.post("/api/reports", async (req, res) => {
    try {
      const { reporterId, reportedUserId, reason, content, messageId } = req.body;
      
      if (!reporterId || !reportedUserId || !reason || !content) {
        return res.status(400).json({ error: "Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ù…Ø·Ù„ÙˆØ¨Ø©" });
      }

      // Ù…Ù†Ø¹ Ø§Ù„Ø¨Ù„Ø§Øº Ø¹Ù„Ù‰ Ø§Ù„Ø¥Ø¯Ù…Ù† ÙˆØ§Ù„Ù…Ø´Ø±Ù ÙˆØ§Ù„Ù…Ø§Ù„Ùƒ
      const reportedUser = await storage.getUser(reportedUserId);
      if (reportedUser && ['admin', 'moderator', 'owner'].includes(reportedUser.userType)) {
        return res.status(403).json({ 
          error: "Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„Ø¥Ø¨Ù„Ø§Øº Ø¹Ù† Ø£Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© (Ø§Ù„Ù…Ø´Ø±ÙØŒ Ø§Ù„Ø¥Ø¯Ù…Ù†ØŒ Ø§Ù„Ù…Ø§Ù„Ùƒ)" 
        });
      }

      const report = spamProtection.addReport(reporterId, reportedUserId, reason, content, messageId);
      res.json({ report, message: "ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªØ¨Ù„ÙŠØº Ø¨Ù†Ø¬Ø§Ø­" });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØªØ¨Ù„ÙŠØºØ§Øª Ø§Ù„Ù…Ø¹Ù„Ù‚Ø© (Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ†)
  app.get("/api/reports/pending", async (req, res) => {
    try {
      const { userId } = req.query;
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø´Ø±Ù
      const user = await storage.getUser(parseInt(userId as string));
      if (!user || user.userType !== 'owner') {
        return res.status(403).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­" });
      }

      const reports = spamProtection.getPendingReports();
      res.json({ reports });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Ù…Ø±Ø§Ø¬Ø¹Ø© ØªØ¨Ù„ÙŠØº (Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ†)
  app.patch("/api/reports/:reportId", async (req, res) => {
    try {
      const { reportId } = req.params;
      const { action, userId } = req.body;
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø´Ø±Ù
      const user = await storage.getUser(userId);
      if (!user || user.userType !== 'owner') {
        return res.status(403).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­" });
      }

      const success = spamProtection.reviewReport(parseInt(reportId), action);
      if (success) {
        res.json({ message: "ØªÙ… Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„ØªØ¨Ù„ÙŠØº" });
      } else {
        res.status(404).json({ error: "Ø§Ù„ØªØ¨Ù„ÙŠØº ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯" });
      }
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
  app.get("/api/users/:userId/spam-status", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const status = spamProtection.getUserStatus(userId);
      res.json({ status });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ù†Ù‚Ø§Ø· Ø§Ù„Ø³Ø¨Ø§Ù… (Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ†)
  app.post("/api/users/:userId/reset-spam", async (req, res) => {
    try {
      const { userId } = req.params;
      const { adminId } = req.body;
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø´Ø±Ù
      const admin = await storage.getUser(adminId);
      if (!admin || admin.userType !== 'owner') {
        return res.status(403).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­" });
      }

      spamProtection.resetUserSpamScore(parseInt(userId));
      res.json({ message: "ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ù†Ù‚Ø§Ø· Ø§Ù„Ø³Ø¨Ø§Ù…" });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø³Ø¨Ø§Ù… (Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ†)
  app.get("/api/spam-stats", async (req, res) => {
    try {
      const { userId } = req.query;
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø´Ø±Ù
      const user = await storage.getUser(parseInt(userId as string));
      if (!user || user.userType !== 'owner') {
        return res.status(403).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­" });
      }

      const stats = spamProtection.getStats();
      res.json({ stats });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Moderation routes
  app.post("/api/moderation/mute", async (req, res) => {
    try {
      const { moderatorId, targetUserId, reason, duration } = req.body;
      const clientIP = req.ip || req.connection.remoteAddress || 'unknown';
      const deviceId = req.headers['user-agent'] || 'unknown';
      
      const success = await moderationSystem.muteUser(
        moderatorId, 
        targetUserId, 
        reason, 
        duration, 
        clientIP, 
        deviceId
      );
      
      if (success) {
        const moderator = await storage.getUser(moderatorId);
        const target = await storage.getUser(targetUserId);
        
        // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ø¹Ø§Ù…Ø©
        const systemMessage = `ğŸ”‡ ØªÙ… ÙƒØªÙ… ${target?.username} Ù…Ù† Ù‚Ø¨Ù„ ${moderator?.username} Ù„Ù…Ø¯Ø© ${duration} Ø¯Ù‚ÙŠÙ‚Ø© - Ø§Ù„Ø³Ø¨Ø¨: ${reason}`;
        
        broadcast({
          type: 'moderationAction',
          action: 'muted',
          targetUserId: targetUserId,
          message: systemMessage,
          reason,
          duration
        });

        // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…ÙƒØªÙˆÙ…
        broadcast({
          type: 'notification',
          targetUserId: targetUserId,
          notificationType: 'muted',
          message: `ØªÙ… ÙƒØªÙ…Ùƒ Ù…Ù† Ù‚Ø¨Ù„ ${moderator?.username} Ù„Ù…Ø¯Ø© ${duration} Ø¯Ù‚ÙŠÙ‚Ø© - Ø§Ù„Ø³Ø¨Ø¨: ${reason}`,
          moderatorName: moderator?.username
        });
        
        // Ù„Ø§ ÙŠØªÙ… Ù‚Ø·Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„ - Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙŠØ¨Ù‚Ù‰ ÙÙŠ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ù„ÙƒÙ† Ù…ÙƒØªÙˆÙ…
        res.json({ message: "ØªÙ… ÙƒØªÙ… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­ - ÙŠÙ…ÙƒÙ†Ù‡ Ø§Ù„Ø¨Ù‚Ø§Ø¡ ÙÙŠ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© ÙˆÙ„ÙƒÙ† Ù„Ø§ ÙŠÙ…ÙƒÙ†Ù‡ Ø§Ù„ØªØ­Ø¯Ø« ÙÙŠ Ø§Ù„Ø¹Ø§Ù…" });
      } else {
        res.status(403).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ù„Ùƒ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡" });
      }
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  app.post("/api/moderation/unmute", async (req, res) => {
    try {
      const { moderatorId, targetUserId } = req.body;
      
      const success = await moderationSystem.unmuteUser(moderatorId, targetUserId);
      
      if (success) {
        const moderator = await storage.getUser(moderatorId);
        const target = await storage.getUser(targetUserId);
        
        // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ø¹Ø§Ù…Ø©
        const systemMessage = `ğŸ”Š ØªÙ… Ø¥Ù„ØºØ§Ø¡ ÙƒØªÙ… ${target?.username} Ù…Ù† Ù‚Ø¨Ù„ ${moderator?.username}`;
        
        broadcast({
          type: 'moderationAction',
          action: 'unmuted',
          targetUserId: targetUserId,
          message: systemMessage
        });
        
        res.json({ message: "ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ÙƒØªÙ… Ø¨Ù†Ø¬Ø§Ø­" });
      } else {
        res.status(403).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ù„Ùƒ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡" });
      }
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  app.post("/api/moderation/ban", async (req, res) => {
    try {
      const { moderatorId, targetUserId, reason, duration } = req.body;
      const clientIP = req.ip || req.connection.remoteAddress || 'unknown';
      const deviceId = req.headers['user-agent'] || 'unknown';
      
      const success = await moderationSystem.banUser(
        moderatorId, 
        targetUserId, 
        reason, 
        duration, 
        clientIP, 
        deviceId
      );
      
      if (success) {
        const moderator = await storage.getUser(moderatorId);
        const target = await storage.getUser(targetUserId);
        
        // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ø®Ø§Øµ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø·Ø±ÙˆØ¯
        const targetClient = Array.from(wss.clients).find((client: any) => client.userId === targetUserId);
        if (targetClient && targetClient.readyState === WebSocket.OPEN) {
          targetClient.send(JSON.stringify({
            type: 'kicked',
            targetUserId: targetUserId,
            duration: duration,
            reason: reason
          }));
        }

        // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ø¹Ø§Ù…Ø©
        const systemMessage = `â° ØªÙ… Ø·Ø±Ø¯ ${target?.username} Ù…Ù† Ù‚Ø¨Ù„ ${moderator?.username} Ù„Ù…Ø¯Ø© ${duration} Ø¯Ù‚ÙŠÙ‚Ø© - Ø§Ù„Ø³Ø¨Ø¨: ${reason}`;
        
        broadcast({
          type: 'moderationAction',
          action: 'banned',
          targetUserId: targetUserId,
          message: systemMessage
        });
        
        // Ø¥Ø¬Ø¨Ø§Ø± Ù‚Ø·Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„
        clients.forEach(client => {
          if (client.userId === targetUserId) {
            client.close();
          }
        });
        
        res.json({ message: "ØªÙ… Ø·Ø±Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­" });
      } else {
        res.status(403).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ù„Ùƒ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡" });
      }
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  app.post("/api/moderation/block", async (req, res) => {
    try {
      const { moderatorId, targetUserId, reason, ipAddress, deviceId } = req.body;
      const clientIP = req.ip || req.connection.remoteAddress || ipAddress || 'unknown';
      const clientDevice = req.headers['user-agent'] || deviceId || 'unknown';
      
      const success = await moderationSystem.blockUser(
        moderatorId, 
        targetUserId, 
        reason, 
        clientIP, 
        clientDevice
      );
      
      if (success) {
        const moderator = await storage.getUser(moderatorId);
        const target = await storage.getUser(targetUserId);
        
        // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ø®Ø§Øµ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø­Ø¬ÙˆØ¨
        const targetClient = Array.from(wss.clients).find((client: any) => client.userId === targetUserId);
        if (targetClient && targetClient.readyState === WebSocket.OPEN) {
          targetClient.send(JSON.stringify({
            type: 'blocked',
            targetUserId: targetUserId,
            reason: reason
          }));
        }

        // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ø¹Ø§Ù…Ø©
        const systemMessage = `ğŸš« ØªÙ… Ø­Ø¬Ø¨ ${target?.username} Ù†Ù‡Ø§Ø¦ÙŠØ§Ù‹ Ù…Ù† Ù‚Ø¨Ù„ ${moderator?.username} - Ø§Ù„Ø³Ø¨Ø¨: ${reason}`;
        
        broadcast({
          type: 'moderationAction',
          action: 'blocked',
          targetUserId: targetUserId,
          message: systemMessage
        });
        
        // Ø¥Ø¬Ø¨Ø§Ø± Ù‚Ø·Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„
        clients.forEach(client => {
          if (client.userId === targetUserId) {
            client.close();
          }
        });
        
        res.json({ message: "ØªÙ… Ø­Ø¬Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­" });
      } else {
        res.status(403).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ù„Ùƒ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡" });
      }
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  app.post("/api/moderation/promote", async (req, res) => {
    try {
      const { moderatorId, targetUserId, role } = req.body;
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…ØªÙ‚Ø¯Ù… Ø¨Ø§Ù„Ø·Ù„Ø¨ Ù‡Ùˆ Ø§Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·
      const moderator = await storage.getUser(moderatorId);
      if (!moderator || moderator.userType !== 'owner') {
        return res.status(403).json({ error: "Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙŠØ²Ø© Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·" });
      }

      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø±Ø§Ø¯ ØªØ±Ù‚ÙŠØªÙ‡ Ø¹Ø¶Ùˆ ÙˆÙ„ÙŠØ³ Ø²Ø§Ø¦Ø±
      const target = await storage.getUser(targetUserId);
      if (!target || target.userType !== 'member') {
        return res.status(400).json({ error: "ÙŠÙ…ÙƒÙ† ØªØ±Ù‚ÙŠØ© Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ ÙÙ‚Ø·" });
      }
      
      // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø±ØªØ¨Ø© ØµØ­ÙŠØ­Ø© (Ø¥Ø¯Ù…Ù† Ø£Ùˆ Ù…Ø´Ø±Ù ÙÙ‚Ø·)
      if (!['admin', 'moderator'].includes(role)) {
        return res.status(400).json({ error: "Ø±ØªØ¨Ø© ØºÙŠØ± ØµØ§Ù„Ø­Ø© - ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ù‚ÙŠØ© Ù„Ø¥Ø¯Ù…Ù† Ø£Ùˆ Ù…Ø´Ø±Ù ÙÙ‚Ø·" });
      }
      
      // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      await storage.updateUser(targetUserId, { userType: role });
      const updatedUser = await storage.getUser(targetUserId);
      
      const roleDisplay = role === 'admin' ? 'Ø¥Ø¯Ù…Ù† â­' : 'Ù…Ø´Ø±Ù ğŸ›¡ï¸';
      const rolePermissions = role === 'admin' ? 'ÙŠÙ…ÙƒÙ†Ù‡ ÙƒØªÙ… ÙˆØ·Ø±Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†' : 'ÙŠÙ…ÙƒÙ†Ù‡ ÙƒØªÙ… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ÙÙ‚Ø·';
      
      // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø±Ù‚Ù‰
      const targetClient = Array.from(wss.clients).find((client: any) => client.userId === targetUserId);
      if (targetClient && targetClient.readyState === WebSocket.OPEN) {
        targetClient.send(JSON.stringify({
          type: 'promotion',
          newRole: role,
          message: `ØªÙ‡Ø§Ù†ÙŠÙ†Ø§! ØªÙ…Øª ØªØ±Ù‚ÙŠØªÙƒ Ø¥Ù„Ù‰ ${roleDisplay} - ${rolePermissions}`
        }));
      }
      
      // Ø¥Ø´Ø¹Ø§Ø± Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø¨Ø§Ù„ØªØ±Ù‚ÙŠØ©
      broadcast({
        type: 'userUpdated',
        user: updatedUser
      });

      // Ø¥Ø´Ø¹Ø§Ø± Ø¹Ø§Ù… ÙÙŠ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©
      broadcast({
        type: 'systemNotification',
        message: `ğŸ‰ ØªÙ… ØªØ±Ù‚ÙŠØ© ${target.username} Ø¥Ù„Ù‰ ${roleDisplay}`,
        timestamp: new Date().toISOString()
      });
      
      res.json({ 
        success: true,
        message: `ØªÙ…Øª ØªØ±Ù‚ÙŠØ© ${target.username} Ø¥Ù„Ù‰ ${roleDisplay}`,
        user: updatedUser
      });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  app.post("/api/moderation/unmute", async (req, res) => {
    try {
      const { moderatorId, targetUserId } = req.body;
      
      const success = await moderationSystem.unmuteUser(moderatorId, targetUserId);
      
      if (success) {
        res.json({ message: "ØªÙ… ÙÙƒ Ø§Ù„ÙƒØªÙ… Ø¨Ù†Ø¬Ø§Ø­" });
      } else {
        res.status(403).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ù„Ùƒ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡" });
      }
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  app.post("/api/moderation/unblock", async (req, res) => {
    try {
      const { moderatorId, targetUserId } = req.body;
      
      const success = await moderationSystem.unblockUser(moderatorId, targetUserId);
      
      if (success) {
        res.json({ message: "ØªÙ… ÙÙƒ Ø§Ù„Ø­Ø¬Ø¨ Ø¨Ù†Ø¬Ø§Ø­" });
      } else {
        res.status(403).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ù„Ùƒ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡" });
      }
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  app.get("/api/moderation/log", async (req, res) => {
    try {
      const userId = parseInt(req.query.userId as string);
      const user = await storage.getUser(userId);
      
      // Ù„Ù„Ø¥Ø¯Ù…Ù† ÙˆØ§Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·
      if (!user || (user.userType !== 'owner' && user.userType !== 'admin')) {
        return res.status(403).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ù„Ùƒ Ø¨Ø§Ù„ÙˆØµÙˆÙ„ - Ù„Ù„Ø¥Ø¯Ù…Ù† ÙˆØ§Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·" });
      }

      const log = moderationSystem.getModerationLog();
      res.json({ log });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Ø¥Ø¶Ø§ÙØ© endpoint Ø³Ø¬Ù„ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ù„Ù„Ø¥Ø¯Ù…Ù†
  app.get("/api/moderation/actions", async (req, res) => {
    try {
      const userId = parseInt(req.query.userId as string);
      const user = await storage.getUser(userId);
      
      // Ù„Ù„Ø¥Ø¯Ù…Ù† ÙˆØ§Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·
      if (!user || (user.userType !== 'owner' && user.userType !== 'admin')) {
        return res.status(403).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ - Ù„Ù„Ø¥Ø¯Ù…Ù† ÙˆØ§Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·" });
      }

      const actions = moderationSystem.getModerationLog()
        .map(action => ({
          ...action,
          moderatorName: '', 
          targetName: '' 
        }));
      
      // Ø¥Ø¶Ø§ÙØ© Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù„Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª
      for (const action of actions) {
        const moderator = await storage.getUser(action.moderatorId);
        const target = await storage.getUser(action.targetUserId);
        action.moderatorName = moderator?.username || 'Ù…Ø¬Ù‡ÙˆÙ„';
        action.targetName = target?.username || 'Ù…Ø¬Ù‡ÙˆÙ„';
      }

      console.log(`ğŸ“‹ ${user.username} Ø·Ù„Ø¨ Ø³Ø¬Ù„ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª - ${actions.length} Ø¥Ø¬Ø±Ø§Ø¡`);
      res.json(actions);
    } catch (error) {
      console.error("Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø³Ø¬Ù„ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª:", error);
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Friends routes
  app.get("/api/friends/:userId", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const friends = await storage.getFriends(userId);
      
      res.json({ friends });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  app.post("/api/friends", async (req, res) => {
    try {
      const { userId, friendId } = req.body;
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…ÙˆØ¬ÙˆØ¯ÙŠÙ†
      const user = await storage.getUser(userId);
      const friend = await storage.getUser(friendId);
      
      if (!user || !friend) {
        return res.status(404).json({ error: "Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯" });
      }
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ø§ ÙŠØ¶ÙŠÙ Ù†ÙØ³Ù‡
      if (userId === friendId) {
        return res.status(400).json({ error: "Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ù†ÙØ³Ùƒ ÙƒØµØ¯ÙŠÙ‚" });
      }
      
      const friendship = await storage.addFriend(userId, friendId);
      
      // Ø¥Ø±Ø³Ø§Ù„ ØªÙ†Ø¨ÙŠÙ‡ WebSocket Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù
      broadcast({
        type: 'friendRequest',
        targetUserId: friendId,
        senderUserId: userId,
        senderUsername: user.username,
        message: `${user.username} ÙŠØ±ÙŠØ¯ Ø¥Ø¶Ø§ÙØªÙƒ ÙƒØµØ¯ÙŠÙ‚`
      });
      
      res.json({ 
        message: "ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø©",
        friendship 
      });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  app.delete("/api/friends/:userId/:friendId", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const friendId = parseInt(req.params.friendId);
      
      const success = await storage.removeFriend(userId, friendId);
      
      if (success) {
        res.json({ message: "ØªÙ… Ø­Ø°Ù Ø§Ù„ØµØ¯ÙŠÙ‚" });
      } else {
        res.status(404).json({ error: "Ø§Ù„ØµØ¯Ø§Ù‚Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©" });
      }
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });



  // Ø¥Ø¶Ø§ÙØ© endpoint Ù„ÙˆØ­Ø© Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ†
  app.get("/api/moderation/actions", async (req, res) => {
    try {
      const { userId } = req.query;
      const user = await storage.getUser(Number(userId));
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø´Ø±Ù Ø£Ùˆ Ù…Ø§Ù„Ùƒ
      if (!user || (user.userType !== 'admin' && user.userType !== 'owner')) {
        return res.status(403).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ - Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·" });
      }

      const actions = moderationSystem.getModerationLog()
        .map(action => ({
          ...action,
          moderatorName: '', // Ø³ÙŠØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ø³Ù… Ø§Ù„Ù…Ø´Ø±Ù
          targetName: '' // Ø³ÙŠØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù
        }));
      
      // Ø¥Ø¶Ø§ÙØ© Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù„Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª
      for (const action of actions) {
        const moderator = await storage.getUser(action.moderatorId);
        const target = await storage.getUser(action.targetUserId);
        action.moderatorName = moderator?.username || 'Ù…Ø¬Ù‡ÙˆÙ„';
        action.targetName = target?.username || 'Ù…Ø¬Ù‡ÙˆÙ„';
      }

      console.log(`ğŸ“‹ ${user.username} Ø·Ù„Ø¨ ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª - ${actions.length} Ø¥Ø¬Ø±Ø§Ø¡`);
      res.json(actions);
    } catch (error) {
      console.error("Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª:", error);
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Ø¥Ø¶Ø§ÙØ© endpoint Ù„Ø³Ø¬Ù„ Ø§Ù„Ø¨Ù„Ø§ØºØ§Øª
  app.get("/api/reports", async (req, res) => {
    try {
      const { userId } = req.query;
      const user = await storage.getUser(Number(userId));
      
      if (!user || (user.userType !== 'admin' && user.userType !== 'owner')) {
        return res.status(403).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ - Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·" });
      }

      const reports = spamProtection.getPendingReports()
        .concat(spamProtection.getReviewedReports())
        .map(report => ({
          ...report,
          reporterName: '',
          reportedUserName: ''
        }));
      
      // Ø¥Ø¶Ø§ÙØ© Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù„Ù„Ø¨Ù„Ø§ØºØ§Øª
      for (const report of reports) {
        const reporter = await storage.getUser(report.reporterId);
        const reported = await storage.getUser(report.reportedUserId);
        report.reporterName = reporter?.username || 'Ù…Ø¬Ù‡ÙˆÙ„';
        report.reportedUserName = reported?.username || 'Ù…Ø¬Ù‡ÙˆÙ„';
      }

      console.log(`ğŸ“‹ ${user.username} Ø·Ù„Ø¨ Ø³Ø¬Ù„ Ø§Ù„Ø¨Ù„Ø§ØºØ§Øª - ${reports.length} Ø¨Ù„Ø§Øº`);
      res.json(reports);
    } catch (error) {
      console.error("Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¨Ù„Ø§ØºØ§Øª:", error);
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Ø¥Ø¶Ø§ÙØ© endpoint Ù„Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ø¨Ù„Ø§ØºØ§Øª
  app.post("/api/reports/:id/review", async (req, res) => {
    try {
      const reportId = parseInt(req.params.id);
      const { action, moderatorId } = req.body;
      
      const user = await storage.getUser(moderatorId);
      if (!user || (user.userType !== 'admin' && user.userType !== 'owner')) {
        return res.status(403).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­" });
      }

      const success = spamProtection.reviewReport(reportId, action);
      
      if (success) {
        console.log(`ğŸ“‹ ${user.username} Ø±Ø§Ø¬Ø¹ Ø§Ù„Ø¨Ù„Ø§Øº ${reportId} - ${action}`);
        res.json({ message: "ØªÙ…Øª Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ø¨Ù„Ø§Øº" });
      } else {
        res.status(404).json({ error: "Ø§Ù„Ø¨Ù„Ø§Øº ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯" });
      }
    } catch (error) {
      console.error("Ø®Ø·Ø£ ÙÙŠ Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ø¨Ù„Ø§Øº:", error);
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Ø¥Ø¶Ø§ÙØ© endpoint Ù„ØªØ±Ù‚ÙŠØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
  app.post("/api/moderation/promote", async (req, res) => {
    try {
      const { moderatorId, targetUserId, newRole } = req.body;
      
      const moderator = await storage.getUser(moderatorId);
      const target = await storage.getUser(targetUserId);
      
      if (!moderator || moderator.userType !== 'owner') {
        return res.status(403).json({ error: "ÙÙ‚Ø· Ø§Ù„Ù…Ø§Ù„Ùƒ ÙŠÙ…ÙƒÙ†Ù‡ ØªØ±Ù‚ÙŠØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†" });
      }
      
      if (!target) {
        return res.status(404).json({ error: "Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯" });
      }
      
      if (target.userType !== 'member') {
        return res.status(400).json({ error: "ÙŠÙ…ÙƒÙ† ØªØ±Ù‚ÙŠØ© Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ ÙÙ‚Ø·" });
      }
      
      if (!['admin', 'owner'].includes(newRole)) {
        return res.status(400).json({ error: "Ø±ØªØ¨Ø© ØºÙŠØ± ØµØ§Ù„Ø­Ø©" });
      }
      
      // ØªØ­Ø¯ÙŠØ« Ù†ÙˆØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
      await storage.updateUser(targetUserId, { userType: newRole as any });
      
      // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ø¹Ø¨Ø± WebSocket
      const promotionMessage = {
        type: 'systemNotification',
        message: `ğŸ‰ ØªÙ… ØªØ±Ù‚ÙŠØ© ${target.username} Ø¥Ù„Ù‰ ${newRole === 'admin' ? 'Ù…Ø´Ø±Ù' : 'Ù…Ø§Ù„Ùƒ'} Ø¨ÙˆØ§Ø³Ø·Ø© ${moderator.username}`,
        timestamp: new Date().toISOString()
      };
      
      broadcast(promotionMessage);
      
      console.log(`ğŸ‘‘ ${moderator.username} Ø±Ù‚Ù‰ ${target.username} Ø¥Ù„Ù‰ ${newRole}`);
      res.json({ message: `ØªÙ… ØªØ±Ù‚ÙŠØ© ${target.username} Ø¥Ù„Ù‰ ${newRole === 'admin' ? 'Ù…Ø´Ø±Ù' : 'Ù…Ø§Ù„Ùƒ'} Ø¨Ù†Ø¬Ø§Ø­` });
    } catch (error) {
      console.error("Ø®Ø·Ø£ ÙÙŠ ØªØ±Ù‚ÙŠØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:", error);
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Ø¥Ø¶Ø§ÙØ© endpoint Ù„Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø©
  app.get("/api/moderation/active-actions", async (req, res) => {
    try {
      const { userId } = req.query;
      const user = await storage.getUser(Number(userId));
      
      if (!user || (user.userType !== 'admin' && user.userType !== 'owner')) {
        return res.status(403).json({ error: "ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ - Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·" });
      }

      const allActions = moderationSystem.getModerationLog();
      const activeActions = allActions
        .filter(action => (action.type === 'mute' || action.type === 'block'))
        .map(action => ({
          ...action,
          moderatorName: '',
          targetName: ''
        }));
      
      // Ø¥Ø¶Ø§ÙØ© Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
      for (const action of activeActions) {
        const moderator = await storage.getUser(action.moderatorId);
        const target = await storage.getUser(action.targetUserId);
        action.moderatorName = moderator?.username || 'Ù…Ø¬Ù‡ÙˆÙ„';
        action.targetName = target?.username || 'Ù…Ø¬Ù‡ÙˆÙ„';
      }

      console.log(`ğŸ“‹ ${user.username} Ø·Ù„Ø¨ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø© - ${activeActions.length} Ø¥Ø¬Ø±Ø§Ø¡`);
      res.json(activeActions);
    } catch (error) {
      console.error("Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø©:", error);
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…" });
    }
  });

  // Security API routes
  app.use('/api/security', securityApiRoutes);
  
  // Performance ping endpoint
  app.get('/api/ping', (req, res) => {
    res.json({ timestamp: Date.now(), status: 'ok' });
  });



  // API routes Ù„Ù„Ø¥Ø®ÙØ§Ø¡ ÙˆØ§Ù„ØªØ¬Ø§Ù‡Ù„
  app.post('/api/users/:userId/stealth', async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const { isHidden } = req.body;
      
      await storage.setUserHiddenStatus(userId, isHidden);
      
      res.json({ success: true, message: isHidden ? 'ØªÙ… Ø¥Ø®ÙØ§Ø¤Ùƒ' : 'ØªÙ… Ø¥Ø¸Ù‡Ø§Ø±Ùƒ' });
    } catch (error) {
      console.error('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« ÙˆØ¶Ø¹ Ø§Ù„Ø¥Ø®ÙØ§Ø¡:', error);
      res.status(500).json({ error: 'ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« ÙˆØ¶Ø¹ Ø§Ù„Ø¥Ø®ÙØ§Ø¡' });
    }
  });

  app.post('/api/users/:userId/ignore/:targetId', async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const targetId = parseInt(req.params.targetId);
      
      await storage.addIgnoredUser(userId, targetId);
      
      res.json({ success: true, message: 'ØªÙ… ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…' });
    } catch (error) {
      console.error('Ø®Ø·Ø£ ÙÙŠ ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:', error);
      res.status(500).json({ error: 'ÙØ´Ù„ ÙÙŠ ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…' });
    }
  });

  app.delete('/api/users/:userId/ignore/:targetId', async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const targetId = parseInt(req.params.targetId);
      
      await storage.removeIgnoredUser(userId, targetId);
      
      res.json({ success: true, message: 'ØªÙ… Ø¥Ù„ØºØ§Ø¡ ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…' });
    } catch (error) {
      console.error('Ø®Ø·Ø£ ÙÙŠ Ø¥Ù„ØºØ§Ø¡ ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:', error);
      res.status(500).json({ error: 'ÙØ´Ù„ ÙÙŠ Ø¥Ù„ØºØ§Ø¡ ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…' });
    }
  });

  app.get('/api/users/:userId/ignored', async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const ignoredUsers = await storage.getIgnoredUsers(userId);
      
      res.json({ ignoredUsers });
    } catch (error) {
      console.error('Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ØªØ¬Ø§Ù‡Ù„ÙŠÙ†:', error);
      res.status(500).json({ error: 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ØªØ¬Ø§Ù‡Ù„ÙŠÙ†' });
    }
  });

  // User Update Route with Theme Support
  app.put('/api/users/:id', async (req, res) => {
    try {
      const { id } = req.params;
      const updates = req.body;
      
      console.log('Updating user:', id, 'with updates:', updates);
      
      const user = await storage.updateUser(parseInt(id), updates);
      if (!user) {
        console.log('User not found:', id);
        return res.status(404).json({ error: 'User not found' });
      }
      
      console.log('User updated successfully:', user);
      
      // Ø¥Ø±Ø³Ø§Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø«ÙŠÙ… Ø¹Ø¨Ø± WebSocket
      if (updates.userTheme) {
        const updateMessage = {
          type: 'theme_update',
          userId: parseInt(id),
          userTheme: updates.userTheme,
          timestamp: new Date().toISOString()
        };
        broadcast(updateMessage);
        console.log('Broadcasting theme update:', updateMessage);
      }
      
      res.json(user);
    } catch (error) {
      console.error('Error updating user:', error);
      res.status(500).json({ error: 'Failed to update user', details: error.message });
    }
  });

  // Notifications API
  app.get("/api/notifications/:userId", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const notifications = await storage.getUserNotifications(userId);
      res.json({ notifications });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª" });
    }
  });

  app.post("/api/notifications", async (req, res) => {
    try {
      const { userId, type, title, message, data } = req.body;
      
      const notification = await storage.createNotification({
        userId,
        type,
        title,
        message,
        data
      });
      
      // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± ÙÙˆØ±ÙŠ Ø¹Ø¨Ø± WebSocket
      if (wss) {
        wss.clients.forEach((client: WebSocketClient) => {
          if (client.readyState === WebSocket.OPEN && client.userId === userId) {
            client.send(JSON.stringify({
              type: 'newNotification',
              notification
            }));
          }
        });
      }
      
      res.json({ notification });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±" });
    }
  });

  app.put("/api/notifications/:id/read", async (req, res) => {
    try {
      const notificationId = parseInt(req.params.id);
      const success = await storage.markNotificationAsRead(notificationId);
      res.json({ success });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±" });
    }
  });

  app.put("/api/notifications/user/:userId/read-all", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const success = await storage.markAllNotificationsAsRead(userId);
      res.json({ success });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª" });
    }
  });

  app.delete("/api/notifications/:id", async (req, res) => {
    try {
      const notificationId = parseInt(req.params.id);
      const success = await storage.deleteNotification(notificationId);
      res.json({ success });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±" });
    }
  });

  app.get("/api/notifications/:userId/unread-count", async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const count = await storage.getUnreadNotificationCount(userId);
      res.json({ count });
    } catch (error) {
      res.status(500).json({ error: "Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª" });
    }
  });

  return httpServer;
}
import type { IStorage } from '../storage';
import type { InsertMessage, Message, User } from '@shared/schema';
import { NotificationService } from './NotificationService';
import { SecurityManager } from '../auth/security';

/**
 * Ø®Ø¯Ù…Ø© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…Ø­Ø³Ù†Ø© Ù…Ø¹ Ø§Ù„ØªØ­Ù‚Ù‚ ÙˆØ§Ù„Ø£Ù…Ø§Ù†
 */
export class MessageService {
  constructor(private storage: IStorage) {}

  /**
   * Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ù…Ø¹ Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ø£Ù…Ù†ÙŠ
   */
  async sendMessage(senderId: number, messageData: Omit<InsertMessage, 'senderId'>): Promise<{success: boolean, message?: Message, error?: string}> {
    try {
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù…Ø±Ø³Ù„
      const sender = await this.storage.getUser(senderId);
      if (!sender) {
        return { success: false, error: 'Ø§Ù„Ù…Ø±Ø³Ù„ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯' };
      }

      // ÙØ­Øµ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª
      if (!SecurityManager.hasPermission(sender.userType, 'send_message')) {
        return { success: false, error: 'ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ù„Ùƒ Ø¨Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„' };
      }

      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø¸Ø±/Ø§Ù„ÙƒØªÙ…
      if (sender.isMuted && !messageData.isPrivate) {
        return { success: false, error: 'Ø£Ù†Øª Ù…ÙƒØªÙˆÙ… ÙˆÙ„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ø¦Ù„ Ø¹Ø§Ù…Ø©' };
      }

      if (sender.isBanned) {
        return { success: false, error: 'Ø£Ù†Øª Ù…Ø­Ø¸ÙˆØ± Ù…Ù† Ø§Ù„Ù…Ù†ØµØ©' };
      }

      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø±Ø³Ø§Ù„Ø©
      if (!messageData.content || messageData.content.trim().length === 0) {
        return { success: false, error: 'Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø±Ø³Ø§Ù„Ø© ÙØ§Ø±Øº' };
      }

      if (messageData.content.length > 1000) {
        return { success: false, error: 'Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø·ÙˆÙŠÙ„Ø© Ø¬Ø¯Ø§Ù‹ (Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ 1000 Ø­Ø±Ù)' };
      }

      // Ù„Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø®Ø§ØµØ© - Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„
      if (messageData.isPrivate && messageData.receiverId) {
        const receiver = await this.storage.getUser(messageData.receiverId);
        if (!receiver) {
          return { success: false, error: 'Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯' };
        }

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ¬Ø§Ù‡Ù„
        const ignoredUsers = await this.storage.getIgnoredUsers(messageData.receiverId);
        if (ignoredUsers.includes(senderId)) {
          // Ù„Ø§ Ù†Ø®Ø¨Ø± Ø§Ù„Ù…Ø±Ø³Ù„ Ø£Ù†Ù‡ Ù…ÙØªØ¬Ø§Ù‡Ù„
          return { success: true, message: undefined };
        }
      }

      // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø±Ø³Ø§Ù„Ø©
      const fullMessageData: InsertMessage = {
        ...messageData,
        senderId,
        content: messageData.content.trim(),
        timestamp: new Date()
      };

      const message = await this.storage.createMessage(fullMessageData);

      // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø®Ø§ØµØ©
      if (messageData.isPrivate && messageData.receiverId) {
        const notification = await this.storage.createNotification({
          userId: messageData.receiverId,
          type: 'private_message',
          title: 'Ø±Ø³Ø§Ù„Ø© Ø®Ø§ØµØ© Ø¬Ø¯ÙŠØ¯Ø© ğŸ’¬',
          message: `Ø£Ø±Ø³Ù„ ${sender.username} Ø±Ø³Ø§Ù„Ø© Ø¥Ù„ÙŠÙƒ`,
          data: { 
            messageId: message.id, 
            senderId, 
            senderName: sender.username,
            messagePreview: messageData.content.substring(0, 50) + (messageData.content.length > 50 ? '...' : '')
          }
        });

        // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± ÙÙˆØ±ÙŠ
        NotificationService.getInstance().sendNotification(messageData.receiverId, notification);
      }

      return { success: true, message };

    } catch (error) {
      console.error('Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©:', error);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©' };
    }
  }

  /**
   * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¹Ø§Ù…Ø© Ù…Ø¹ Ø§Ù„ØªØ­Ù‚Ù‚
   */
  async getPublicMessages(userId: number, limit: number = 50): Promise<{success: boolean, messages?: Message[], error?: string}> {
    try {
      const user = await this.storage.getUser(userId);
      if (!user) {
        return { success: false, error: 'Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯' };
      }

      if (!SecurityManager.hasPermission(user.userType, 'view_public')) {
        return { success: false, error: 'ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ù„Ùƒ Ø¨Ù…Ø´Ø§Ù‡Ø¯Ø© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¹Ø§Ù…Ø©' };
      }

      const messages = await this.storage.getPublicMessages(limit);
      
      // ØªØµÙÙŠØ© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ÙØªØ¬Ø§Ù‡Ù„ÙŠÙ†
      const ignoredUsers = await this.storage.getIgnoredUsers(userId);
      const filteredMessages = messages.filter(msg => !ignoredUsers.includes(msg.senderId));

      return { success: true, messages: filteredMessages };

    } catch (error) {
      console.error('Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¹Ø§Ù…Ø©:', error);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„' };
    }
  }

  /**
   * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø®Ø§ØµØ© Ù…Ø¹ Ø§Ù„ØªØ­Ù‚Ù‚
   */
  async getPrivateMessages(userId: number, otherUserId: number, limit: number = 50): Promise<{success: boolean, messages?: Message[], error?: string}> {
    try {
      const user = await this.storage.getUser(userId);
      const otherUser = await this.storage.getUser(otherUserId);
      
      if (!user || !otherUser) {
        return { success: false, error: 'Ø£Ø­Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯' };
      }

      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ¬Ø§Ù‡Ù„
      const ignoredByOther = await this.storage.getIgnoredUsers(otherUserId);
      if (ignoredByOther.includes(userId)) {
        return { success: false, error: 'Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ù…Ø±Ø§Ø³Ù„Ø© Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…' };
      }

      const messages = await this.storage.getPrivateMessages(userId, otherUserId, limit);
      return { success: true, messages };

    } catch (error) {
      console.error('Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø®Ø§ØµØ©:', error);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„' };
    }
  }

  /**
   * Ø­Ø°Ù Ø±Ø³Ø§Ù„Ø© (Ù„Ù„Ù…Ø±Ø³Ù„ Ø£Ùˆ Ø§Ù„Ø¥Ø¯Ù…Ù†)
   */
  async deleteMessage(messageId: number, userId: number): Promise<{success: boolean, error?: string}> {
    try {
      const user = await this.storage.getUser(userId);
      if (!user) {
        return { success: false, error: 'Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯' };
      }

      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª (Ø§Ù„Ù…Ø±Ø³Ù„ Ø§Ù„Ø£ØµÙ„ÙŠ Ø£Ùˆ Ø¥Ø¯Ù…Ù†)
      // Ù‡Ø°Ø§ Ø³ÙŠØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ ØªØ·Ø¨ÙŠÙ‚ ÙÙŠ storage.ts
      // const message = await this.storage.getMessage(messageId);
      // if (message.senderId !== userId && !SecurityManager.hasPermission(user.userType, 'delete_messages')) {
      //   return { success: false, error: 'ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ù„Ùƒ Ø¨Ø­Ø°Ù Ù‡Ø°Ù‡ Ø§Ù„Ø±Ø³Ø§Ù„Ø©' };
      // }

      // await this.storage.deleteMessage(messageId);
      return { success: true };

    } catch (error) {
      console.error('Ø®Ø·Ø£ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø©:', error);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø©' };
    }
  }
}
import { SecurityManager } from '../auth/security';
import type { IStorage } from '../storage';
import type { InsertUser, User } from '@shared/schema';

/**
 * Ø®Ø¯Ù…Ø© Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø© Ø§Ù„Ù…Ø­Ø³Ù†Ø© Ù…Ø¹ Ø§Ù„Ø£Ù…Ø§Ù†
 */
export class AuthService {
  constructor(private storage: IStorage) {}

  /**
   * ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„ Ù…Ø­Ø³Ù† Ù…Ø¹ Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ø£Ù…Ù†ÙŠ
   */
  async login(username: string, password: string): Promise<{success: boolean, user?: User, error?: string}> {
    try {
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      const usernameValidation = SecurityManager.validateUsername(username);
      if (!usernameValidation.valid) {
        return { success: false, error: usernameValidation.error };
      }

      if (!password || password.trim().length === 0) {
        return { success: false, error: 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù…Ø·Ù„ÙˆØ¨Ø©' };
      }

      // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
      const user = await this.storage.getUserByUsername(username.trim());
      if (!user) {
        return { success: false, error: 'Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± ØµØ­ÙŠØ­' };
      }

      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
      let passwordValid = false;
      if (user.userType === 'guest') {
        // Ø§Ù„Ø¶ÙŠÙˆÙ ÙŠØ³ØªØ®Ø¯Ù…ÙˆÙ† Ù…Ù‚Ø§Ø±Ù†Ø© Ù…Ø¨Ø§Ø´Ø±Ø©
        passwordValid = user.password === password.trim();
      } else {
        // Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ ÙŠØ³ØªØ®Ø¯Ù…ÙˆÙ† Ø§Ù„ØªØ´ÙÙŠØ±
        if (user.password) {
          passwordValid = await SecurityManager.verifyPassword(password.trim(), user.password);
        }
      }

      if (!passwordValid) {
        return { success: false, error: 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©' };
      }

      // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„
      await this.storage.setUserOnlineStatus(user.id, true);

      // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø± ØªØ±Ø­ÙŠØ¨
      if (user.userType !== 'guest') {
        await this.storage.createNotification({
          userId: user.id,
          type: 'welcome_back',
          title: 'ğŸ‰ Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ø¹ÙˆØ¯ØªÙƒ',
          message: `Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ ${user.username}! Ù†Ø³Ø¹Ø¯ Ø¨Ø¹ÙˆØ¯ØªÙƒ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ù†ØµØ©.`,
          data: { loginTime: new Date().toISOString() }
        });
      }

      return { success: true, user };

    } catch (error) {
      console.error('Ø®Ø·Ø£ ÙÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„:', error);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…' };
    }
  }

  /**
   * ØªØ³Ø¬ÙŠÙ„ Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯ Ù…Ø¹ Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ø£Ù…Ù†ÙŠ
   */
  async register(userData: InsertUser): Promise<{success: boolean, user?: User, error?: string}> {
    try {
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
      const usernameValidation = SecurityManager.validateUsername(userData.username);
      if (!usernameValidation.valid) {
        return { success: false, error: usernameValidation.error };
      }

      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù„Ù„Ø£Ø¹Ø¶Ø§Ø¡
      if (userData.userType !== 'guest' && userData.password) {
        const passwordValidation = SecurityManager.validatePassword(userData.password);
        if (!passwordValidation.valid) {
          return { success: false, error: passwordValidation.error };
        }
      }

      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø³Ø¨Ù‚Ø§Ù‹
      const existingUser = await this.storage.getUserByUsername(userData.username);
      if (existingUser) {
        return { success: false, error: 'Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø¨Ù‚Ø§Ù‹' };
      }

      // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
      const newUser = await this.storage.createUser(userData);

      // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø± ØªØ±Ø­ÙŠØ¨
      await this.storage.createNotification({
        userId: newUser.id,
        type: 'welcome',
        title: 'ğŸŒŸ Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù…Ù†ØµØ© Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©',
        message: `Ø£Ù‡Ù„Ø§Ù‹ ÙˆØ³Ù‡Ù„Ø§Ù‹ ${newUser.username}! Ù†ØªÙ…Ù†Ù‰ Ù„Ùƒ ØªØ¬Ø±Ø¨Ø© Ø±Ø§Ø¦Ø¹Ø© Ù…Ø¹Ù†Ø§.`,
        data: { registrationTime: new Date().toISOString() }
      });

      return { success: true, user: newUser };

    } catch (error) {
      console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ³Ø¬ÙŠÙ„:', error);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ³Ø¬ÙŠÙ„' };
    }
  }

  /**
   * ØªØ³Ø¬ÙŠÙ„ Ø®Ø±ÙˆØ¬ Ø¢Ù…Ù†
   */
  async logout(userId: number): Promise<{success: boolean, error?: string}> {
    try {
      await this.storage.setUserOnlineStatus(userId, false);
      return { success: true };
    } catch (error) {
      console.error('Ø®Ø·Ø£ ÙÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬:', error);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬' };
    }
  }

  /**
   * Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª
   */
  hasPermission(user: User, action: string): boolean {
    return SecurityManager.hasPermission(user.userType, action);
  }

  /**
   * Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¬Ù„Ø³Ø©
   */
  isSessionValid(user: User): boolean {
    if (!user.lastSeen) return false;
    return SecurityManager.isSessionValid(user.lastSeen);
  }
}
import type { IStorage } from '../storage';
import { NotificationService } from './NotificationService';

/**
 * Ø®Ø¯Ù…Ø© Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£ØµØ¯Ù‚Ø§Ø¡ - Ù…Ù†Ø¸Ù…Ø© ÙˆÙ…Ø­Ø³Ù†Ø©
 */
export class FriendService {
  constructor(private storage: IStorage) {}
  
  /**
   * Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ ØµØ¯Ø§Ù‚Ø© Ù…Ø¹ Ø§Ù„ØªØ­Ù‚Ù‚ ÙˆØ§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª
   */
  async sendFriendRequest(senderId: number, receiverId: number): Promise<{success: boolean, error?: string, request?: any}> {
    try {
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ù…Ø¹Ø·ÙŠØ§Øª
      if (senderId === receiverId) {
        return { success: false, error: 'Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ ØµØ¯Ø§Ù‚Ø© Ù„Ù†ÙØ³Ùƒ' };
      }
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
      const sender = await this.storage.getUser(senderId);
      const receiver = await this.storage.getUser(receiverId);
      
      if (!sender || !receiver) {
        return { success: false, error: 'Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯' };
      }
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ ØµØ¯Ø§Ù‚Ø© Ù…Ø³Ø¨Ù‚Ø©
      const existingFriendship = await this.storage.getFriendship(senderId, receiverId);
      if (existingFriendship) {
        return { success: false, error: 'Ø£Ù†ØªÙ…Ø§ Ø£ØµØ¯Ù‚Ø§Ø¡ Ø¨Ø§Ù„ÙØ¹Ù„' };
      }
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Ø·Ù„Ø¨ Ù…Ø³Ø¨Ù‚
      const existingRequest = await this.storage.getFriendRequest(senderId, receiverId);
      if (existingRequest) {
        return { success: false, error: 'Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø© Ù…Ø±Ø³Ù„ Ù…Ø³Ø¨Ù‚Ø§Ù‹' };
      }
      
      // Ø¥Ù†Ø´Ø§Ø¡ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø©
      const request = await this.storage.createFriendRequest(senderId, receiverId);
      
      // Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± ÙÙˆØ±ÙŠ Ù„Ù„Ù…Ø³ØªÙ‚Ø¨Ù„
      const notification = await this.storage.createNotification({
        userId: receiverId,
        type: 'friend_request',
        title: 'Ø·Ù„Ø¨ ØµØ¯Ø§Ù‚Ø© Ø¬Ø¯ÙŠØ¯ ğŸ‘«',
        message: `Ø£Ø±Ø³Ù„ ${sender.username} Ø·Ù„Ø¨ ØµØ¯Ø§Ù‚Ø© Ø¥Ù„ÙŠÙƒ`,
        data: { requestId: request.id, senderId, senderName: sender.username }
      });
      
      NotificationService.getInstance().sendNotification(receiverId, notification);
      
      return { success: true, request };
      
    } catch (error) {
      console.error('Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø©:', error);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø©' };
    }
  }
  
  /**
   * Ù‚Ø¨ÙˆÙ„ Ø·Ù„Ø¨ ØµØ¯Ø§Ù‚Ø© Ù…Ø¹ Ø¥Ø´Ø¹Ø§Ø±Ø§Øª
   */
  async acceptFriendRequest(requestId: number, userId: number): Promise<{success: boolean, error?: string}> {
    try {
      const request = await this.storage.getFriendRequestById(requestId);
      if (!request) {
        return { success: false, error: 'Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯' };
      }
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©
      if (request.receiverId !== userId) {
        return { success: false, error: 'ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ù„Ùƒ Ø¨Ù‚Ø¨ÙˆÙ„ Ù‡Ø°Ø§ Ø§Ù„Ø·Ù„Ø¨' };
      }
      
      if (request.status !== 'pending') {
        return { success: false, error: 'ØªÙ… Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ù‡Ø°Ø§ Ø§Ù„Ø·Ù„Ø¨ Ù…Ø³Ø¨Ù‚Ø§Ù‹' };
      }
      
      // Ù‚Ø¨ÙˆÙ„ Ø§Ù„Ø·Ù„Ø¨
      await this.storage.acceptFriendRequest(requestId);
      
      // Ø¥Ø¶Ø§ÙØ© ØµØ¯Ø§Ù‚Ø© Ù…ØªØ¨Ø§Ø¯Ù„Ø©
      await this.storage.addFriend(request.senderId, request.receiverId);
      await this.storage.addFriend(request.receiverId, request.senderId);
      
      // Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ù…Ø±Ø³Ù„ Ø¨Ø§Ù„Ù‚Ø¨ÙˆÙ„
      const notification = await this.storage.createNotification({
        userId: request.senderId,
        type: 'friend_accepted',
        title: 'ØªÙ… Ù‚Ø¨ÙˆÙ„ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø© âœ…',
        message: `Ù‚Ø¨Ù„ ${request.receiver?.username} Ø·Ù„Ø¨ ØµØ¯Ø§Ù‚ØªÙƒ`,
        data: { friendId: request.receiverId, friendName: request.receiver?.username }
      });
      
      NotificationService.getInstance().sendNotification(request.senderId, notification);
      
      return { success: true };
      
    } catch (error) {
      console.error('Ø®Ø·Ø£ ÙÙŠ Ù‚Ø¨ÙˆÙ„ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø©:', error);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù‚Ø¨ÙˆÙ„ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø©' };
    }
  }
  
  /**
   * Ø±ÙØ¶ Ø·Ù„Ø¨ ØµØ¯Ø§Ù‚Ø©
   */
  async declineFriendRequest(requestId: number, userId: number): Promise<{success: boolean, error?: string}> {
    try {
      const request = await this.storage.getFriendRequestById(requestId);
      if (!request) {
        return { success: false, error: 'Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯' };
      }
      
      if (request.receiverId !== userId) {
        return { success: false, error: 'ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ù„Ùƒ Ø¨Ø±ÙØ¶ Ù‡Ø°Ø§ Ø§Ù„Ø·Ù„Ø¨' };
      }
      
      await this.storage.declineFriendRequest(requestId);
      return { success: true };
      
    } catch (error) {
      console.error('Ø®Ø·Ø£ ÙÙŠ Ø±ÙØ¶ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø©:', error);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø±ÙØ¶ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø©' };
    }
  }
  
  /**
   * Ø¥Ù„ØºØ§Ø¡ Ø·Ù„Ø¨ ØµØ¯Ø§Ù‚Ø© Ù…Ø±Ø³Ù„
   */
  async cancelFriendRequest(requestId: number, userId: number): Promise<{success: boolean, error?: string}> {
    try {
      const request = await this.storage.getFriendRequestById(requestId);
      if (!request) {
        return { success: false, error: 'Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯' };
      }
      
      if (request.senderId !== userId) {
        return { success: false, error: 'ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ù„Ùƒ Ø¨Ø¥Ù„ØºØ§Ø¡ Ù‡Ø°Ø§ Ø§Ù„Ø·Ù„Ø¨' };
      }
      
      await this.storage.deleteFriendRequest(requestId);
      return { success: true };
      
    } catch (error) {
      console.error('Ø®Ø·Ø£ ÙÙŠ Ø¥Ù„ØºØ§Ø¡ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø©:', error);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ù„ØºØ§Ø¡ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø©' };
    }
  }
  
  /**
   * Ø­Ø°Ù ØµØ¯ÙŠÙ‚ Ù…Ø¹ ØªØ£ÙƒÙŠØ¯
   */
  async removeFriend(userId: number, friendId: number): Promise<{success: boolean, error?: string}> {
    try {
      const friendship = await this.storage.getFriendship(userId, friendId);
      if (!friendship) {
        return { success: false, error: 'Ø§Ù„ØµØ¯Ø§Ù‚Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©' };
      }
      
      const success = await this.storage.removeFriend(userId, friendId);
      if (success) {
        // Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ø·Ø±Ù Ø§Ù„Ø¢Ø®Ø± (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)
        const friend = await this.storage.getUser(friendId);
        const user = await this.storage.getUser(userId);
        
        if (friend && user) {
          const notification = await this.storage.createNotification({
            userId: friendId,
            type: 'friend_removed',
            title: 'ØªÙ… Ø­Ø°Ù ØµØ¯ÙŠÙ‚',
            message: `Ù‚Ø§Ù… ${user.username} Ø¨Ø­Ø°ÙÙƒ Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£ØµØ¯Ù‚Ø§Ø¡`,
            data: { removedBy: userId }
          });
          
          NotificationService.getInstance().sendNotification(friendId, notification);
        }
        
        return { success: true };
      }
      
      return { success: false, error: 'ÙØ´Ù„ ÙÙŠ Ø­Ø°Ù Ø§Ù„ØµØ¯ÙŠÙ‚' };
      
    } catch (error) {
      console.error('Ø®Ø·Ø£ ÙÙŠ Ø­Ø°Ù Ø§Ù„ØµØ¯ÙŠÙ‚:', error);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø­Ø°Ù Ø§Ù„ØµØ¯ÙŠÙ‚' };
    }
  }
}
import { Switch, Route } from "wouter";
import { queryClient } from "./lib/queryClient";
import { QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import { TooltipProvider } from "@/components/ui/tooltip";
import { ThemeProvider } from "@/components/ui/theme-provider";
import ChatPage from "@/pages/chat";
import { useEffect, Suspense, lazy } from "react";

// ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ø¹Ø§Ù… - ØªØ³Ø±ÙŠØ¹ Ø§Ù„Ø¯Ø®ÙˆÙ„
function PerformanceOptimizer() {
  useEffect(() => {
    // ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªÙ…Ø±ÙŠØ±
    const smoothScroll = () => {
      document.documentElement.style.scrollBehavior = 'smooth';
    };
    
    // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø®Ø·ÙˆØ· - ØªØ­Ù…ÙŠÙ„ Ù…Ø³Ø¨Ù‚
    const preloadFonts = () => {
      const link = document.createElement('link');
      link.rel = 'preload';
      link.href = 'https://fonts.googleapis.com/css2?family=Cairo:wght@300;400;500;600;700&display=swap';
      link.as = 'style';
      document.head.appendChild(link);
    };

    // ØªØ­Ø³ÙŠÙ† Ø§Ù„ØµÙˆØ± - ØªØ­Ù…ÙŠÙ„ Ù…Ø³Ø¨Ù‚
    const preloadImages = () => {
      const images = [
        '/default_avatar.svg',
        '/notification.mp3'
      ];
      
      images.forEach(src => {
        const link = document.createElement('link');
        link.rel = 'preload';
        link.href = src;
        link.as = src.endsWith('.mp3') ? 'audio' : 'image';
        document.head.appendChild(link);
      });
    };

    // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø°Ø§ÙƒØ±Ø©
    const optimizeMemory = () => {
      // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø© ÙƒÙ„ 5 Ø¯Ù‚Ø§Ø¦Ù‚
      setInterval(() => {
        if ('memory' in performance) {
          const memory = (performance as any).memory;
          if (memory.usedJSHeapSize > memory.jsHeapSizeLimit * 0.8) {
            console.log('ğŸ§¹ ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø©...');
            // Ø¥Ø¬Ø¨Ø§Ø± ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø©
            if (window.gc) window.gc();
          }
        }
      }, 300000);
    };

    // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø´Ø¨ÙƒØ©
    const optimizeNetwork = () => {
      // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø´Ø¨ÙƒØ©
      if ('connection' in navigator) {
        const connection = (navigator as any).connection;
        if (connection.effectiveType === 'slow-2g' || connection.effectiveType === '2g') {
          // ØªÙ‚Ù„ÙŠÙ„ Ø¬ÙˆØ¯Ø© Ø§Ù„ØµÙˆØ± Ù„Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ø¨Ø·ÙŠØ¦Ø©
          document.documentElement.classList.add('slow-connection');
        }
      }
    };

    // ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª
    const optimizeCache = () => {
      if ('caches' in window) {
        caches.open('arabic-chat-v1').then(cache => {
          // ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ù‡Ù…Ø©
          cache.addAll([
            '/',
            '/index.html',
            '/default_avatar.svg',
            '/notification.mp3'
          ]);
        });
      }
    };

    // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ø¹Ø§Ù…
    const optimizePerformance = () => {
      // ØªÙ‚Ù„ÙŠÙ„ Ø§Ø³ØªØ®Ø¯Ø§Ù… CPU
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          // Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª ØºÙŠØ± Ø§Ù„Ø¶Ø±ÙˆØ±ÙŠØ© Ø¹Ù†Ø¯ Ø¹Ø¯Ù… Ø§Ù„ØªØ±ÙƒÙŠØ²
          document.body.classList.add('page-hidden');
        } else {
          document.body.classList.remove('page-hidden');
        }
      });

      // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ù…ØªØ­Ø±ÙƒØ©
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if (prefersReducedMotion) {
        document.documentElement.classList.add('reduce-motion');
      }
    };

    smoothScroll();
    preloadFonts();
    preloadImages();
    optimizeMemory();
    optimizeNetwork();
    optimizeCache();
    optimizePerformance();

    console.log('ğŸš€ ØªÙ… ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø¨Ù†Ø¬Ø§Ø­');
  }, []);

  return null;
}

// ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªØ­Ù…ÙŠÙ„ - Lazy Loading
const LazyChatPage = lazy(() => import("@/pages/chat"));

// Ø´Ø§Ø´Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø­Ø³Ù†Ø©
function LoadingScreen() {
  return (
    <div className="h-screen flex flex-col justify-center items-center bg-gradient-to-br from-background via-background to-muted animate-pulse">
      <div className="text-center">
        <div className="text-6xl mb-4 animate-bounce">ğŸ’¬</div>
        <h2 className="text-2xl font-bold mb-2 bg-gradient-to-r from-primary to-blue-400 bg-clip-text text-transparent">
          Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©...
        </h2>
        <div className="flex justify-center mt-4">
          <div className="w-8 h-8 border-4 border-primary border-t-transparent rounded-full animate-spin"></div>
        </div>
        <p className="text-sm text-muted-foreground mt-4">ÙŠØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø³Ø±Ø¹Ø©...</p>
      </div>
    </div>
  );
}

function Router() {
  return (
    <Switch>
      <Route path="/" component={LazyChatPage} />
      <Route component={LazyChatPage} />
    </Switch>
  );
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider defaultTheme="dark" storageKey="arabic-chat-theme">
        <TooltipProvider>
          <PerformanceOptimizer />
          <Toaster />
          <Suspense fallback={<LoadingScreen />}>
            <Router />
          </Suspense>
        </TooltipProvider>
      </ThemeProvider>
    </QueryClientProvider>
  );
}

export default App;
import { useState, useEffect } from 'react';
import UserSidebar from './UserSidebar';
import MessageArea from './MessageArea';
import ProfileModal from './ProfileModal';
import PrivateMessageBox from './PrivateMessageBox';
import UserPopup from './UserPopup';
import SettingsMenu from './SettingsMenu';
import ReportModal from './ReportModal';
import AdminReportsPanel from './AdminReportsPanel';
import NotificationPanel from './NotificationPanel';
import FriendsPanel from './FriendsPanelSimple';
import FriendRequestBadge from './FriendRequestBadge';
import MessagesPanel from './MessagesPanel';
import MessageAlert from './MessageAlert';
import ModerationPanel from './ModerationPanel';
import ReportsLog from '../moderation/ReportsLog';
import ActiveModerationLog from '../moderation/ActiveModerationLog';
import KickNotification from '../moderation/KickNotification';
import BlockNotification from '../moderation/BlockNotification';
import PromoteUserPanel from '../moderation/PromoteUserPanel';
import OwnerAdminPanel from './OwnerAdminPanel';
import ProfileImage from './ProfileImage';
import StealthModeToggle from './StealthModeToggle';
import WelcomeNotification from './WelcomeNotification';

import { Button } from '@/components/ui/button';
import { useToast } from '@/hooks/use-toast';
import { apiRequest } from '@/lib/queryClient';
import type { useChat } from '@/hooks/useChat';
import type { ChatUser } from '@/types/chat';

interface ChatInterfaceProps {
  chat: ReturnType<typeof useChat>;
  onLogout: () => void;
}

export default function ChatInterface({ chat, onLogout }: ChatInterfaceProps) {
  const [showProfile, setShowProfile] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  const [selectedPrivateUser, setSelectedPrivateUser] = useState<ChatUser | null>(null);
  const [showReportModal, setShowReportModal] = useState(false);
  const [showAdminReports, setShowAdminReports] = useState(false);

  const [showNotifications, setShowNotifications] = useState(false);
  const [showFriends, setShowFriends] = useState(false);
  const [showMessages, setShowMessages] = useState(false);
  const [showModerationPanel, setShowModerationPanel] = useState(false);
  const [showOwnerPanel, setShowOwnerPanel] = useState(false);
  const [showReportsLog, setShowReportsLog] = useState(false);
  const [showActiveActions, setShowActiveActions] = useState(false);
  const [showPromotePanel, setShowPromotePanel] = useState(false);

  const [newMessageAlert, setNewMessageAlert] = useState<{
    show: boolean;
    sender: ChatUser | null;
  }>({
    show: false,
    sender: null,
  });

  // ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡ Ø¹Ù†Ø¯ ÙˆØµÙˆÙ„ Ø±Ø³Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø©
  useEffect(() => {
    if (chat.newMessageSender) {
      setNewMessageAlert({
        show: true,
        sender: chat.newMessageSender,
      });
    }
  }, [chat.newMessageSender]);
  const [reportedUser, setReportedUser] = useState<ChatUser | null>(null);
  const [reportedMessage, setReportedMessage] = useState<{ content: string; id: number } | null>(null);
  const [userPopup, setUserPopup] = useState<{
    show: boolean;
    user: ChatUser | null;
    x: number;
    y: number;
  }>({
    show: false,
    user: null,
    x: 0,
    y: 0,
  });
  const { toast } = useToast();

  const handleUserClick = (event: React.MouseEvent, user: ChatUser) => {
    event.stopPropagation();
    setUserPopup({
      show: true,
      user,
      x: event.clientX,
      y: event.clientY,
    });
  };

  const closeUserPopup = () => {
    setUserPopup(prev => ({ ...prev, show: false }));
  };

  const handlePrivateMessage = (user: ChatUser) => {
    setSelectedPrivateUser(user);
    closeUserPopup();
  };

  const closePrivateMessage = () => {
    setSelectedPrivateUser(null);
  };

  const handleAddFriend = async (user: ChatUser) => {
    if (!chat.currentUser) return;
    
    try {
      console.log('Sending friend request:', { senderId: chat.currentUser.id, receiverId: user.id });
      
      const response = await apiRequest('/api/friend-requests', {
        method: 'POST',
        body: {
          senderId: chat.currentUser.id,
          receiverId: user.id,
        }
      });
      
      console.log('Friend request response:', response);
      
      toast({
        title: "ØªÙ…Øª Ø§Ù„Ø¥Ø¶Ø§ÙØ©",
        description: `ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ ØµØ¯Ø§Ù‚Ø© Ø¥Ù„Ù‰ ${user.username}`,
      });
    } catch (error) {
      console.error('Friend request error:', error);
      toast({
        title: "Ø®Ø·Ø£",
        description: error instanceof Error ? error.message : "Ù„Ù… Ù†ØªÙ…ÙƒÙ† Ù…Ù† Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø©",
        variant: "destructive",
      });
    }
    closeUserPopup();
  };

  const handleIgnoreUser = (user: ChatUser) => {
    chat.ignoreUser(user.id);
    toast({
      title: "ØªÙ… Ø§Ù„ØªØ¬Ø§Ù‡Ù„",
      description: `ØªÙ… ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ${user.username} - Ù„Ù† ØªØ±Ù‰ Ø±Ø³Ø§Ø¦Ù„Ù‡ Ø¨Ø¹Ø¯ Ø§Ù„Ø¢Ù†`,
    });
    closeUserPopup();
  };



  const handleViewProfile = (user: ChatUser) => {
    setShowProfile(true);
    setSelectedPrivateUser(user);
    closeUserPopup();
  };

  const handleReportUser = (user: ChatUser, messageContent?: string, messageId?: number) => {
    setReportedUser(user);
    setReportedMessage(messageContent && messageId ? { content: messageContent, id: messageId } : null);
    setShowReportModal(true);
    closeUserPopup();
  };

  const closeReportModal = () => {
    setShowReportModal(false);
    setReportedUser(null);
    setReportedMessage(null);
  };

  return (
    <div className="h-screen flex flex-col bg-gradient-to-br from-slate-900 via-blue-900 to-slate-900" onClick={closeUserPopup}>
      {/* Header - Ù…Ø­Ø³Ù† */}
      <header className="bg-gradient-to-r from-slate-800/90 to-blue-800/90 backdrop-blur-xl py-4 px-6 flex justify-between items-center shadow-2xl border-b border-blue-500/30 relative overflow-hidden">
        {/* ØªØ£Ø«ÙŠØ± Ø®Ù„ÙÙŠØ© Ù…ØªØ­Ø±Ùƒ */}
        <div className="absolute inset-0 bg-gradient-to-r from-blue-500/10 via-purple-500/10 to-pink-500/10 animate-pulse"></div>
        
        <div className="flex items-center gap-3 relative z-10">
          <div className="text-3xl animate-bounce">ğŸ’¬</div>
          <div className="text-2xl font-bold text-white">
            <span className="bg-gradient-to-r from-blue-400 to-purple-400 bg-clip-text text-transparent">
              Arabic
            </span>
            <span className="text-primary ml-2">Chat</span>
          </div>
        </div>
        
        <div className="flex gap-3 relative z-10">
          <Button 
            className="bg-gradient-to-r from-blue-500/20 to-purple-500/20 backdrop-blur-md px-4 py-2 rounded-xl hover:from-blue-500/30 hover:to-purple-500/30 transition-all duration-300 flex items-center gap-2 relative border border-blue-400/30 hover:border-blue-400/50 hover:scale-105"
            onClick={() => setShowNotifications(true)}
          >
            <span className="text-lg">ğŸ””</span>
            <span className="font-semibold">Ø¥Ø´Ø¹Ø§Ø±Ø§Øª</span>
          </Button>
          
          <Button 
            className="bg-gradient-to-r from-green-500/20 to-emerald-500/20 backdrop-blur-md px-4 py-2 rounded-xl hover:from-green-500/30 hover:to-emerald-500/30 transition-all duration-300 flex items-center gap-2 relative border border-green-400/30 hover:border-green-400/50 hover:scale-105"
            onClick={() => setShowFriends(true)}
          >
            <span className="text-lg">ğŸ‘¥</span>
            <span className="font-semibold">Ø§Ù„Ø£ØµØ¯Ù‚Ø§Ø¡</span>
            {/* ØªÙ†Ø¨ÙŠÙ‡ Ø·Ù„Ø¨Ø§Øª Ø§Ù„ØµØ¯Ø§Ù‚Ø© */}
            <FriendRequestBadge currentUser={chat.currentUser} />
          </Button>

          <Button 
            className="bg-gradient-to-r from-purple-500/20 to-pink-500/20 backdrop-blur-md px-4 py-2 rounded-xl hover:from-purple-500/30 hover:to-pink-500/30 transition-all duration-300 flex items-center gap-2 border border-purple-400/30 hover:border-purple-400/50 hover:scale-105"
            onClick={() => setShowMessages(true)}
            title="Ø§Ù„Ø±Ø³Ø§Ø¦Ù„"
          >
            <span>âœ‰ï¸</span>
            Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
          </Button>
          
          {/* Ø²Ø± Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† */}
          {chat.currentUser && (chat.currentUser.userType === 'owner' || chat.currentUser.userType === 'admin') && (
            <>
              <Button 
                className="glass-effect px-4 py-2 rounded-lg hover:bg-accent transition-all duration-200 flex items-center gap-2"
                onClick={() => setShowModerationPanel(true)}
              >
                <span>ğŸ›¡ï¸</span>
                Ø¥Ø¯Ø§Ø±Ø©
              </Button>
              
              <StealthModeToggle currentUser={chat.currentUser} />
              
              <Button 
                className="glass-effect px-4 py-2 rounded-lg hover:bg-red-600 transition-all duration-200 flex items-center gap-2 border border-red-400 relative"
                onClick={() => setShowReportsLog(true)}
              >
                <span>âš ï¸</span>
                Ø³Ø¬Ù„ Ø§Ù„Ø¨Ù„Ø§ØºØ§Øª
              </Button>
              
              <Button 
                className="glass-effect px-4 py-2 rounded-lg hover:bg-yellow-600 transition-all duration-200 flex items-center gap-2 border border-yellow-400"
                onClick={() => setShowActiveActions(true)}
              >
                <span>ğŸ”’</span>
                Ø³Ø¬Ù„ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø©
              </Button>

              {/* Ø²Ø± ØªØ±Ù‚ÙŠØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† - Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø· */}
              {chat.currentUser?.userType === 'owner' && (
                <Button 
                  className="glass-effect px-4 py-2 rounded-lg hover:bg-blue-600 transition-all duration-200 flex items-center gap-2"
                  onClick={() => setShowPromotePanel(true)}
                >
                  <span>ğŸ‘‘</span>
                  ØªØ±Ù‚ÙŠØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
                </Button>
              )}
            </>
          )}

          {/* Ø²Ø± Ø®Ø§Øµ Ø¨Ø§Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø· */}
          {chat.currentUser && chat.currentUser.userType === 'owner' && (
            <Button 
              className="glass-effect px-4 py-2 rounded-lg hover:bg-purple-600 transition-all duration-200 flex items-center gap-2 border border-purple-400"
              onClick={() => setShowOwnerPanel(true)}
            >
              <span>ğŸ‘‘</span>
              Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø§Ù„Ùƒ
            </Button>
          )}
          
          <Button 
            className="glass-effect px-4 py-2 rounded-lg hover:bg-accent transition-all duration-200 flex items-center gap-2"
            onClick={() => setShowSettings(!showSettings)}
          >
            <span>âš™ï¸</span>
            Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
          </Button>


        </div>
      </header>
      
      {/* Main Content */}
      <main className="flex flex-1 overflow-hidden">
        <UserSidebar 
          users={chat.onlineUsers}
          onUserClick={handleUserClick}
          currentUser={chat.currentUser}
        />
        <MessageArea 
          messages={chat.publicMessages}
          currentUser={chat.currentUser}
          onSendMessage={chat.sendPublicMessage}
          onTyping={chat.handleTyping}
          typingUsers={chat.typingUsers}
          onReportMessage={handleReportUser}
          onUserClick={handleUserClick}
        />
      </main>

      {/* Modals and Popups */}
      {showProfile && (
        <ProfileModal 
          user={selectedPrivateUser || chat.currentUser}
          currentUser={chat.currentUser}
          onClose={() => {
            setShowProfile(false);
            if (selectedPrivateUser) setSelectedPrivateUser(null);
          }}
          onIgnoreUser={(userId) => {
            chat.ignoreUser(userId);
          }}
        />
      )}

      {selectedPrivateUser && (
        <PrivateMessageBox
          isOpen={!!selectedPrivateUser}
          user={selectedPrivateUser}
          currentUser={chat.currentUser}
          messages={chat.privateConversations[selectedPrivateUser.id] || []}
          onSendMessage={(content) => chat.sendPrivateMessage(selectedPrivateUser.id, content)}
          onClose={closePrivateMessage}
        />
      )}

      {userPopup.show && userPopup.user && (
        <UserPopup
          user={userPopup.user}
          x={userPopup.x}
          y={userPopup.y}
          onPrivateMessage={() => handlePrivateMessage(userPopup.user!)}
          onAddFriend={() => handleAddFriend(userPopup.user!)}
          onIgnore={() => {
            // Ø¥Ø²Ø§Ù„Ø© Ø²Ø± Ø§Ù„ØªØ¬Ø§Ù‡Ù„ Ù…Ù† UserPopup - Ø§Ù„Ø¢Ù† ÙÙŠ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ ÙÙ‚Ø·
          }}
          onViewProfile={() => handleViewProfile(userPopup.user!)}
          currentUser={chat.currentUser}
          onClose={closeUserPopup}
        />
      )}

      {showSettings && (
        <SettingsMenu
          onOpenProfile={() => {
            setShowProfile(true);
            setShowSettings(false);
          }}
          onLogout={onLogout}
          onClose={() => setShowSettings(false)}
          onOpenReports={() => {
            setShowAdminReports(true);
            setShowSettings(false);
          }}
          currentUser={chat.currentUser}
        />
      )}

      {showReportModal && (
        <ReportModal
          isOpen={showReportModal}
          onClose={closeReportModal}
          reportedUser={reportedUser}
          currentUser={chat.currentUser}
          messageContent={reportedMessage?.content}
          messageId={reportedMessage?.id}
        />
      )}

      {showNotifications && (
        <NotificationPanel
          isOpen={showNotifications}
          onClose={() => setShowNotifications(false)}
          currentUser={chat.currentUser}
        />
      )}

      {/* Admin Reports Panel */}
      {showAdminReports && chat.currentUser && chat.currentUser.userType === 'owner' && (
        <AdminReportsPanel
          isOpen={showAdminReports}
          onClose={() => setShowAdminReports(false)}
          currentUser={chat.currentUser}
        />
      )}

      {showFriends && (
        <FriendsPanel
          isOpen={showFriends}
          onClose={() => setShowFriends(false)}
          currentUser={chat.currentUser}
          onlineUsers={chat.onlineUsers}
          onStartPrivateChat={(friend) => {
            setSelectedPrivateUser(friend);
            setShowFriends(false);
          }}
        />
      )}

      {showMessages && (
        <MessagesPanel
          isOpen={showMessages}
          onClose={() => setShowMessages(false)}
          currentUser={chat.currentUser}
          privateConversations={chat.privateConversations}
          onlineUsers={chat.onlineUsers}
          onStartPrivateChat={(user) => {
            setSelectedPrivateUser(user);
            setShowMessages(false);
          }}
        />
      )}

      {showModerationPanel && (
        <ModerationPanel
          isOpen={showModerationPanel}
          onClose={() => setShowModerationPanel(false)}
          currentUser={chat.currentUser}
          onlineUsers={chat.onlineUsers}
        />
      )}

      {showOwnerPanel && (
        <OwnerAdminPanel 
          isOpen={showOwnerPanel}
          onClose={() => setShowOwnerPanel(false)}
          currentUser={chat.currentUser}
          onlineUsers={chat.onlineUsers}
        />
      )}

      {showModerationPanel && (
        <ModerationPanel 
          isOpen={showModerationPanel}
          onClose={() => setShowModerationPanel(false)}
          currentUser={chat.currentUser}
          onlineUsers={chat.onlineUsers}
        />
      )}

      {showReportsLog && (
        <ReportsLog 
          isVisible={showReportsLog}
          onClose={() => setShowReportsLog(false)}
          currentUser={chat.currentUser}
        />
      )}

      {showActiveActions && (
        <ActiveModerationLog 
          isVisible={showActiveActions}
          onClose={() => setShowActiveActions(false)}
          currentUser={chat.currentUser}
        />
      )}

      {showPromotePanel && (
        <PromoteUserPanel 
          isVisible={showPromotePanel}
          onClose={() => setShowPromotePanel(false)}
          currentUser={chat.currentUser}
          onlineUsers={chat.onlineUsers}
        />
      )}

      {/* Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø§Ù„Ø·Ø±Ø¯ ÙˆØ§Ù„Ø­Ø¬Ø¨ */}
      <KickNotification
        isVisible={chat.kickNotification?.show || false}
        durationMinutes={chat.kickNotification?.duration || 15}
        onClose={() => {}}
      />
      
      <BlockNotification
        isVisible={chat.blockNotification?.show || false}
        reason={chat.blockNotification?.reason || ''}
        onClose={() => {}}
      />

      {/* ØªÙ†Ø¨ÙŠÙ‡ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© */}
      <MessageAlert
        isOpen={newMessageAlert.show}
        sender={newMessageAlert.sender}
        onClose={() => setNewMessageAlert({ show: false, sender: null })}
        onOpenMessages={() => setShowMessages(true)}
      />

      {/* Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„ØªØ±Ø­ÙŠØ¨ */}
      {chat.currentUser && <WelcomeNotification user={chat.currentUser} />}

    </div>
  );
}

import { useState, useCallback, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { UserPlus, Loader2, Zap, Shield, Users } from 'lucide-react';
import { apiRequest } from '@/lib/queryClient';
import { useToast } from '@/hooks/use-toast';
import UserRegistration from './UserRegistration';
import type { ChatUser } from '@/types/chat';

interface WelcomeScreenProps {
  onUserLogin: (user: ChatUser) => void;
}

export default function WelcomeScreen({ onUserLogin }: WelcomeScreenProps) {
  const [showGuestModal, setShowGuestModal] = useState(false);
  const [showMemberModal, setShowMemberModal] = useState(false);
  const [showRegisterModal, setShowRegisterModal] = useState(false);
  const [guestName, setGuestName] = useState('');
  const [guestGender, setGuestGender] = useState('male');
  const [memberName, setMemberName] = useState('');
  const [memberPassword, setMemberPassword] = useState('');
  const [registerName, setRegisterName] = useState('');
  const [registerPassword, setRegisterPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [registerGender, setRegisterGender] = useState('male');
  const [loading, setLoading] = useState(false);
  const [isPreloading, setIsPreloading] = useState(true);
  const { toast } = useToast();

  // ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø³Ø¨Ù‚
  useEffect(() => {
    const preloadResources = async () => {
      try {
        // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ù‡Ù…Ø© Ù…Ø³Ø¨Ù‚Ø§Ù‹
        const resources = [
          '/default_avatar.svg',
          '/notification.mp3'
        ];

        await Promise.allSettled(
          resources.map(resource => {
            if (resource.endsWith('.mp3')) {
              return new Promise((resolve) => {
                const audio = new Audio(resource);
                audio.preload = 'metadata';
                audio.onloadedmetadata = resolve;
                audio.onerror = resolve;
              });
            } else {
              return new Promise((resolve) => {
                const img = new Image();
                img.onload = resolve;
                img.onerror = resolve;
                img.src = resource;
              });
            }
          })
        );

        // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ù…Ø³Ø¨Ù‚Ø§Ù‹
        await Promise.allSettled([
          fetch('/api/users').catch(() => {}),
          fetch('/api/messages/public').catch(() => {})
        ]);

        console.log('ğŸš€ ØªÙ… Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø³Ø¨Ù‚ Ø¨Ù†Ø¬Ø§Ø­');
      } catch (error) {
        console.log('âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø³Ø¨Ù‚:', error);
      } finally {
        setIsPreloading(false);
      }
    };

    preloadResources();
  }, []);

  // ØªØ­Ø³ÙŠÙ† ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„ Ø§Ù„Ø²Ø§Ø¦Ø±
  const handleGuestLogin = useCallback(async () => {
    if (!guestName.trim()) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… Ø§Ù„Ø²Ø§Ø¦Ø±",
        variant: "destructive",
      });
      return;
    }

    setLoading(true);
    try {
      const data = await apiRequest('/api/auth/guest', {
        method: 'POST',
        body: {
          username: guestName.trim(),
          gender: guestGender,
        }
      });
      
      toast({
        title: "Ù…Ø±Ø­Ø¨Ø§Ù‹! ğŸ‘‹",
        description: `ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„Ùƒ ÙƒØ²Ø§Ø¦Ø± Ø¨Ù†Ø¬Ø§Ø­`,
      });
      
      onUserLogin(data.user);
      setShowGuestModal(false);
    } catch (error: any) {
      toast({
        title: "Ø®Ø·Ø£",
        description: error.message || "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  }, [guestName, guestGender, onUserLogin, toast]);

  // ØªØ­Ø³ÙŠÙ† ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„ Ø§Ù„Ø¹Ø¶Ùˆ
  const handleMemberLogin = useCallback(async () => {
    if (!memberName.trim() || !memberPassword.trim()) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙˆÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±",
        variant: "destructive",
      });
      return;
    }

    setLoading(true);
    try {
      const data = await apiRequest('/api/auth/member', {
        method: 'POST',
        body: {
          username: memberName.trim(),
          password: memberPassword.trim(),
        }
      });
      
      toast({
        title: "Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ø¹ÙˆØ¯ØªÙƒ! ğŸ‰",
        description: `ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„Ùƒ Ø¨Ù†Ø¬Ø§Ø­`,
      });
      
      onUserLogin(data.user);
      setShowMemberModal(false);
    } catch (error: any) {
      toast({
        title: "Ø®Ø·Ø£",
        description: error.message || "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  }, [memberName, memberPassword, onUserLogin, toast]);

  // ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªØ³Ø¬ÙŠÙ„
  const handleRegister = useCallback(async () => {
    if (!registerName.trim() || !registerPassword.trim() || !confirmPassword.trim()) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "ÙŠØ±Ø¬Ù‰ Ù…Ù„Ø¡ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„",
        variant: "destructive",
      });
      return;
    }

    if (registerPassword !== confirmPassword) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± Ù…ØªØ·Ø§Ø¨Ù‚Ø©",
        variant: "destructive",
      });
      return;
    }

    if (registerPassword.length < 6) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† 6 Ø£Ø­Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„",
        variant: "destructive",
      });
      return;
    }

    setLoading(true);
    try {
      const data = await apiRequest('/api/auth/register', {
        method: 'POST',
        body: {
          username: registerName.trim(),
          password: registerPassword.trim(),
          confirmPassword: confirmPassword.trim(),
          gender: registerGender,
        }
      });
      
      toast({
        title: "Ø£Ù‡Ù„Ø§Ù‹ ÙˆØ³Ù‡Ù„Ø§Ù‹! ğŸŠ",
        description: "ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨Ùƒ Ø¨Ù†Ø¬Ø§Ø­",
      });
      
      onUserLogin(data.user);
      setShowRegisterModal(false);
    } catch (error: any) {
      toast({
        title: "Ø®Ø·Ø£",
        description: error.message || "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ³Ø¬ÙŠÙ„",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  }, [registerName, registerPassword, confirmPassword, registerGender, onUserLogin, toast]);

  const handleGoogleLogin = useCallback(() => {
    toast({
      title: "Ù‚Ø±ÙŠØ¨Ø§Ù‹",
      description: "ğŸ”„ Ø¬Ø§Ø±ÙŠ ØªØ·ÙˆÙŠØ± Ø®Ø¯Ù…Ø© ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ù€ Google",
    });
  }, [toast]);

  // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ - Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ localStorage
  const saveToLocalStorage = useCallback((key: string, data: any) => {
    try {
      localStorage.setItem(key, JSON.stringify(data));
    } catch (error) {
      console.log('Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ù„ÙŠØ©:', error);
    }
  }, []);

  const loadFromLocalStorage = useCallback((key: string) => {
    try {
      const data = localStorage.getItem(key);
      return data ? JSON.parse(data) : null;
    } catch (error) {
      console.log('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ù„ÙŠØ©:', error);
      return null;
    }
  }, []);

  // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©
  useEffect(() => {
    const savedGuestName = loadFromLocalStorage('guestName');
    const savedMemberName = loadFromLocalStorage('memberName');
    
    if (savedGuestName) setGuestName(savedGuestName);
    if (savedMemberName) setMemberName(savedMemberName);
  }, [loadFromLocalStorage]);

  // Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù†Ø¯ Ø§Ù„ØªØºÙŠÙŠØ±
  useEffect(() => {
    if (guestName) saveToLocalStorage('guestName', guestName);
  }, [guestName, saveToLocalStorage]);

  useEffect(() => {
    if (memberName) saveToLocalStorage('memberName', memberName);
  }, [memberName, saveToLocalStorage]);

  if (isPreloading) {
    return (
      <div className="h-screen flex flex-col justify-center items-center welcome-gradient">
        <div className="text-center animate-pulse">
          <div className="text-6xl mb-4 animate-bounce">ğŸ’¬</div>
          <h2 className="text-2xl font-bold mb-2 bg-gradient-to-r from-primary to-blue-400 bg-clip-text text-transparent">
            Ø¬Ø§Ø±ÙŠ ØªØ­Ø¶ÙŠØ± Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©...
          </h2>
          <div className="flex justify-center mt-4">
            <Loader2 className="w-8 h-8 animate-spin text-primary" />
          </div>
          <p className="text-sm text-muted-foreground mt-4">ÙŠØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙˆØ§Ø±Ø¯ Ø¨Ø³Ø±Ø¹Ø©...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="h-screen flex flex-col justify-center items-center welcome-gradient">
      <div className="text-center animate-slide-up">
        <div className="mb-8">
          <div className="text-6xl mb-4 animate-pulse-slow">ğŸ’¬</div>
          <h1 className="text-5xl font-bold mb-4 bg-gradient-to-r from-primary to-blue-400 bg-clip-text text-transparent">
            Ù…Ø±Ø­Ø¨Ù‹Ø§ Ø¨Ùƒ ÙÙŠ Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ø¹Ø±Ø¨
          </h1>
          <p className="text-xl text-muted-foreground mb-8">Ù…Ù†ØµØ© Ø§Ù„ØªÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ø£ÙˆÙ„Ù‰</p>
          
          {/* Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡ */}
          <div className="flex justify-center gap-4 mb-6 text-sm text-muted-foreground">
            <div className="flex items-center gap-1">
              <Zap className="w-4 h-4 text-green-500" />
              <span>Ø³Ø±ÙŠØ¹</span>
            </div>
            <div className="flex items-center gap-1">
              <Shield className="w-4 h-4 text-blue-500" />
              <span>Ø¢Ù…Ù†</span>
            </div>
            <div className="flex items-center gap-1">
              <Users className="w-4 h-4 text-purple-500" />
              <span>Ù…Ø¬ØªÙ…Ø¹ÙŠ</span>
            </div>
          </div>
        </div>
        
        <div className="flex flex-col sm:flex-row gap-4 justify-center items-center">
          <Button 
            className="btn-success text-white font-semibold py-3 px-8 rounded-xl shadow-lg flex items-center gap-3 hover:scale-105 transition-all duration-200"
            onClick={() => setShowGuestModal(true)}
            disabled={loading}
          >
            <span>ğŸ‘¤</span>
            Ø¯Ø®ÙˆÙ„ ÙƒØ²Ø§Ø¦Ø±
          </Button>
          
          <Button 
            className="btn-primary text-white font-semibold py-3 px-8 rounded-xl shadow-lg flex items-center gap-3 hover:scale-105 transition-all duration-200"
            onClick={() => setShowMemberModal(true)}
            disabled={loading}
          >
            <span>âœ…</span>
            Ø¯Ø®ÙˆÙ„ ÙƒØ¹Ø¶Ùˆ
          </Button>
          
          <Button 
            className="bg-gradient-to-r from-purple-600 to-purple-700 hover:from-purple-700 hover:to-purple-800 text-white font-semibold py-3 px-8 rounded-xl shadow-lg flex items-center gap-3 transition-all duration-300 hover:scale-105"
            onClick={() => setShowRegisterModal(true)}
            disabled={loading}
          >
            <span>ğŸ“</span>
            ØªØ³Ø¬ÙŠÙ„ Ø¹Ø¶ÙˆÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©
          </Button>
          
          <Button 
            className="btn-danger text-white font-semibold py-3 px-8 rounded-xl shadow-lg flex items-center gap-3 hover:scale-105 transition-all duration-200"
            onClick={handleGoogleLogin}
            disabled={loading}
          >
            <span>ğŸ”</span>
            Ø¯Ø®ÙˆÙ„ Ø¨Ù€ Google
          </Button>
        </div>
      </div>

      {/* Guest Name Modal */}
      <Dialog open={showGuestModal} onOpenChange={setShowGuestModal}>
        <DialogContent className="glass-effect border border-border animate-fade-in">
          <DialogHeader>
            <DialogTitle className="text-center text-2xl font-bold text-white flex items-center justify-center gap-2">
              <span>ğŸ“</span>
              Ø£Ø¯Ø®Ù„ Ø§Ø³Ù… Ø§Ù„Ø²Ø§Ø¦Ø±
            </DialogTitle>
          </DialogHeader>
          
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-white mb-2">Ø§Ø³Ù… Ø§Ù„Ø²Ø§Ø¦Ø±</label>
              <Input
                type="text"
                placeholder="Ø£Ø¯Ø®Ù„ Ø§Ø³Ù…Ùƒ"
                value={guestName}
                onChange={(e) => setGuestName(e.target.value)}
                className="glass-input"
                disabled={loading}
                onKeyPress={(e) => e.key === 'Enter' && handleGuestLogin()}
              />
            </div>
            
            <div>
              <label className="block text-sm font-medium text-white mb-2">Ø§Ù„Ø¬Ù†Ø³</label>
              <select
                value={guestGender}
                onChange={(e) => setGuestGender(e.target.value)}
                className="w-full p-3 rounded-lg bg-white/10 border border-white/20 text-white"
                disabled={loading}
              >
                <option value="male">Ø°ÙƒØ±</option>
                <option value="female">Ø£Ù†Ø«Ù‰</option>
              </select>
            </div>
            
            <Button
              onClick={handleGuestLogin}
              disabled={loading || !guestName.trim()}
              className="w-full btn-success text-white font-semibold py-3 rounded-xl"
            >
              {loading ? (
                <>
                  <Loader2 className="w-4 h-4 animate-spin mr-2" />
                  Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¯Ø®ÙˆÙ„...
                </>
              ) : (
                <>
                  <span>ğŸš€</span>
                  Ø¯Ø®ÙˆÙ„ Ø³Ø±ÙŠØ¹
                </>
              )}
            </Button>
          </div>
        </DialogContent>
      </Dialog>

      {/* Member Login Modal */}
      <Dialog open={showMemberModal} onOpenChange={setShowMemberModal}>
        <DialogContent className="glass-effect border border-border animate-fade-in">
          <DialogHeader>
            <DialogTitle className="text-center text-2xl font-bold text-white flex items-center justify-center gap-2">
              <span>âœ…</span>
              Ø¯Ø®ÙˆÙ„ Ø§Ù„Ø¹Ø¶Ùˆ
            </DialogTitle>
          </DialogHeader>
          
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-white mb-2">Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…</label>
              <Input
                type="text"
                placeholder="Ø£Ø¯Ø®Ù„ Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…"
                value={memberName}
                onChange={(e) => setMemberName(e.target.value)}
                className="glass-input"
                disabled={loading}
                onKeyPress={(e) => e.key === 'Enter' && handleMemberLogin()}
              />
            </div>
            
            <div>
              <label className="block text-sm font-medium text-white mb-2">ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±</label>
              <Input
                type="password"
                placeholder="Ø£Ø¯Ø®Ù„ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±"
                value={memberPassword}
                onChange={(e) => setMemberPassword(e.target.value)}
                className="glass-input"
                disabled={loading}
                onKeyPress={(e) => e.key === 'Enter' && handleMemberLogin()}
              />
            </div>
            
            <Button
              onClick={handleMemberLogin}
              disabled={loading || !memberName.trim() || !memberPassword.trim()}
              className="w-full btn-primary text-white font-semibold py-3 rounded-xl"
            >
              {loading ? (
                <>
                  <Loader2 className="w-4 h-4 animate-spin mr-2" />
                  Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù‚Ù‚...
                </>
              ) : (
                <>
                  <span>ğŸ”</span>
                  ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„
                </>
              )}
            </Button>
          </div>
        </DialogContent>
      </Dialog>

      {/* Register Modal */}
      <Dialog open={showRegisterModal} onOpenChange={setShowRegisterModal}>
        <DialogContent className="glass-effect border border-border animate-fade-in max-w-md">
          <DialogHeader>
            <DialogTitle className="text-center text-2xl font-bold text-white flex items-center justify-center gap-2">
              <UserPlus className="w-6 h-6" />
              ØªØ³Ø¬ÙŠÙ„ Ø¹Ø¶ÙˆÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©
            </DialogTitle>
          </DialogHeader>
          
          <UserRegistration
            onRegister={handleRegister}
            loading={loading}
            name={registerName}
            setName={setRegisterName}
            password={registerPassword}
            setPassword={setRegisterPassword}
            confirmPassword={confirmPassword}
            setConfirmPassword={setConfirmPassword}
            gender={registerGender}
            setGender={setRegisterGender}
          />
        </DialogContent>
      </Dialog>
    </div>
  );
}

import { useState, useEffect, useRef, useCallback } from 'react';
import type { ChatUser, ChatMessage } from '@/types/chat';

interface CleanChatHook {
  // State
  user: ChatUser | null;
  users: ChatUser[];
  messages: ChatMessage[];
  friends: ChatUser[];
  friendRequests: any[];
  notifications: any[];
  isConnected: boolean;
  
  // Actions
  connect: (user: ChatUser) => void;
  disconnect: () => void;
  sendMessage: (content: string, recipientId?: number) => void;
  sendFriendRequest: (targetUserId: number) => void;
  acceptFriendRequest: (senderId: number) => void;
  declineFriendRequest: (senderId: number) => void;
  removeFriend: (friendId: number) => void;
  
  // UI State
  isTyping: boolean;
  setIsTyping: (typing: boolean) => void;
  
  // Performance State
  isLoading: boolean;
  connectionStatus: 'connecting' | 'connected' | 'disconnected' | 'error';
}

export function useCleanChat(): CleanChatHook {
  const [user, setUser] = useState<ChatUser | null>(null);
  const [users, setUsers] = useState<ChatUser[]>([]);
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [friends, setFriends] = useState<ChatUser[]>([]);
  const [friendRequests, setFriendRequests] = useState<any[]>([]);
  const [notifications, setNotifications] = useState<any[]>([]);
  const [isConnected, setIsConnected] = useState(false);
  const [isTyping, setIsTyping] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState<'connecting' | 'connected' | 'disconnected' | 'error'>('disconnected');
  
  const wsRef = useRef<WebSocket | null>(null);
  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const dataCacheRef = useRef<Map<string, any>>(new Map());

  // ØªØ­Ø³ÙŠÙ† API calls Ù…Ø¹ Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª
  const apiRequest = useCallback(async (url: string, options: RequestInit = {}, useCache = false) => {
    const cacheKey = `${url}-${JSON.stringify(options)}`;
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª
    if (useCache && dataCacheRef.current.has(cacheKey)) {
      const cachedData = dataCacheRef.current.get(cacheKey);
      const cacheAge = Date.now() - cachedData.timestamp;
      
      // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª Ø¥Ø°Ø§ ÙƒØ§Ù† Ø¹Ù…Ø±Ù‡ Ø£Ù‚Ù„ Ù…Ù† 30 Ø«Ø§Ù†ÙŠØ©
      if (cacheAge < 30000) {
        return cachedData.data;
      }
    }

    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000); // timeout 10 Ø«ÙˆØ§Ù†ÙŠ

      const response = await fetch(url, {
        headers: {
          'Content-Type': 'application/json',
          ...options.headers
        },
        signal: controller.signal,
        ...options
      });
      
      clearTimeout(timeoutId);
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…' }));
        throw new Error(errorData.error || 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…');
      }
      
      const data = await response.json();
      
      // Ø­ÙØ¸ ÙÙŠ Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª
      if (useCache) {
        dataCacheRef.current.set(cacheKey, {
          data,
          timestamp: Date.now()
        });
      }
      
      return data;
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        throw new Error('Ø§Ù†ØªÙ‡Øª Ù…Ù‡Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„');
      }
      throw error;
    }
  }, []);

  // ØªØ­Ø³ÙŠÙ† WebSocket connection Ù…Ø¹ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
  const connectWebSocket = useCallback((userData: ChatUser) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.close();
    }

    setConnectionStatus('connecting');
    const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
    const wsUrl = `${protocol}//${window.location.host}/ws`;
    
    wsRef.current = new WebSocket(wsUrl);
    
    // ØªØ­Ø³ÙŠÙ† Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª WebSocket
    wsRef.current.binaryType = 'arraybuffer';
    
    wsRef.current.onopen = () => {
      console.log('ğŸ”— WebSocket connected');
      setIsConnected(true);
      setConnectionStatus('connected');
      
      // Ø¥Ø±Ø³Ø§Ù„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø© ÙÙˆØ±Ø§Ù‹
      wsRef.current?.send(JSON.stringify({
        type: 'authenticate',
        userId: userData.id,
        username: userData.username,
        timestamp: Date.now()
      }));
    };
    
    wsRef.current.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        handleWebSocketMessage(data);
      } catch (error) {
        console.error('WebSocket message error:', error);
      }
    };
    
    wsRef.current.onclose = (event) => {
      console.log('ğŸ”Œ WebSocket disconnected:', event.code, event.reason);
      setIsConnected(false);
      setConnectionStatus('disconnected');
      
      // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ Ù…Ù‚ØµÙˆØ¯Ø§Ù‹
      if (event.code !== 1000 && user) {
        console.log('ğŸ”„ Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„...');
        setConnectionStatus('connecting');
        
        if (reconnectTimeoutRef.current) {
          clearTimeout(reconnectTimeoutRef.current);
        }
        
        reconnectTimeoutRef.current = setTimeout(() => {
          if (user) {
            connectWebSocket(user);
          }
        }, 3000);
      }
    };
    
    wsRef.current.onerror = (error) => {
      console.error('WebSocket error:', error);
      setIsConnected(false);
      setConnectionStatus('error');
    };
  }, [user]);

  const handleWebSocketMessage = useCallback((data: any) => {
    switch (data.type) {
      case 'newMessage':
        setMessages(prev => {
          // ØªØ¬Ù†Ø¨ ØªÙƒØ±Ø§Ø± Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
          if (prev.some(msg => msg.id === data.message.id)) {
            return prev;
          }
          return [...prev, data.message];
        });
        break;
        
      case 'userOnline':
        setUsers(prev => prev.map(u => 
          u.id === data.userId ? { ...u, isOnline: true, lastSeen: new Date().toISOString() } : u
        ));
        break;
        
      case 'userOffline':
        setUsers(prev => prev.map(u => 
          u.id === data.userId ? { ...u, isOnline: false, lastSeen: data.lastSeen || new Date().toISOString() } : u
        ));
        break;
        
      case 'friendRequest':
        loadFriendRequests();
        loadNotifications();
        break;
        
      case 'friendshipAccepted':
        loadFriends();
        break;
        
      case 'friendRemoved':
        loadFriends();
        break;
        
      case 'userUpdated':
        setUsers(prev => prev.map(u => 
          u.id === data.user.id ? { ...u, ...data.user } : u
        ));
        break;
        
      case 'typing':
        // ØªØ­Ø³ÙŠÙ† Ù…Ø¤Ø´Ø± Ø§Ù„ÙƒØªØ§Ø¨Ø©
        if (data.userId !== user?.id) {
          setUsers(prev => prev.map(u => 
            u.id === data.userId ? { ...u, isTyping: data.isTyping } : u
          ));
        }
        break;
    }
  }, [user]);

  // ØªØ­Ø³ÙŠÙ† ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ØªÙˆØ§Ø²ÙŠ
  const loadUsers = useCallback(async () => {
    try {
      const data = await apiRequest('/api/users', {}, true);
      setUsers(data.users || []);
    } catch (error) {
      console.error('Error loading users:', error);
    }
  }, [apiRequest]);

  const loadMessages = useCallback(async () => {
    try {
      const data = await apiRequest('/api/messages/public', {}, true);
      setMessages(data.messages || []);
    } catch (error) {
      console.error('Error loading messages:', error);
    }
  }, [apiRequest]);

  const loadFriends = useCallback(async () => {
    if (!user) return;
    try {
      const data = await apiRequest(`/api/friends/${user.id}`, {}, true);
      setFriends(data.friends || []);
    } catch (error) {
      console.error('Error loading friends:', error);
    }
  }, [apiRequest, user]);

  const loadFriendRequests = useCallback(async () => {
    if (!user) return;
    try {
      const data = await apiRequest(`/api/friend-requests/${user.id}`, {}, true);
      setFriendRequests(data.requests || []);
    } catch (error) {
      console.error('Error loading friend requests:', error);
    }
  }, [apiRequest, user]);

  const loadNotifications = useCallback(async () => {
    if (!user) return;
    try {
      const data = await apiRequest(`/api/notifications/${user.id}`, {}, true);
      setNotifications(data.notifications || []);
    } catch (error) {
      console.error('Error loading notifications:', error);
    }
  }, [apiRequest, user]);

  // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø§ØªØµØ§Ù„ Ù…Ø¹ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ØªÙˆØ§Ø²ÙŠ
  const connect = useCallback(async (userData: ChatUser) => {
    setIsLoading(true);
    setUser(userData);
    
    try {
      // Ø¨Ø¯Ø¡ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù€ WebSocket ÙÙˆØ±Ø§Ù‹
      connectWebSocket(userData);
      
      // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø§Ù„ØªÙˆØ§Ø²ÙŠ
      await Promise.allSettled([
        loadUsers(),
        loadMessages(),
        loadFriends(),
        loadFriendRequests(),
        loadNotifications()
      ]);
      
      console.log('âœ… ØªÙ… Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù†Ø¬Ø§Ø­');
    } catch (error) {
      console.error('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„:', error);
    } finally {
      setIsLoading(false);
    }
  }, [connectWebSocket, loadUsers, loadMessages, loadFriends, loadFriendRequests, loadNotifications]);

  const disconnect = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
    }
    
    if (wsRef.current) {
      wsRef.current.close(1000, 'User disconnected');
    }
    
    setUser(null);
    setUsers([]);
    setMessages([]);
    setFriends([]);
    setFriendRequests([]);
    setNotifications([]);
    setIsConnected(false);
    setConnectionStatus('disconnected');
    
    // ØªÙ†Ø¸ÙŠÙ Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª
    dataCacheRef.current.clear();
    
    console.log('ğŸ‘‹ ØªÙ… Ù‚Ø·Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„');
  }, []);

  // ØªØ­Ø³ÙŠÙ† Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
  const sendMessage = useCallback((content: string, recipientId?: number) => {
    if (!user || !content.trim()) return;

    const message = {
      type: 'sendMessage',
      content: content.trim(),
      recipientId,
      timestamp: Date.now()
    };

    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify(message));
    } else {
      console.error('WebSocket ØºÙŠØ± Ù…ØªØµÙ„');
    }
  }, [user]);

  // ØªØ­Ø³ÙŠÙ† Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨Ø§Øª Ø§Ù„ØµØ¯Ø§Ù‚Ø©
  const sendFriendRequest = useCallback(async (targetUserId: number) => {
    if (!user) return;
    
    try {
      await apiRequest('/api/friend-requests', {
        method: 'POST',
        body: JSON.stringify({
          senderId: user.id,
          receiverId: targetUserId
        })
      });
      
      // ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª
      dataCacheRef.current.delete(`/api/friend-requests/${user.id}`);
      
      console.log('âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø©');
    } catch (error) {
      console.error('âŒ Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø©:', error);
      throw error;
    }
  }, [apiRequest, user]);

  const acceptFriendRequest = useCallback(async (senderId: number) => {
    if (!user) return;
    
    try {
      await apiRequest('/api/friend-requests/accept', {
        method: 'POST',
        body: JSON.stringify({
          senderId,
          receiverId: user.id
        })
      });
      
      // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      await Promise.all([
        loadFriends(),
        loadFriendRequests()
      ]);
      
      console.log('âœ… ØªÙ… Ù‚Ø¨ÙˆÙ„ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø©');
    } catch (error) {
      console.error('âŒ Ø®Ø·Ø£ ÙÙŠ Ù‚Ø¨ÙˆÙ„ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø©:', error);
      throw error;
    }
  }, [apiRequest, user, loadFriends, loadFriendRequests]);

  const declineFriendRequest = useCallback(async (senderId: number) => {
    if (!user) return;
    
    try {
      await apiRequest('/api/friend-requests/decline', {
        method: 'POST',
        body: JSON.stringify({
          senderId,
          receiverId: user.id
        })
      });
      
      await loadFriendRequests();
      console.log('âŒ ØªÙ… Ø±ÙØ¶ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø©');
    } catch (error) {
      console.error('âŒ Ø®Ø·Ø£ ÙÙŠ Ø±ÙØ¶ Ø·Ù„Ø¨ Ø§Ù„ØµØ¯Ø§Ù‚Ø©:', error);
      throw error;
    }
  }, [apiRequest, user, loadFriendRequests]);

  const removeFriend = useCallback(async (friendId: number) => {
    if (!user) return;
    
    try {
      await apiRequest('/api/friends/remove', {
        method: 'POST',
        body: JSON.stringify({
          userId: user.id,
          friendId
        })
      });
      
      await loadFriends();
      console.log('ğŸ‘‹ ØªÙ… Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØµØ¯ÙŠÙ‚');
    } catch (error) {
      console.error('âŒ Ø®Ø·Ø£ ÙÙŠ Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØµØ¯ÙŠÙ‚:', error);
      throw error;
    }
  }, [apiRequest, user, loadFriends]);

  // ØªØ­Ø³ÙŠÙ† Ù…Ø¤Ø´Ø± Ø§Ù„ÙƒØªØ§Ø¨Ø©
  const sendTyping = useCallback((typing: boolean) => {
    if (!user || !wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) return;

    wsRef.current.send(JSON.stringify({
      type: 'typing',
      userId: user.id,
      isTyping: typing,
      timestamp: Date.now()
    }));
  }, [user]);

  const handleSetTyping = useCallback((typing: boolean) => {
    setIsTyping(typing);
    sendTyping(typing);

    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }

    if (typing) {
      typingTimeoutRef.current = setTimeout(() => {
        setIsTyping(false);
        sendTyping(false);
      }, 3000);
    }
  }, [sendTyping]);

  // ØªÙ†Ø¸ÙŠÙ Ø¹Ù†Ø¯ Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ­Ù…ÙŠÙ„
  useEffect(() => {
    return () => {
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current);
      }
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }
      if (wsRef.current) {
        wsRef.current.close();
      }
    };
  }, []);

  return {
    user,
    users,
    messages,
    friends,
    friendRequests,
    notifications,
    isConnected,
    isLoading,
    connectionStatus,
    connect,
    disconnect,
    sendMessage,
    sendFriendRequest,
    acceptFriendRequest,
    declineFriendRequest,
    removeFriend,
    isTyping,
    setIsTyping: handleSetTyping
  };
}
// ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ø¹Ø§Ù… - ØªØ³Ø±ÙŠØ¹ Ø§Ù„Ø¯Ø®ÙˆÙ„ ÙˆØ§Ù„ØªØ­Ù…ÙŠÙ„
export class PerformanceOptimizer {
  private static instance: PerformanceOptimizer;
  private cache = new Map<string, any>();
  private preloadQueue: Promise<any>[] = [];

  static getInstance(): PerformanceOptimizer {
    if (!PerformanceOptimizer.instance) {
      PerformanceOptimizer.instance = new PerformanceOptimizer();
    }
    return PerformanceOptimizer.instance;
  }

  // ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø³Ø¨Ù‚
  async preloadResources(resources: string[]): Promise<void> {
    const promises = resources.map(resource => this.preloadResource(resource));
    this.preloadQueue.push(...promises);
    
    try {
      await Promise.allSettled(promises);
      console.log('ğŸš€ ØªÙ… Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø³Ø¨Ù‚ Ø¨Ù†Ø¬Ø§Ø­');
    } catch (error) {
      console.log('âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø³Ø¨Ù‚:', error);
    }
  }

  private async preloadResource(resource: string): Promise<void> {
    return new Promise((resolve) => {
      if (resource.endsWith('.mp3')) {
        const audio = new Audio(resource);
        audio.preload = 'metadata';
        audio.onloadedmetadata = () => resolve();
        audio.onerror = () => resolve();
      } else if (resource.endsWith('.css')) {
        const link = document.createElement('link');
        link.rel = 'preload';
        link.href = resource;
        link.as = 'style';
        link.onload = () => resolve();
        link.onerror = () => resolve();
        document.head.appendChild(link);
      } else {
        const img = new Image();
        img.onload = () => resolve();
        img.onerror = () => resolve();
        img.src = resource;
      }
    });
  }

  // ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª
  setCache(key: string, data: any, ttl: number = 30000): void {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl
    });
  }

  getCache(key: string): any | null {
    const cached = this.cache.get(key);
    if (!cached) return null;

    const age = Date.now() - cached.timestamp;
    if (age > cached.ttl) {
      this.cache.delete(key);
      return null;
    }

    return cached.data;
  }

  clearCache(): void {
    this.cache.clear();
  }

  // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø°Ø§ÙƒØ±Ø©
  optimizeMemory(): void {
    if ('memory' in performance) {
      const memory = (performance as any).memory;
      const usagePercent = memory.usedJSHeapSize / memory.jsHeapSizeLimit;
      
      if (usagePercent > 0.8) {
        console.log('ğŸ§¹ ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø©...');
        this.clearCache();
        
        // Ø¥Ø¬Ø¨Ø§Ø± ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø©
        if (window.gc) {
          (window as any).gc();
        }
      }
    }
  }

  // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø´Ø¨ÙƒØ©
  optimizeNetwork(): void {
    if ('connection' in navigator) {
      const connection = (navigator as any).connection;
      
      if (connection.effectiveType === 'slow-2g' || connection.effectiveType === '2g') {
        document.documentElement.classList.add('slow-connection');
        console.log('ğŸŒ ØªÙ… ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„Ø¨Ø·ÙŠØ¡');
      }
    }
  }

  // ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª ÙÙŠ Ø§Ù„Ù…ØªØµÙØ­
  async setupServiceWorker(): Promise<void> {
    if ('serviceWorker' in navigator) {
      try {
        await navigator.serviceWorker.register('/sw.js');
        console.log('ğŸ”§ ØªÙ… ØªØ³Ø¬ÙŠÙ„ Service Worker');
      } catch (error) {
        console.log('âš ï¸ Ø®Ø·Ø£ ÙÙŠ ØªØ³Ø¬ÙŠÙ„ Service Worker:', error);
      }
    }
  }

  // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø®Ø·ÙˆØ·
  preloadFonts(): void {
    const fonts = [
      'https://fonts.googleapis.com/css2?family=Cairo:wght@300;400;500;600;700&display=swap'
    ];

    fonts.forEach(font => {
      const link = document.createElement('link');
      link.rel = 'preload';
      link.href = font;
      link.as = 'style';
      document.head.appendChild(link);
    });
  }

  // ØªØ­Ø³ÙŠÙ† Ø§Ù„ØµÙˆØ±
  optimizeImages(): void {
    const images = document.querySelectorAll('img');
    images.forEach(img => {
      if (!img.loading) {
        img.loading = 'lazy';
      }
    });
  }

  // ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªÙ…Ø±ÙŠØ±
  optimizeScroll(): void {
    document.documentElement.style.scrollBehavior = 'smooth';
    
    // ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªÙ…Ø±ÙŠØ± Ù„Ù„Ø¹Ù†Ø§ØµØ±
    const scrollElements = document.querySelectorAll('[data-smooth-scroll]');
    scrollElements.forEach(element => {
      element.addEventListener('click', (e) => {
        e.preventDefault();
        const target = document.querySelector((e.target as HTMLElement).getAttribute('href') || '');
        if (target) {
          target.scrollIntoView({ behavior: 'smooth' });
        }
      });
    });
  }

  // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ø¹Ø§Ù…
  optimizePerformance(): void {
    // ØªÙ‚Ù„ÙŠÙ„ Ø§Ø³ØªØ®Ø¯Ø§Ù… CPU Ø¹Ù†Ø¯ Ø¹Ø¯Ù… Ø§Ù„ØªØ±ÙƒÙŠØ²
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        document.body.classList.add('page-hidden');
      } else {
        document.body.classList.remove('page-hidden');
      }
    });

    // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ù…ØªØ­Ø±ÙƒØ©
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (prefersReducedMotion) {
      document.documentElement.classList.add('reduce-motion');
    }

    // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
    this.debounceEvents();
  }

  // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
  private debounceEvents(): void {
    let resizeTimeout: NodeJS.Timeout;
    let scrollTimeout: NodeJS.Timeout;

    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        // Ø¥Ø¹Ø§Ø¯Ø© Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£Ø­Ø¬Ø§Ù…
        this.optimizeImages();
      }, 250);
    });

    window.addEventListener('scroll', () => {
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…Ø±Ø¦ÙŠØ©
        this.optimizeVisibleElements();
      }, 100);
    });
  }

  // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…Ø±Ø¦ÙŠØ©
  private optimizeVisibleElements(): void {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
        }
      });
    });

    document.querySelectorAll('[data-lazy]').forEach(element => {
      observer.observe(element);
    });
  }

  // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø§ØªØµØ§Ù„
  optimizeConnection(): void {
    // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª WebSocket Ù…Ø­Ø³Ù†Ø©
    const wsConfig = {
      binaryType: 'arraybuffer',
      maxReconnectAttempts: 5,
      reconnectInterval: 3000,
      heartbeatInterval: 30000
    };

    // Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
    this.setCache('ws-config', wsConfig);
  }

  // ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªØ­Ù…ÙŠÙ„
  optimizeLoading(): void {
    // Ø¥Ø¶Ø§ÙØ© Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„ØªØ­Ù…ÙŠÙ„
    const loadingElements = document.querySelectorAll('[data-loading]');
    loadingElements.forEach(element => {
      element.classList.add('loading');
      
      // Ø¥Ø²Ø§Ù„Ø© Ù…Ø¤Ø´Ø± Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø¹Ù†Ø¯ Ø§ÙƒØªÙ…Ø§Ù„ Ø§Ù„ØªØ­Ù…ÙŠÙ„
      setTimeout(() => {
        element.classList.remove('loading');
        element.classList.add('loaded');
      }, 1000);
    });
  }

  // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ù…Ø§Ù†
  optimizeSecurity(): void {
    // Ø¥Ø¶Ø§ÙØ© headers Ø§Ù„Ø£Ù…Ø§Ù†
    const meta = document.createElement('meta');
    meta.httpEquiv = 'Content-Security-Policy';
    meta.content = "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com;";
    document.head.appendChild(meta);
  }

  // Ø¨Ø¯Ø¡ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª
  async startOptimization(): Promise<void> {
    console.log('ğŸš€ Ø¨Ø¯Ø¡ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡...');
    
    try {
      // ØªØ­Ø³ÙŠÙ†Ø§Øª ÙÙˆØ±ÙŠØ©
      this.optimizeScroll();
      this.optimizePerformance();
      this.optimizeConnection();
      this.optimizeSecurity();
      this.preloadFonts();
      
      // ØªØ­Ø³ÙŠÙ†Ø§Øª Ù…ØªØ£Ø®Ø±Ø©
      setTimeout(() => {
        this.optimizeImages();
        this.optimizeLoading();
        this.optimizeNetwork();
      }, 100);

      // ØªØ­Ø³ÙŠÙ†Ø§Øª Ø¯ÙˆØ±ÙŠØ©
      setInterval(() => {
        this.optimizeMemory();
      }, 300000); // ÙƒÙ„ 5 Ø¯Ù‚Ø§Ø¦Ù‚

      console.log('âœ… ØªÙ… ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø¨Ù†Ø¬Ø§Ø­');
    } catch (error) {
      console.error('âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡:', error);
    }
  }
}

// ØªØµØ¯ÙŠØ± Ø§Ù„Ù…Ø«ÙŠÙ„ Ø§Ù„ÙˆØ­ÙŠØ¯
export const performanceOptimizer = PerformanceOptimizer.getInstance();

// ÙˆØ¸Ø§Ø¦Ù Ù…Ø³Ø§Ø¹Ø¯Ø©
export const debounce = <T extends (...args: any[]) => any>(
  func: T,
  wait: number
): ((...args: Parameters<T>) => void) => {
  let timeout: NodeJS.Timeout;
  return (...args: Parameters<T>) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => func(...args), wait);
  };
};

export const throttle = <T extends (...args: any[]) => any>(
  func: T,
  limit: number
): ((...args: Parameters<T>) => void) => {
  let inThrottle: boolean;
  return (...args: Parameters<T>) => {
    if (!inThrottle) {
      func(...args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
};

// ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø³Ø±ÙŠØ¹
export const fastLoad = {
  // ØªØ­Ù…ÙŠÙ„ Ø³Ø±ÙŠØ¹ Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  async loadData<T>(url: string, options?: RequestInit): Promise<T> {
    const cached = performanceOptimizer.getCache(url);
    if (cached) return cached;

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 10000);

    try {
      const response = await fetch(url, {
        ...options,
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      performanceOptimizer.setCache(url, data);
      return data;
    } catch (error) {
      clearTimeout(timeoutId);
      throw error;
    }
  },

  // ØªØ­Ù…ÙŠÙ„ Ù…ØªÙˆØ§Ø²ÙŠ Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  async loadParallel<T>(urls: string[]): Promise<T[]> {
    const promises = urls.map(url => this.loadData<T>(url));
    return Promise.allSettled(promises).then(results => 
      results.map(result => 
        result.status === 'fulfilled' ? result.value : null
      ).filter(Boolean) as T[]
    );
  }
};
import { pgTable, text, serial, integer, boolean, timestamp, varchar, jsonb } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  password: text("password"),
  userType: text("user_type").notNull().default("guest"), // 'guest', 'member', 'owner'
  profileImage: text("profile_image"),
  profileBanner: text("profile_banner"),
  status: text("status"),
  gender: text("gender"),
  age: integer("age"),
  country: text("country"),
  relation: text("relation"),
  isOnline: boolean("is_online").default(false),
  isHidden: boolean("is_hidden").default(false), // Ø®Ø§ØµÙŠØ© Ø§Ù„Ø¥Ø®ÙØ§Ø¡ Ù„Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©
  lastSeen: timestamp("last_seen"),
  joinDate: timestamp("join_date").defaultNow(),
  isMuted: boolean("is_muted").default(false),
  muteExpiry: timestamp("mute_expiry"),
  isBanned: boolean("is_banned").default(false),
  banExpiry: timestamp("ban_expiry"),
  isBlocked: boolean("is_blocked").default(false),
  ipAddress: varchar("ip_address", { length: 45 }),
  deviceId: varchar("device_id", { length: 100 }),
  ignoredUsers: text("ignored_users").array().default([]), // Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ØªØ¬Ø§Ù‡Ù„ÙŠÙ†
  usernameColor: text("username_color").default('#FFFFFF'), // Ù„ÙˆÙ† Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
  userTheme: text("user_theme").default('default'), // Ø«ÙŠÙ… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
});

export const messages = pgTable("messages", {
  id: serial("id").primaryKey(),
  senderId: integer("sender_id").references(() => users.id),
  receiverId: integer("receiver_id").references(() => users.id), // null for public messages
  content: text("content").notNull(),
  messageType: text("message_type").notNull().default("text"), // 'text', 'image'
  isPrivate: boolean("is_private").default(false),
  timestamp: timestamp("timestamp").defaultNow(),
});

export const friends = pgTable("friends", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id),
  friendId: integer("friend_id").references(() => users.id),
  status: text("status").notNull().default("pending"), // 'pending', 'accepted', 'blocked'
  createdAt: timestamp("created_at").defaultNow(),
});

export const notifications = pgTable("notifications", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  type: text("type").notNull(), // 'system', 'friend_request', 'message', 'promotion', etc.
  title: text("title").notNull(),
  message: text("message").notNull(),
  isRead: boolean("is_read").default(false),
  data: jsonb("data"), // Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ© 
  createdAt: timestamp("created_at").defaultNow(),
});

export const insertUserSchema = createInsertSchema(users).pick({
  username: true,
  password: true,
  userType: true,
  profileImage: true,
  profileBanner: true,
  status: true,
  gender: true,
  age: true,
  country: true,
  relation: true,
}).extend({
  // Ø¥Ø¶Ø§ÙØ© Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© ÙƒØ§Ø®ØªÙŠØ§Ø±ÙŠØ©
  isMuted: z.boolean().optional(),
  muteExpiry: z.date().optional(),
  isBanned: z.boolean().optional(),
  banExpiry: z.date().optional(),
  isBlocked: z.boolean().optional(),
  ipAddress: z.string().optional(),
  deviceId: z.string().optional(),
});

export const insertMessageSchema = createInsertSchema(messages).pick({
  senderId: true,
  receiverId: true,
  content: true,
  messageType: true,
  isPrivate: true,
});

export const insertFriendSchema = createInsertSchema(friends).pick({
  userId: true,
  friendId: true,
  status: true,
});

export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = typeof users.$inferSelect;
export type InsertMessage = z.infer<typeof insertMessageSchema>;
export type Message = typeof messages.$inferSelect;
export type InsertFriend = z.infer<typeof insertFriendSchema>;
export type Friend = typeof friends.$inferSelect;

export const insertNotificationSchema = createInsertSchema(notifications).pick({
  userId: true,
  type: true,
  title: true,
  message: true,
  data: true,
});

export type InsertNotification = z.infer<typeof insertNotificationSchema>;
export type Notification = typeof notifications.$inferSelect;
// Extended types for the chat application
export interface ExtendedUser {
  id: number;
  username: string;
  profileImage?: string;
  profileBanner?: string;
  userType: 'guest' | 'member' | 'admin' | 'owner';
  isOnline: boolean;
  usernameColor?: string;
  userTheme?: string;
  status?: string;
  gender?: string;
  age?: number;
  country?: string;
  relation?: string;
  lastSeen?: Date;
  joinDate?: Date;
  isHidden?: boolean;
  isMuted?: boolean;
  isBanned?: boolean;
  isBlocked?: boolean;
  ignoredUsers?: string[];
}

export interface ExtendedMessage {
  id: number;
  senderId: number | null;
  receiverId?: number | null;
  content: string;
  messageType: 'text' | 'image' | 'file';
  isPrivate: boolean;
  timestamp: Date;
  sender?: ExtendedUser;
  senderName?: string;
}
